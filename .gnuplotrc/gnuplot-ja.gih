?gnuplot
?copyright
?license
     Copyright (C) 1986 - 1993, 1998, 2004, 2007  Thomas Williams, Colin Kelley

 Permission to use, copy, and distribute this software and its
 documentation for any purpose with or without fee is hereby granted,
 provided that the above copyright notice appear in all copies and
 that both that copyright notice and this permission notice appear
 in supporting documentation.

 Permission to modify the software is granted, but not the right to
 distribute the complete modified source code.  Modifications are to
 be distributed as patches to the released version.  Permission to
 distribute binaries produced by compiling modified sources is granted,
 provided you
   1. distribute the corresponding source modifications from the
    released version in the form of a patch file along with the binaries,
   2. add special version identification to distinguish your version
    in addition to the base release version number,
   3. provide your name and address as the primary contact for the
    support of your modified version, and
   4. retain our contact information in regard to use of the base software.
 Permission to distribute the released version of the source code along
 with corresponding source modifications in the form of a patch file is
 granted with same provisions 2 through 4 for binary distributions.

 This software is provided "as is" without express or implied warranty
 to the extent permitted by applicable law.

       AUTHORS
               Original Software:
                  Thomas Williams,  Colin Kelley.
               Gnuplot 2.0 additions:
                  Russell Lang, Dave Kotz, John Campbell.
               Gnuplot 3.0 additions:
                  Gershon Elber and many others.
               Gnuplot 4.0 and 5.0 additions:
                  See list of contributors at head of this document.

 (以下おおまかな訳; 訳は正しくないかも知れませんので詳しくは上記の原文
 を当たってください。訳者は責任を持ちません。)

     Copyright (C) 1986 - 1993, 1998, 2004, 2007  Thomas Williams, Colin Kelley

 このソフトウェアとその付属文書の使用、複製、配布の許可は、上記の著作権
 (copyright) 表示が、全ての複製物に書かれていること、および著作権表示と
 この許諾文の両方がその支援文書に書かれていることを条件とした上で、この
 文書により保証されます。

 このソフトウェアの修正も認められています。しかし、修正を含む全ソースコ
 ードの配布の権利は認められません。修正はリリース版に対するパッチの形で
 配布しなければなりません。修正されたソースをコンパイルして作られたバイ
 ナリの配布は、以下の条件の元で認められます:
   1. リリース版からのソースの修正部分を、パッチの形でバイナリと共に配
      布すること
   2. ベースとなるリリース版と区別するために、そのバージョン番号に特別
      なバージョン指定子を付加すること
   3. その修正版のサポート用に、あなたの名前とアクセス可能なアドレスと
      を提供すること
   4. ベースとなるソフトウェアの使用に関しては、我々の連絡情報を保持し
      続けること
 リリース版のソースコードを、パッチの形でのソースの修正と一緒に配布する
 ことは、バイナリ配布に関する条項 2 から 4 までの条件の元で許されます。

 このソフトウェアは "あるがまま" 提供され、適用可能な法律で許められる範
 囲の保証を表明あるいは暗示していはいません。

       著者
               オリジナルソフトウェア:
                  Thomas Williams,  Colin Kelley.
               Gnuplot 2.0 追加:
                  Russell Lang, Dave Kotz, John Campbell.
               Gnuplot 3.0 追加:
                  Gershon Elber とその他の人々。
               Gnuplot 4.0, 5.0 追加:
                  この文書の先頭の寄与者 (contributors) の一覧参照。
?introduction
?
 `gnuplot` は、ポータブルなコマンド入力方式のグラフユーティリティで、
 Linux, OS/2, MS Windows, OSX, VMS, その他多くのプラットホーム上で動作
 します。ソースコードには著作権がありますが、無料で配布されています (す
 なわち、それに対価を支払う必要はありません)。元は、科学者や学生が数学
 関数やデータなどを対話的に表示できるよう作られたのですが、現在までに、
 例えば Web スクリプトなど、多くの非対話型の利用もサポートするように成
 長しています。これは、例えば Octave のようにサードパーティのアプリケー
 ションの描画エンジンとしても使われています。gnuplot は、1986 よりサポ
 ートと活発な開発が行われています。

 gnuplot は、2 次元、または 3 次元の、多くの種類のグラフをサポートして
 います: 折線グラフ、点グラフ、棒グラフ、等高線、ベクトル場描画、曲面、
 そしてそれらに関連するさまざまな文字列等。そしてさらにいくつかの特別な
 描画型もサポートしています。

 gnuplot は多くの異なる出力をサポートしています: 対話型スクリーン出力形
 式 (マウスやホットキー入力も可能)、ペンプロッタや現在のプリンタへの直
 接出力、または多くのファイル形式への出力 (eps, emf, fig, jpeg, LaTeX,
 pdf, png, postscript, ...)。gnuplot は、容易に新しい出力形式を追加する
 よう拡張することができます。最近追加された対話型出力形式には、
 wxWidgets (複数のプラットホームで利用可能), Qt を元にしたものがありま
 す。svg や HTML5 canvas 出力形式を利用すれば、グラフを Web ページ内に
 マウス利用可能な形で埋め込んだ出力を生成することもできます。

 `gnuplot` のコマンド言語は大文字小文字を区別します。すなわち、小文字で
 書かれたコマンドや関数名は、それらを大文字で書いたものとは同じではあり
 ません。いずれのコマンドも、あいまいさの無い限りにおいて省略することが
 できます。1 行中にはセミコロン (;) で区切って複数のコマンドを書くこと
 ができます。文字列は単一引用符、あるいは二重引用符のどちらかで書き始め
 ますが、両者には微妙な違いがあります (詳細は、以下参照: `syntax`)。例:

       set title "My First Plot";  plot 'data';  print "all done!"

 コマンドは、複数行にまたがることができます。その場合は、最終行以外の
 全ての行の行末にバックスラッシュ (\) を書く必要があります。バックスラ
 ッシュは必ず各行 *最後* の文字でなくてはなりません。その結果としてバッ
 クスラッシュと、それに続く改行文字が存在しなかったかのように扱われます。
 つまり、改行文字がスペースの役をすることもありませんし、改行によってコ
 メントが終了することもありません。ですから複数行にまたがる行の先頭をコ
 メントアウトすると、そのコマンド全体がコメントアウトされることになりま
 す (以下参照: `comments`)。なお注意しますが、もし、複数行のコマンドの
 どこかでエラーが起きたとき、パーサはその場所を正確には指示することがで
 きませんし、また、正しい行に指示する必要もないでしょう。

 このドキュメントにおいて、中括弧 ({}) は省略可能な引数を表すものとし、
 縦棒 (|) は、互いに排他的な引数を区切るものとします。`gnuplot` のキー
 ワードや `help` における項目名は、逆引用符 (｀)、または可能な場合には
 `boldface` (太字) で表します。角括弧 (<>) は、それに対応するものに置き
 換えられるべきものを表します。多くの場合、オプションの引数には、それが
 省略されるとデフォルトの値が使用されます。しかし、これらの場合、必ずし
 も角括弧が中括弧で囲まれて書かれているわけではありません。

 ある項目についてのヘルプが必要なときには、`help` に続けてその項目名を
 入力して下さい。または単に `help ?` でもヘルプの項目のメニューが現われ
 ます。

 大量のグラフサンプルが、以下の Web ページにあります。
           http://www.gnuplot.info/demo/
 コマンドラインから起動するときは、以下の書式が使えます。
       gnuplot {OPTIONS} file1 file2 ...
 ここで file1, file2 等は、`local` コマンドで取り込むのと同等の入力ファ
 イル (スクリプトファイル) です。
 X11 ベースのシステムでは、以下の書式が使えます。
       gnuplot {X11OPTIONS} {OPTIONS} file1 file2 ...
 詳細は、X11 のドキュメント、および以下参照: `x11`。

 gnuplot に与えるオプションは、コマンド行のどこに置いても構いません。フ
 ァイルは指定した順に実行され、同様に -e オプションで任意のコマンドを与
 えることもできます。例:
       gnuplot   file1.in   -e "reset"   file2.in

 特別なファイル名 "-" は、標準入力から読ませるのに使います。`gnuplot`
 は最後のファイルを処理し終わると終了します。読み込ませるファイルを一つ
 も指定しない場合は、`gnuplot` は標準入力からの対話入力を取ります。詳細
 は、以下参照: `batch/interactive`。gnuplot 用のオプションについては、
 以下のようにして一覧を見ることができます:
       gnuplot --help
 詳細は以下参照: `command line options`。

 対話型描画ウィンドウでの作業中は、'h' を打つとホットキー (`hotkeys`)
 とマウス機能 (`mousing`) に関するヘルプを見ることができます。
 `seeking-assistance` のセクションは、さらなる情報やヘルプ、FAQ を探す
 手掛りを与えてくれるでしょう。
?help-desk
?faq
?FAQ
?seeking-assistance
 公式の gnuplot Web ページは以下にあります。
           http://www.gnuplot.info

 助けを求める前に、ファイル FAQ.pdf か、または上の Web サイトの
           FAQ (度々聞かれる質問; Frequently Asked Questions) の一覧
 をチェックしてください。

 gnuplot ユーザとしての手助けが必要なら、以下のニュースグループを利用し
 てください。
           comp.graphics.apps.gnuplot

 gnuplot メーリングリストへの投稿の方法に関しては、SouceForge にある
 gnuplot の開発 Web サイト
           http://sourceforge.net/projects/gnuplot
 を参照してください。

 gnuplot メーリングリストにメールを書く前に、最初にそのメーリングリスト
 に参加する必要があることに注意してください。これは、スパムの量を減らす
 ことを維持するために必要です。

 メーリングリストメンバーへのメールアドレス:
           gnuplot-info@lists.sourceforge.net

 バグリポート、ソースの改良等は以下の trackers に upload してください:
           http://sourceforge.net/projects/gnuplot/support
 ただし、リポートを送る前に、あなたがリポートしようとしているバグが、よ
 り新しい版で既に修正されていないかチェックしてください。

 開発版に関するメーリングリスト:
           gnuplot-beta@lists.sourceforge.net

 何か質問を投稿するときは、あなたが使用している gnuplot のバージョン、
 出力形式、オペレーティングシステム、といった全ての情報を含むようにして
 ください。それだけで閉じていて、その問題を再現する短いスクリプトを提示
 するとなお良いでしょう。

?new version_5.2
?new
 バージョン 5.2 は gnuplot の現在の安定版系列です。
 以下の新機能の一覧は、2017 5 月時点で最新のものです。
?new plot styles
 *  3 次元描画スタイル `with zerrorfill`。以下参照: `zerrorfill`,
    `fenceplots`,
   zerror デモ。
 *  ビースウォームグラフ。以下参照: `set jitter`, `beeswarm`,
   ビースウォームグラフデモ。
 *  グラフの点 (points) で使われる個々の記号は、データ値で制御できます。
    (以下参照: `pointtype variable`)
 *  `plot`, `splot` コマンドのファイル名か関数を `keyentry` で置き換える
    ことで凡例のカスタマイズ用の余分な線を追加可能に。
   これは、対応するグラフは描かずに凡例中にそれ用の 1 行を作ります。
   以下参照: `keyentry`。
?new filters
 *  データ集合内での出現回数の正規化 (以下参照: `smooth fnormal`)
 *  データの階級幅割り当ての自動化 (以下参照: `bins`)
?new polar mode features
 *  ラベル、矢 (arrow)、オブジェクトの定義に極座標が使えます。
 *  `set [m]ttics` は極座標モードでの外周方位軸のラベルと刻みを配置しま
    す。以下参照:
   極座標軸と刻みラベルデモ
 *  `set rlabel` は動径軸 (r 軸) の上にラベルを配置します。
 *  逆向きの `rrange` (例: set rrange [90:0]) で天球地平座標 (celestial
    horizontal coordinates) が使えるようになります。以下参照:
   天体軌道デモ
 *  `set border polar` は極座標の外周の回りに実線を描きます。
 *  `set theta` は極座標グラフの外周方位軸での theta = 0 の位置と、角の
    増加方向 (時計回りか反時計回りか) を制御します。
?new nonlinear coordinates
 *  グラフの任意の軸に、線形の範囲への写像とその逆写像を意味する関数の組
    を割り当てることができ、それを非線形にすることも可能です (以下参照:
    `set nonlinear`)。
   非線形 x,y 軸デモ
 *  なじみ深いコマンド `set logscale` は、現在は関数の組 log(x), exp(x)
    による非線形軸の例の一つとして再実装されました。
?new commands
 *  繰り返し実行部分の中カッコ内では、`continue` は次の繰り返しにすぐに
    移動し、`break` は繰り返しを中断します。
 *  `toggle {<plotno> | "plottitle" | all}"` は、対話的に現在のグラフの
    構成要素を表示させるか消すかを選択できます。
 *  `save fit` は非推奨のコマンド `update` を置き換え
 *  `set table "outfile.name" append` で、その後の table 出力を、既に存
    在するテキストファイルを上書きせず、追加出力にします。
 *  `set pm3d lighting` で、反射光ハイライトによる点光源モデルを使用しま
    す (以下参照: `lighting`)。
 *  `set minussign` は、負の数でのアスキー文字 '-' を、現在のエンコード
    での特殊文字に置き換えるよう gnuplot に指示します。
 *  `set micro` は、科学用接頭辞の「マイクロ」用のアスキー文字 'u' を、
    現在のエンコードでの特殊文字に置き換えるよう gnuplot に指示します。
    micro, minussign の特殊印刷記号は、軸刻みラベルと、明示的に gprintf()
    で生成した文字列にのみ使用します。それらの文字表現のバイト列は、現在
    のエンコード設定に依存します。
?new features
 *  このバージョンの gnuplot には、新しい配列データ型 `array name[size]`
    が導入されています。配列は、使用する前に宣言しなければいけません。各
    配列要素 A[i] は、文字列、整数、実数、複素数のいずれでも構いません。
    一つの配列が異なる型の要素を持つことも可能です。基数演算子 |A| は配
    列のサイズを返します。以下参照: `arrays`。

 *  新しい `sixelgd` 出力形式は、vt340 と互換の端末エミュレータ上で
    gnuplot を実行した場合に、グラフを出力する命令のコマンドラインの合間
    にグラフを挟むような出力をサポートします。以下参照: `sixelgd`。
 *  `domterm` 出力形式は、svg を解釈する端末エミュレータ上で gnuplot を
    実行した場合に、グラフを出力する命令のコマンドラインの合間にグラフを
    挟むような出力をサポートします。
 *  `windows` 出力形式は、現在のグラフのビットマップファイルへの保存をサ
    ポートします。
 *  `windows` 出力形式は、グラフウィンドウと wgnuplot テキストウィウンド
    ウをドッキングできます。
 *  `windows` 出力形式用 (試験的) Direct2D/DirectWrite 新バックエンド。
 *  `wxt` 出力形式は、Windows 上では EMF ファイルへの出力とプリンタ出力
    をサポート。
 *  `dumb` 出力形式は、線と領域の塗り潰しで ANSI カラーをサポート。
 *  `tkcanvas` 出力形式は、新しい言語と、最近の gnuplot の多くの機能をサ
    ポートするように書き直されています (5.0.3 より)。
 *  3 次元グラフの向きに影響する追加回転角 `azimuth`。これは、コマンドラ
    インから (以下参照: `set view azimuth`)、または右マウスボタンのドラ
    ッグで設定できます。
 *  Windows 上の gnuplot では、Unicode (BMP) スクリプトの入力を、
    `set encoding` による現在のエンコード (UTF-8 を含む) に変換して解釈
    します。
 *  文字枠に境界色と背景色を指定できます (以下参照: `set style textbox`)
 *  グラフの表題のカスタマイズ (以下参照: `plot title`, `set key`,
    `multiple keys`)
 *  疑似ファイル '+' でのグラフのサンプリング範囲指定にサンプリング区間
    を指定できます。例:
    plot sample [t=0:100:10] '+' using (t):(1):(label[t]) with labels
 *  疑似ファイル '++' は、x, y 軸でなく u, v 軸に沿ったサンプリングを行
    います。これは、3 次元グラフ中に、別々のデカルト座標領域を占めるよう
    な複数の媒介変数曲面を置くのに便利でしょう。
 *  ^R で、組み込み readline (Windows でも使われている) の履歴の逆向き検
    索を開始します。以下参照: `command-line-editing`。
 *  Windows での `set output "PRN"` による印刷の改良。以下参照:
    `windows printing`。

?Features introduced in version 5.0
 *  線の点線/破線パターンは、現在は線の他の属性と独立に指定できます。以
    下参照: `dashtype`, `set dashtype`, `set linetype`。
 *  一つの plot での連続した要素に使用されるデフォルトの色の巡回列は、色
    弱者により容易に区別できるものになりました。その色の巡回列は、ユーザ
    が制御できます (以下参照: `set colorsequence`)。この仕組みは、白黒の
    グラフを生成することでも行えます (以下参照: `set monochrome`)。なお、
    従来の gnuplot のバージョンでは `monochrome` は、現在の出力形式を
    `set temrinal` で変更するときにのみにしか選択できませんでした。
 *  新しい描画スタイル `with parallelaxes`、`with table`、および等高線の
    ラベル付け。
 *  単調 3 次スプラインによるデータの新しい前処理フィルタ (以下参照:
    `smooth mcsplines`)
 *  文字の書式制御は、下付き、上付き、フォントサイズ、その他以前有効だっ
    たものに加え、今は太字体 (bold) と斜体 (italic) フォント設定もサポー
    トしています。このモード (拡張文字処理) は、現在はデフォルトで有効と
    なっています。以下参照: `enhanced text`。文字列要素は枠で囲むことも
    できます (以下参照: `set style textbox`)。
 *  対話型出力形式は、ハイパーテキストラベルをサポートしていますが、これ
    はマウスがそのラベルのリンク点上にあるときにのみ現れるものです。
 *  新しい座標系 (度、分、秒)。以下参照: `set xtics geographic`。
 *  軸の見出しのデフォルト書式用の "% h" (LaTeX 系出力形式では "$%h$")。
    この書式は C の標準書式の %g に似ていますが、指数部分がある場合は、
    それが上付き文字として書かれることが違います。例えば、1.2E05 でなく
    1.2 x 10^5 となります。
 *  スクリプト内で、インラインデータを名前付きのデータブロックとして保存
    し繰り返し描画できるように。以下参照: `inline data`。
 *  32-bit のアルファ値 + RGB 色表記 (#AARRGGBB) をサポート。以下参照:
    `colorspec`。
 *  hsv2rgb(H,S,V) という変換関数による HSV 色空間のサポート。
 *  第 2 軸 (x2, y2) は、対応関数により、第 1 軸に固定できます。最も単純
    なのは、これにより第 1 軸と 2 軸の軸の範囲を一致させることです。より
    一般に、これにより非線形な軸を定義できるようになりますが、これまでは
    そのようなことは対数軸しかできませんでした。以下参照: `set link`。
 *  plot コマンドの各関数にオプションとして描画範囲を前置指定できます。
    これは、plot 全体の範囲には影響せず、その関数のデータをサンプリング
    する範囲でしかありません。以下参照: `plot`, `piecewise.dem`。
 *  外部ライブラリ libcerf が利用可能であれば、それは複素数学関数 cerf,
    cdawson, erfi, faddeeva, および Voigt プロファイル VP(x,sigma,gamma)
    を提供するのに使われます。
 *  コマンド `import` は、外部共有オブジェクト (サポートはオペレーティン
    グシステム依存) が提供する関数にユーザ定義関数名を割り当てます。適当
    な外部共有オブジェクトを作るためのテンプレートヘッダファイル、サンプ
    ルソース、makefile などが demo の中にあります。
 *  対話作業の履歴一覧内の直前のコマンドは、番号で再実行できます。例えば
    `history !5` は、`history` の一覧内の 5 番のコマンドを再実行します。
 *  ビットシフト演算子 >> と <<。
 *  gnuplot のシェル呼び出しで gnuplot スクリプトにパラメータを渡せます。
    gnuplot -c scriptfile.gp ARG1 ARG2 ARG3 ...

?changes
?differences
 バージョン 5 で導入されたいくつかの変更は、前の版の gnuplot 用のスクリ
 プトの挙動を変える可能性があります。

 * NaN や、正しくないデータ列数、または他の予期しないものを含む入力デー
 タの処理の改良。例 (や図) については、以下参照: `missing`。

 * 時間座標は、標準的な Unix エポック (1970 年 1 月 1 日) からの秒数と
 して内部で保存します。以前の版の gnuplot では、別のエポック (2000 年
 1 月 1 日) を内部で使用していました。この変更は、gnuplot の外で作られ
 た秒単位のデータによって矛盾がもたらされる問題を解決します。インストー
 ルされている個々の gnuplot がどちらのエポックを使用しているかについて
 は、コマンド `print strftime("%F",0)` で知ることができます。現在は、時
 間は少なくともミリ秒の精度で保存されます。

 * 関数 `timecolumn(N,"timeformat")` は、現在は 2 つの引数を持ちます。
 新しい 2 つ目の引数はどのデータ軸とも関連しておらず、よってこれにより
 関数 `timecolumn` を、x や y 軸に指定するのとは違う形式の日時データの
 読み込みに使えるようになります。この機能は、次のコマンド列に取って変わ
 ります: `set xdata time; set timefmt "timeformat"`。これは、複数のファ
 イルから異なる書式の日時データを読んで、それらを組み合わせて 1 つのグ
 ラフにすることを可能にします。

 * コマンド `set [axis]range` のキーワード `reverse` は、自動縮尺
 (autoscaling) にのみ影響し、`set xrange [0:1]` のようなコマンドの意味
 を逆にしたり他の変更を行ったりはしません。このような場合に x 軸の方向
 を逆向きにしたければ、代わりに `set xrange [1:0]` としてください。

 * コマンド `call` は、変数群 ARGC, ARG0, ..., ARG9 を提供します。ARG0
 は、実行するスクリプト名を指します。ARG1 から ARG9 は文字列変数になる
 ので、直接参照するか、または例えば @ARG1 のようにマクロ展開させたもの
 を参照することができます。ARG0 ... ARG9 の内容は、他にも配列変数 ARGV
 の要素 ARGV[0] ... ARGV[ARGC] としても取得できます。古い gnuplot での
 call のパラメータ参照形式 $0 ... $9 は現在は非推奨です。

 * オプション smooth の kdensity の、bandwidth の追加指定では、データ列
 からでなく 1 つのキーワードとして値を取ります。以下参照:
 `smooth kdensity`。

?deprecated syntax
?backwards compatibility
?compatibility
 以前の版で使われていたいくつかの書式は gnuplot 4 で非推奨となりました
 が、後方互換性を持たせるためのコンパイル時のオプションが用意されていま
 す。古い書式のサポートは現在は削除されています。

 gnuplot 4 では非推奨で、バージョン 5 では削除:
       set title "Old" 0,-1
       set data linespoints
       plot 1 2 4               # y=1 での水平線
 現在の同等の機能:
       TITLE = "New"
       set title TITLE offset char 0, char -1
       set style data linespoints
       plot 1 linetype 2 pointtype 4
 バージョン 5.0 では --enable-backwards-compatibility で構築された場合
 は使えるが非推奨:
       if (defined(VARNAME)) ...
       set style increment user
       plot 'file' thru f(x)
       call 'script' 1.23 ABC
          (in script:  print $0, "$1", "number of args = $#")
 現在の同等の機能:
       if (exists("VARNAME")) ...
       set linetype
       plot 'file' using 1:(f(column(2)))
       call 'script' 1.23 "ABC"
          (in script:  print ARG1, ARG2, "number of args = ", ARGC
?demos
?online examples
?examples
 `gnuplot` の配布物の `demo` ディレクトリ内には、多くのサンプルが収めら
 れています。これらのサンプルの png, svg, canvas 出力形式による出力を、
 以下のネット上で見ることもできます:
   http://gnuplot.info/demos
 そこでは、各デモを作成するコマンドがグラフの隣りに表示されますし、その
 gnuplot スクリプトをダウンロードすることもできますので、それを保存し同
 様のグラフを作成することができます。

?batch/interactive
?command line options
 `gnuplot` は多くのシステム上で、バッチ処理形式、あるいは対話型のどちら
 の形式でも実行でき、それらを組み合わせることも可能です。

 コマンドライン引数は、プログラムへのオプション (文字 - で始まる) か、
 `gnuplot` コマンドを含むファイルの名前であると解釈されます。
 -e "command" の形式のオプションは、gnuplot コマンドを強制的に実行させ、
 各ファイルとこのコマンド文字列は、指定された順に実行されます。特別なフ
 ァイル名 "-" は、コマンドを標準入力から読み込むことを意味します。最後
 のファイルを実行した後に `gnuplot` は終了します。読み込ませるファイル、
 およびコマンド文字列を指定しなかった場合は、`gnuplot` は標準入力からの
 対話型の入力を受け付けます。

 `exit` と `quit` はどちらも現在のコマンドファイルを終了し、まだ全ての
 ファイルが終っていなければ、次のファイルを `load` するのに使われます。

 例:

 対話を開始する:
       gnuplot

 2 つのコマンドファイル "input1", "input2" を使ってバッチ処理を行なう:
       gnuplot input1 input2

 初期化ファイル "header" の後、対話型モードを起動し、その後別のコマンド
 ファイル "tailer" を実行する:
       gnuplot header - trailer

 コマンドラインから `gnuplot` コマンドを直接与え、終了後にスクリーン上
 にグラフが残るようにオプション "-persist" を使う:
        gnuplot -persist -e "set title 'Sine curve'; plot sin(x)"

 ファイルのコマンドを実行する前に、ユーザ定義変数 a と s をセットする:
       gnuplot -e "a=2; s='file.png'" input.gpl

?canvas size
?canvas
?set term size

 gnuplot の以前の版では、`set size` の値を、出力する描画領域 (キャンバ
 ス) のサイズを制御するのにも使っていた出力形式もありましたが、すべての
 出力形式がそうだったわけではありませんでした。この目的のために
 `set size` を使用することはバージョン 4.2 で非推奨となり、現在はほとん
 どの出力形式が以下のルールに従います:

 `set term <terminal_type> size <XX>, <YY>` は、出力ファイルのサイズ、
 または "キャンバス" のサイズを制御します。デフォルトでは、グラフはその
 キャンバス全体に描画されます。

 `set size <XX>, <YY>` は、描画自体をキャンバスのサイズに対して相対的に
 伸縮させます。1 より小さい伸縮値を指定すると、グラフはキャンバス全体を
 埋めず、1 より大きい伸縮値を指定すると、グラフの一部分のみがキャンバス
 全体に合うように描画されます。1 より大きい伸縮値を指定すると、問題が起
 こるかもしれないことに注意してください。

 このルールに沿わない主な例外は PostScript ドライバで、デフォルトでは以
 前の版と同じ振舞いをしますが、将来は PostScript ドライバも同様にデフォ
 ルトの振舞いを変更することになるでしょう。

 例:

       set size 0.5, 0.5
       set term png size 600, 400
       set output "figure.png"
       plot "data" with lines

 このコマンドは、幅 600 ピクセル、高さ 400 ピクセルの出力ファイル
 "figure.png" を生成します。グラフはキャンバスの中の左下に置かれます。
 これは、multiplot モードが常に行ってきた方法と矛盾しません。

?line-editing
?editing
?command-line-editing
 コマンドラインでの編集機能とコマンドヒストリの機能は、外部の GNU
 readline ライブラリか外部の BSD libedit ライブラリ、または組み込まれて
 いる同等のもののいずれかを使ってサポートしています。この選択は、
 gnuplot のコンパイル時の configure のオプションで行います。

 組み込みの readline 版の場合の編集コマンドは以下の通りですが、DEL キー
 に関する動作はシステムに依存することに注意してください。GNU readline
 ライブラリと BSD libedit ライブラリに関しては、それ自身のドキュメント
 を参照してください。

       `行編集`:

       ^B    1 文字前へ戻す
       ^F    1 文字先へ進める
       ^A    行の先頭に移動
       ^E    行の最後に移動
       ^H    直前の文字を削除
       DEL   現在の文字を削除
       ^D    現在位置の文字を削除、空行なら EOF を送信
       ^K    現在位置から行末まで削除
       ^L    壊れた表示の行を再表示
       ^U    行全体の削除
       ^W    直前の単語を削除
       ^V    この次のキーを編集コマンドと見なさない
       TAB   ファイル名補完動作

       `履歴`:

       ^P    前の履歴へ移動
       ^N    次の履歴へ移動
       ^R    後方検索を開始


?comments
 コメント記号 `#` は、コマンド行中のほとんどどこにでも書くことができま
 す。このとき `gnuplot` は、その行の残りの部分を無視します。ただし、記
 号 `#` は引用符内ではこの効果がありません。コメント行が '\' で終わって
 いる場合、次の行もコメントの一部として扱われることに注意してください。

 データファイルに対するコメント文字の指定については、以下参照:
 `set datafile commentschars`。
?coordinates
 コマンド `set arrow`, `set key`, `set label`, `set object` はグラフ上
 の任意の位置が指定できます。その位置は以下の書式で指定します:

       {<system>} <x>, {<system>} <y> {,{<system>} <z>}

 各座標系指定 <system> には、`first`, `second`, `polar`, `graph`,
 `screen`, `character` のいずれかが入ります。

 `first` は左と下の軸で定義される x,y (3D の場合は z も) の座標系を使用
 します。`second` は x2, y2 軸 (上と右の軸) を使用します。`graph` はグ
 ラフ描画領域内の相対的位置を指定し、左下が 0,0 で 右上が 1,1 (splot の
 場合はグラフ描画領域内の左下が 0,0,0 で、土台の位置は負の z の値を使用
 します。以下参照: `set xyplane`) となります。`screen` は表示範囲内 (範
 囲全体であり、`set size` で選択される一部分ではありません) を指定し、
 左下が 0,0 で 右上が 1,1 となります。`character` 座標は主にずれを指定
 するのに使用し、絶対的な位置を示すものではありません。`character` の水
 平、垂直サイズは、現在使用しているフォントに依存します。

 `polar` は、最初の 2 つの値を、x, y ではなく、角 theta と半径 r である
 と解釈します。これは、例えば 2 次元の極座標、あるいは 3 次元円柱座標で
 のグラフにラベルを配置するのに役に立つでしょう。

 x の座標系が指定されていない場合は `first` が使われます。y の座標系が
 指定されていない場合は x に対する座標系が使用されます。

 与える座標が絶対的な位置ではなくて相対的な値である場合もあります (例え
 ば `set arrow` ... `rto` の 2 番目の数値)。そのほとんどが、与えられた
 数値を最初の位置に対する差として使います。与えられた座標が対数軸内にあ
 る場合は、その相対的な値は倍率として解釈されます。例えば

       set logscale x
       set arrow 100,5 rto 10,2

 は、x 軸が対数軸で y 軸が線形の軸なので、100,5 の位置から 1000,7 の位
 置への矢印を書くことになります。

 一つ (あるいはそれ以上) の軸が時間軸である場合、`timefmt` の書式文字列
 に従って、引用符で囲まれた時間文字列で適切な座標を指定する必要がありま
 す。以下参照: `set xdata`, `set timefmt`。また、`gnuplot` は整数表記も
 認めていて、その場合その整数は 1970 年 1 月 1 日からの秒数と解釈されま
 す。
?datastrings
 データファイルには、ホワイトスペース (空白やタブ) を含まない任意の印字
 可能な文字列、あるいは 2 重引用符で囲まれた任意の文字列 (ホワイトスペ
 ースが含まれても良い)、のいずれかの形からなる文字列データを持たせるこ
 とも可能です。データファイルに次のような行が含まれている場合、それは 4
 つの列を含み、3 列目がテキスト部分であると見なされます:

   1.000 2.000 "Third column is all of this text" 4.00

 テキスト部分は 2 次元や 3 次元描画内で例えば以下のように使用されます:

   plot 'datafile' using 1:2:4 with labels
   splot 'datafile' using 1:2:3:4 with labels

 テキスト部分の列データは 1 つ、または複数の描画軸の目盛りのラベルとし
 て使用できます。次の例は、入力データの 3 列目と 4 列目を (X,Y) 座標と
 して取り出し、それらの点の列を結ぶ線分を描画します。しかしこの場合
 gnuplot は、x 軸に沿って標準的に間の空いた数字ラベルのついた目盛り刻み
 をつけるのではなく、入力データファイルの 1 行目の X 座標の位置に、目盛
 り刻みと文字列を x 軸に沿ってつけて行きます。

   set xtics
   plot 'datafile' using 3:4:xticlabels(1) with linespoints

 入力データの列の最初のエントリ (すなわち列の見出し) をテキスト部分と解
 釈するもう一つのオプションがあり、それはテキスト部分を、その描画した列
 のデータの凡例 (key) のタイトル部分として使用します。次の例は、先頭の
 行の 2 列目の部分を凡例ボックス内のタイトルを生成するのに使用し、その
 後の列の 2,4 列目は要求された曲線を描画するのに処理されます:

   plot 'datafile' using 1:(f($2)/$4) with lines title columnhead(2)

 別の例:

   plot for [i=2:6] 'datafile' using i title "Results for ".columnhead(i)

 この列の先頭を使用する方法は、`set key autotitle columnhead` で自動化
 できます。 以下参照: `labels`, `using xticlabels`, `plot title`,
 `using`, `key autotitle`。
?enhanced text
?enhanced
?text_markup
?markup
?bold
?italic
 多くの出力形式が、拡張文字列処理モード (enhanced text mode) をサポート
 しています。これは、文字列に追加の書式情報を埋めこみます。例えば "x^2"
 は x の自乗を、通常我々が見る上付きの 2 がついた形で書き出します。この
 モードは、出力形式の設定時にデフォルトとして選択されますが、その後で
 "set termoption [no]enhanced" を使ってその機能を有効/無効にもできます
 し、"set label 'x_2' noenhanced" のように個々の文字列に適用することも
 できます。

  制御記号     例              説明
   ^           a^x             上付き文字
   _           a_x             下付き文字
   @           @x, a@^b_{cd}   空ボックス (幅がない)
   &           &{space}        指定した長さのスペースを挿入
   ~           ~a{.8-}         'a' の上に '-' を、現在のフォントサ
                               イズの .8 倍持ち上げた位置に重ね書き
   {/Times abc}                Times フォント、今のサイズで abc を出力
   {/Times*2 abc}              Times フォント、今の倍のサイズで abc
   {/Times:Italic abc}         TImes フォント、イタリック体で abc
   {/Arial:Bold=20 abc}        Arial フォント、太字、サイズ 20 で abc


 書式制御文字は、それに続く 1 文字、または中カッコで囲まれたものに適用
 されます。中カッコ内には、例えば 2^{10} のような追加の書式文字列のない
 文字列か、またはフォントの属性を変更する追加制御文字列を入れることがで
 きます。フォント指定は、開き中カッコ '{' の直後に続く '/' のすぐ次に書
 かなければ「いけません」。フォント名にスペースが含まれる場合、それを単
 一、または二重引用符で囲まなければいけません。

 例: 最初の例はその中カッコの入れ子を示していて、ボールド体の A にイタ
 リック体の下付きの添字 i がついたものが、いずれも現在のフォントで描か
 れます。この例の :Normal を取ると、下付きの添字はボールド体でかつイタ
 リック体になります。2 つ目の例は同じ書式制御を 20 ポイントサイズの
 "Times New Roman" フォントに適用したものです。
      {/:Bold A_{/:Normal{/:Italic i}}}
      {/"Times New Roman":Bold=20 A_{/:Normal{/:Italic i}}}

 空ボックス (phantom box) は a@^b_c の上付き文字と下付き文字を揃えると
 きに有用ですが、文字にアクセント記号を重ねる場合にはうまく働きません。
 後者の目的のためには、色々なアクセントやその他のダイアクリティカルマ
 ークのある多くの文字を持つエンコード (例えば iso_8859_1 や utf8) を使
 用する方がいいでしょう。以下参照: `set encoding`。そのボックスはスペー
 シングが行なわれないので、ボックス内 (つまり @ の後ろ) の上付き文字や
 下付き文字を短く出力するのに適しています。

 ある文字列と同じ長さのスペースを文字 '&' を使うことで入れることができ
 ます。すなわち、
         'abc&{def}ghi'
 は以下を生成します (abc と ghi の間は 3 文字分の空白):
         'abc   ghi'

 文字 '~' は、次の文字、またはカッコで囲まれた文字列に、それに続く文字
 またはカッコで囲まれた文字列を重ね書きします。2 番目の文字は最初の文字
 にあわせて水平方向にセンタリングされます。よって '~a/' は 'a' を貫くよ
 うなスラッシュが得られます。2 番目の文字は、その前に数字を置くことで垂
 直方向に移動させることができます。その数字は現在のフォントサイズに対す
 る割合を意味し、それに従って文字が上がったり下がったりします。この場合
 数字と文字列は 1 文字より長くなるのでカッコで囲む必要があります。重ね
 書きされる文字列が数字から始まっている場合は、垂直にずらす値と文字列と
 の間にスペースを入れてください ('~{abc}{.5 000}')。それ以外はスペース
 は不要です ('~{abc}{.5---}')。一方、あるいは両方のフォントを変更するこ
 ともできます ('~a{.5 /*.2 o}'; 'a' その 1/5 の大きさの 'o'、この場合数
 字とスラッシュの間のスペースは必要です) が、その文字列が始まった後で変
 更することはできません。それぞれの文字列内で、他の特殊な書式を使うこと
 もできません。もちろん、'~a{\^}' のように特殊な文字をエスケープするこ
 と (下記参照) は可能です。

 特殊記号は、8 進文字コードを与えることで数字で指定できます。例えば、
 {/Symbol \245} は、Adobe Symbol フォントの無限大の記号です。しかし、こ
 れは、 UTF-8 のようなマルチバイトエンコーディングではうまくいきません。
 UTF-8 環境では、タイプ打ち、そうでなければあなたが望む文字を選ぶような
 方法で、マルチバイト列を間接的に入力できるようにすべきです。

 制御文字は、 \\ や \{ などのように \ を使ってエスケープできます。

 二重引用符内の文字列は単一引用符内の文字列とは異なって解釈されることに
 注意してください。主な違いは、二重引用符内の文字列ではバックスラッシュ
 は 2 つ重ねる必要があることです。

 gnuplot ソース配布物内の /docs/psdoc サブディレクトリにあるファイル
 "ps_guide.ps" に、拡張された書式に関する例が載っています。同様のものが
 デモ
 `enhanced_utf8.dem`
 にもあります。
?environment
 `gnuplot` は多くのシェル環境変数を認識します。必須のものはありませんが、
 使えば便利になるかも知れません。

 GNUTERM は、それが定義されていれば、起動時の出力形式を設定するのに使わ
 れます。バージョン 5.2 からは、GNUTERM の文字列全部が "set term" に渡
 されるので、そこに terminal オプションを入れることもできます。例:
      GNUTERM="postscript eps color size 5in, 3in"
 これは、~/.gnuplot (またはそれに相当する) 初期化ファイル (以下参照:
 `startup`) による指定や、もちろんその後の明示的な `set term` コマンド
 による指定で変更できます。

 GNUHELP にヘルプファイル (gnuplot.gih) のパス名を定義しておくことがで
 きます。

 VMS では、論理名 GNUPLOT$HELP を `gnuplot` のヘルプライブラリの名前と
 して定義します。`gnuplot` のヘルプは任意の VMS システムのヘルプライブ
 ラリに入れることができます。

 Unix においては、カレントディレクトリに .gnuplot というファイルがない
 場合には、HOME に定義されたディレクトリを探します。MS-DOS, Windows,
 OS/2 では GNUPLOT がその役割に使われます。Windows では、NT 専用の変数
 USERPROFILE も参照されます。VMS では SYS$LOGIN です。`help startup`
 と打ってみてください。

 Unix においては、PAGER がヘルプメッセージの出力用のフィルタとして使わ
 れます。

 Unix では、SHELL が `shell` コマンドの際に使われます。MS-DOS, OS/2 で
 は COMSPEC が `shell` コマンドの際に使われます。

 `FIT_SCRIPT` は、当てはめ (fit) が中断されたときに実行する `gnuplot`
 コマンドの指定に使われます。以下参照: `fit`。`FIT_LOG` は当てはめによ
 るログファイルのデフォルトのファイル名の指定に使われます。

 GNUPLOT_LIB は、データやコマンドファイルの検索ディレクトリを追加定義す
 るのに使われます。その変数は、一つのディレクトリ名かまたは複数のディレ
 クトリ名を書くことができますが、ディレクトリの区切りはプラットホーム毎
 に違います。例えば Unix では ':' で、MS-DOS, Windows, OS/2 では ';' で
 す。GNUPLOT_LIB の値は変数 `loadpath` に追加されますが、それは `save`
 や `save set` コマンドでは保存されません。

 出力ドライバの中には gd ライブラリ経由で TrueType フォントを扱えるもの
 もいくつかあります。これらのドライバのフォント検索パスは、環境変数
 GDFONTPATH で制御できます。さらに、それらのドライバでのデフォルトのフ
 ォントは環境変数 GNUPLOT_DEFAULT_GDFONT で制御できます。

 postscript 出力ドライバは自分で持っているフォント検索パスを使いますが、
 それは環境変数 GNUPLOT_FONTPATH で制御できます。書式は GNUPLOT_LIB と
 同じです。GNUPLOT_FONTPATH の値は変数 `fontpath` に追加されますが、そ
 れは `save` や `save set` コマンドでは保存されません。

 PostScript ドライバは、外部 (組み込まれていない) 定義ファイルを探すた
 めに環境変数 GNUPLOT_PS_DIR を利用します。インストール時の作業により、
 gnuplot にはそれらのファイルのコピーが組み込まれているか、またはデフォ
 ルトのパスが埋め込まれています。この変数は、postscript 出力形式でデフ
 ォルトのファイルの代わりにカスタマイズした prologue ファイルを使用する
 のに利用できます。以下参照: `postscript prologue`。
?expressions
?division
 基本的には C, FORTRAN, Pascal, BASIC において利用可能な数学表現を使用
 できます。 演算子の優先順位は C 言語の仕様に従います。数式中の空白文字
 とタブ文字は無視されます。

 gnuplot は "実数" と "整数" 演算を FORTRAN や C のように扱うということ
 に注意してください。"1", "-10" などは整数と見なされ、"1.0", "-10.0",
 "1e1", 3.5e-1 などは実数と見なされます。 これら 2 つのもっとも重要な違
 いは割算です。整数の割算は切り捨てられます: 5/2 = 2。実数はそうではあ
 りません: 5.0/2.0 = 2.5。それらが混在した式の場合、計算の前に整数は実
 数に "拡張" されます: 5/2e0 = 2.5。負の整数を正の整数で割る場合、その
 値はコンパイラによって変わります。"print -5/2" として、あなたのシステ
 ムが常に切り捨てる (-5/2 で -3 になる) のか、または 0 の近くに丸める
 (-5/2 で -2 になる) のかを確認してください。

 数式 "1/0" は "未定義値 (undefined)" フラグを生成し、それによりその点
 を無視します。あるいは、あらかじめ定義されている値 NaN を使っても同じ
 ことになります。例については、以下参照: `using`。

 gnuplot は文字列に対する単純な演算、および文字列変数も利用できます。例
 えば式 ("A" . "B" eq "AB") は真と評価されますが、これは文字列の結合演
 算子と文字列の等号演算子を意味しています。

 数としての値を含む文字列は、それが数式で利用された場合は、対応する整数
 や実数に変換されます。よって、("3" + "4" == 7) や (6.78 == "6.78") は
 どちらも真になります。整数は、それが文字列結合演算子で使われた場合は文
 字列に変換されますが、実数や複素数はダメです。典型的な例は、ファイル名
 や他の文字列内に整数を使う場合でしょう: 例えば ("file" . 4 eq "file4")
 は真です。

 後置指定する範囲記述子 [beg:end] によって、部分文字列を指定することが
 できます。例えば、"ABCDEF"[3:4] == "CD" で、"ABCDEF"[4:*] == "DEF" で
 す。書式 "string"[beg:end] は、文字列値の組み込み関数
 substr("strings",beg,end) を呼ぶこととほぼ同じですが、関数呼び出しでは
 beg, end は省略することはできません。
?complex arithmetic
?complex
 計算の演算子とほとんどの組み込み関数は複素数引数の使用をサポートしてい
 ます。複素定数は、{<real>,<imag>} と表記し、<real> と <imag> は、数定
 数である必要があります。よって、{0,1} は 'i' を意味します。
 複素数値 x の実数部分と虚数部分は、real(x), imag(x) として取り出せます。
 絶対値は abs(x) で得られます。

 gnuplot の 2 次元と 3 次元の描画スタイルでは、実数値のみ描画できます。
 よって 0 でない虚数部分を持つ複素数値関数 f(x) を描画する場合は、
 real(f(x)) か abs(f(x)) の描画を選択する必要があります。複素数値の表現
 の例は、
 複素三角関数デモ (complex_trig.dem)
 をご覧ください。

?constants
?expressions constants
?octal
?hexadecimal
?complex constants
 整数定数は、C の strtoll() ライブラリルーチンを使って解釈しますが、こ
 れは、"0" で始まる定数は 8 進数と、また "0x" か "0X" で始まる定数は
 16 進数とみなすことを意味します。

 実数 (浮動小数) 定数は、C の atof() ライブラリルーチンを使って解釈しま
 す。

 複素数の定数は {<real>,<imag>} と表現します。ここで <real> と <imag>
 (実部、虚部) は数値定数である必要があります。例えば {3,2} は 3 + 2i を
 あらわし、{0,1} は 'i' 自身を表します。これらには明示的に中カッコを使
 う必要があります。

 文字列定数は単一引用符か二重引用符のいずれかで囲まれた任意の文字の並び
 からなるものです。単一引用符と二重引用符の違いは重要です。以下参照:
 `quotes`。

 例:
      1 -10 0xffaabb        # 整数定数
      1.0 -10. 1e1 3.5e-1   # 実数定数
      {1.2, -3.4}           # 複素数定数
      "Line 1\nLine 2"      # 文字列定数 (\n は改行に展開される)
      '123\n456'            # 文字列定数 (\ と n はそのままの文字)

?expressions functions
 特に注意がなければ、`gnuplot` の数学関数の引数は整数、実数、複素数の値
 を取ることができます。角を引数や戻り値とする関数 (例えば sin(x)) は、
 その値をラジアンとして扱いますが、これはコマンド `set angles` によって
 度に変更できます。









?expressions functions abs
?abs
 関数 `abs(x)` 引数の絶対値を返します。返り値の型は引数と同じです。

 複素数の引数に対しては, abs(x) は複素平面における x の長さと定義されて
 います [すなわち sqrt(real(x)**2 + imag(x)**2) ]。これは x のノルム
 (norm)、または x の複素絶対値 (modulus) とも呼ばれます。
?expressions functions acos
?acos
 関数 `acos(x)` は引数のアークコサイン (逆余弦) を返します。`acos` の返
 す値がラジアン単位かまたは度であるかは `set angles` で選択されます。
?expressions functions acosh
?acosh
 関数 `acosh(x)` は逆ハイパボリックコサイン (逆双曲余弦) の値をラジアン
 で返します。
?expressions functions airy
?airy
 関数 `airy(x)` は、エアリー (Airy) 関数 Ai(x) の値を返します。関数
 Ai(x) は、微分方程式 y'' - x y = 0 の、実数全体で有界な解です。引数が
 複素数の場合、その虚数部分は無視されます。
?expressions functions arg
?arg
 関数 `arg(x)` は複素数の偏角を、`set angles` の設定にしたがってラジア
 ン、または度で返します。
?expressions functions asin
?asin
 関数 `asin(x)` は引数のアークサイン (逆正弦) を返します。`asin` の返す
 値は `set angles` の設定によってラジアン単位かまたは度になります。
?expressions functions asinh
?asinh
 関数 `asinh(x)` は逆ハイパボリックサイン (逆双曲正弦) の値をラジアンで
 返します。
?expressions functions atan
?atan
 関数 `atan(x)` は引数のアークタンジェント (逆正接) の値を返します。
 `atan` の返す値は `set angles` の設定によってラジアン単位かまたは度に
 なります。
?expressions functions atan2
?atan2
 関数 `atan2(y,x)` は引数の実数部分の比のアークタンジェント (逆正接) の
 値を返します。`atan2` は `set angles` の設定によってラジアン単位か度に
 なる、適切な四分円における値を返します。
?expressions functions atanh
?atanh
 関数 `atanh(x)` は逆ハイパボリックタンジェント (逆双曲正接) の値をラジ
 アンで返します。
?expressions functions EllipticK
?EllipticK
 関数 `EllipticK(k)` は、第 1 種完全楕円積分の値を返します。詳細は、以
 下参照: `elliptic integrals`。
?expressions functions EllipticE
?EllipticE
 関数 `EllipticE(k)` は、第 2 種完全楕円積分の値を返します。詳細は、以
 下参照: `elliptic integrals`。
?expressions functions EllipticPi
?EllipticPi
 関数 `EllipticPi(n,k)` は、第 3 種完全楕円積分の値を返します。詳細は、
 以下参照: `elliptic integrals`。
?expressions functions besj0
?besj0
 関数 `besj0(x)` は引数の J0 ベッセル関数 (0 次の第 1 種円柱関数 J0、0
 次ベッセル関数) の値を返します。`besj0` には引数はラジアンで与えます。
?expressions functions besj1
?besj1
 関数 `besj1(x)` は引数の J1 ベッセル関数 (1 次の第 1 種円柱関数 J1、1
 次ベッセル関数) の値を返します。`besj1` には引数はラジアンで与えます。
?expressions functions besy0
?besy0
 関数 `besy0(x)` は引数の Y0 ベッセル関数 (0 次の第 2 種円柱関数 Y0、0
 次ノイマン関数) の値を返します。`besy0` には引数はラジアンで与えます。
?expressions functions besy1
?besy1
 関数 `besy1(x)` は引数の Y1 ベッセル関数 (1 次の第 2 種円柱関数 Y1、1
 次ノイマン関数) の値を返します。`besy1` には引数はラジアンで与えます。
?expressions functions ceil
?ceil
 関数 `ceil(x)` は引数以上の最小の整数を返します。複素数引数に対しては
 `ceil` はその引数の実部以上の最小の整数を返します。
?expressions functions cos
?cos
 関数 `cos(x)` は引数のコサイン (余弦) の値を返します。`cos` は
 `set angles` の選択にしたがって、ラジアンまたは度の引数を受け付けます。
?expressions functions cosh
?cosh
 関数 `cosh(x)` は引数のハイパボリックコサインの値を返します。`cosh` の
 引数はラジアンで与えます。
?expressions functions erf
?erf
 関数 `erf(x)` は引数の実部の誤差関数の値を返します。引数が複素数の場合
 は虚部は無視されます。以下参照: `erfc`, `inverf`, `norm`。
?expressions functions erfc
?erfc
 関数 `erfc(x)` は 1.0 から、引数の実部の誤差関数の値を引いたものを返し
 ます。引数が複素数の場合は虚部は無視されます。以下参照: `erf`,
 `inverf`, `norm`。
?expressions functions exp
?exp
 関数 `exp(x)` 引数の指数関数の値 (`e` の引数乗) を返します。環境によっ
 ては (特に sun) 大きい x の値に対する exp(-x) は未定義値を返す場合があ
 ります。このような場合、safe(x) = x<-100 ? 0 : exp(x) のようなユーザ定
 義関数が役に立つでしょう。
?expressions functions expint
?expint
 関数 `expint(n,x)` は、その引数の実数部分の指数積分、すなわち t の関数
 t^(-n) e^(-tx) の 1 から∞までの積分値を返します。n は 0 以上の整数、
 x は 0 以上の実数で、x>0 か n>1 のいずれかでなければなりません。
?expressions functions floor
?floor
 関数 `floor(x)` はその引数以下の最大の整数を返します。複素数引数に対し
 ては `floor` はその引数の実部以下の最大の整数を返します。
?expressions functions gamma
?gamma
 関数 `gamma(x)` は引数の実部のガンマ関数の値を返します。整数 n に対し
 ては gamma(n+1) = n! です。引数が複素数の場合、虚数部分は無視されます。
?expressions functions ibeta
?ibeta
 関数 `ibeta(p,q,x)` は引数の実部の不完全ベータ関数の値を返します。p, q
 は正で x は [0:1] 内の値です。引数が複素数の場合は虚部は無視されます。
 この関数は連分数法 (Abramowitz and Stegun, 1964) で近似していて、この
 近似は x < (p-1)/(p+q-2) の範囲でしか正確ではありません。
?expressions functions inverf
?inverf
 関数 `inverf(x)` は引数の実部の逆誤差関数の値を返します。以下参照:
 `erf`, `invnorm`。
?expressions functions igamma
?igamma
 関数 `igamma(a,x)` は引数の実部の、正規化された不完全ガンマ関数の値を
 返します。ここで、a > 0, x >= 0 です。標準的な記法では P(a,x) (例えば
 Abramowitz and Stegun (6.5.1)) で、x が無限大に発散する場合の極限値は
 1 です。引数が複素数の場合は虚部は無視されます。
?expressions functions imag
?imag
 関数 `imag(x)` は引数の虚数部分を実数として返します。
?expressions functions invnorm
?invnorm
 関数 `invnorm(x)` は引数の実部に対する、正規分布 (ガウス分布) の累積分
 布関数の逆関数の値を返します。以下参照: `norm`。
?expressions functions int
?int
 関数 `int(x)` は、引数の整数部分 (0 に向かって丸めた) を返します。
?expressions functions lambertw
?lambertw
 関数 `lambertw(x)` は Lambert の W 関数の主値を返します。W 関数は、方
 程式 (W(x)*exp(W(x))=x によって定義されます。x は x >= -exp(-1) を満た
 す実数でなければいけません。
?expressions functions lgamma
?lgamma
 関数 `lgamma(x)` は引数の実部のガンマ関数値の自然対数の値を返します。
 引数が複素数の場合、虚部は無視されます。
?expressions functions log
?log
 関数 `log(x)` は引数の自然対数 (底 `e`) の値を返します。以下参照:
 `log10`。
?expressions functions log10
?log10
 関数 `log10(x)` は引数の対数 (底 10) を返します。
?expressions functions norm
?norm
 関数 `norm(x)` は、引数の実部に対する、正規分布 (ガウス分布) の累積分
 布関数の値を返します。以下参照: `invnorm`, `erf`, `erfc`。
?expressions functions rand
?rand
 関数 `rand(x)` は、区間 (0:1) 内の疑似乱数を返します。詳しくは以下参
 照: `random`。
?expressions functions real
?real
 関数 `real(x)` は引数の実部を返します。
?expressions functions sgn
?sgn
 関数 `sgn(x)` は引数が正なら 1 を、負なら -1 を、0 ならば 0 を返します。
 引数が複素数の場合虚部は無視されます。
?expressions functions sin
?sin
 関数 `sin(x)` は引数のサイン (正弦) の値を返します。`sin` は
 `set angles` の選択にしたがって、ラジアンまたは度の引数を受け付けます。
?expressions functions sinh
?sinh
 関数 `sinh(x)` は引数のハイパボリックサインの値を返します。`sinh` の
 引数はラジアンで与えます。
?expressions functions sqrt
?sqrt
 関数 `sqrt(x)` は引数の平方根の値を返します。x が複素数の場合、これは
 常に正の実部を持つ根を返します。
?expressions functions tan
?tan
 関数 `tan(x)` は引数のタンジェント (正接) の値を返します。`tan` は
 `set angles` の選択にしたがって、ラジアンまたは度の引数を受け付けます。
?expressions functions tanh
?tanh
 関数 `tanh(x)` は引数のハイパボリックタンジェントの値を返します。
 `tanh` の引数はラジアンで与えます。
?expressions functions voigt
?voigt
 関数 `voigt(x,y)` は、スペクトル解析で使用される Voigt/Faddeeva 関数の
 近似を返します。その誤差は 1/10^4 以内です。libcerf ルーチンが利用可能
 ならば、より正確な値を求めるために re_w_of_z() ルーチンが使われます。
 voigt(x,y) = real(faddeeva( x + y*{0,1} )) に注意してください。

?expressions functions cerf
?cerf
 `cerf(z)` は誤差関数 erf(x) の複素バージョンです。
?expressions functions cdawson
?cdawson
 `cdawson(z)` は複素引数に対する Dawson 積分の値を返します。
 cdawson(z) = sqrt(pi)/2 * exp(-z^2) * erfi(z)
?expressions functions faddeeva
?faddeeva
 関数 `faddeeva(z)` は再スケール化複素誤差関数です。
 faddeeva(z) = exp(-z^2) * erfc(-i*z)
 これは、Abramowitz-Stegun の式 7.1.3, 7.1.4 に対応します。
?expressions functions erfi
?erfi
 虚誤差関数 erfi(x) = -i * erf(ix)
?expressions functions VP
?VP
 `VP(x,sigma,gamma)` はガウス密度関数 G(x;sigma) とローレンツ密度関数
 L(x;gamma) の畳み込みで定義される Voigt プロファイル (密度関数) に対
 応します。


?expressions functions gprintf
 `gprintf("format",x)` は、gnuplot 独自の書式指定子に一つの変数 x を適
 用し、その結果の文字列を返します。標準的な C 言語書式指定子を使いたい
 場合は、代わりに `sprintf("format",x)` を使う必要があります。
 以下参照: `format specifiers`。
?expressions functions sprintf
?sprintf
 `sprintf("format",var1,var2,...)` は標準的な C 言語の書式指定子を複数
 個の引数に適用し、その結果の文字列を返します。gnuplot 独自の書式指定子
 を使いたい場合は、代わりに `gprintf()` を使用する必要があります。
 sprintf の書式指定子に関するより詳しい情報については、標準的な C 言語
 の本か、unix の sprintf の man ページを参照してください。
?expressions functions strlen
?strlen
 `strlen("string")` は、現在のエンコーディングを考慮した、文字列中の文
 字数を返します。現在のエンコーディングが多バイト文字 (SJIS UTF8) をサ
 ポートしていれば、この値は、文字列のバイト数よりも小さくなるでしょう。
 文字列に多バイト UTF8 文字が含まれていて、しかし現在のエンコーディング
 が UTF8 以外の別のものに設定されていると、strlen("utf8文字列") は、
 実際の文字数よりも大きな値を返すでしょう。
?expressions functions strstrt
?strstrt
 `strstrt("string","key")` は、文字列 "key" を "string" の中で探し、そ
 れが現れる先頭位置を返します。"key" が見つからなかった場合は 0 を返し
 ます。C ライブラリの strstr 関数に似ていますが、文字列へのポインタを返
 す strstr とは違い、これは整数での位置を返します。例えば、
 strstrt("hayneedlestack","needle") = 4 となります。
?expressions functions substr
?substr
 `substr("string",beg,end)` は、元の文字列の beg から end 番目までの文
 字からなる文字列を返します。これは、"string"[beg:end] という式とほぼ同
 じですが、こちらはオプション beg, end を省略できません。
?expressions functions strftime
?strftime
 `strftime("timeformat",t)` は、1970 年からの秒数による時刻 t に、時刻
 書式指定 timeformat を適用します。
 以下参照: `time_specifiers`, `strptime`。
?expressions functions strptime
?strptime
 `strptime("timeformat",s)` 書式指定 timeformat を使って文字列 s から時
 刻を読み込んで、それを 1970 年からの秒数に変換します。
 以下参照: `time_specifiers`, `strftime`。
?expressions functions system
 `system("command")` は、標準的なシェルを用いて "command" を実行し、そ
 の標準出力への文字列を文字列変数として返します。一番最後の改行一つは無
 視されます。

 これは、'f(x) = real(system(sprintf("somecommand %f", x)))' のようにし
 て、外部関数の出力を gnuplot スクリプト内に取り込むのに利用できます。
 `word("string",n)` は文字列 string の n 番目の単語文字列を返します。例
 えば `word("one two three",2)` は文字列 "two" を返します。
 `words("string")` は文字列 string 中の単語数を返します。例えば
 `words(" a b c d")` は 4 を返します。

?expressions functions column
?column
 `column(x)` は、plot, splot, stats コマンドの一部としてのみ使います。
 これは、$x$ 列目の内容を数値として評価します。以下参照:
 `plot datafile using`。
?expressions functions columnhead
?columnhead
 `columnhead(x)` は、plot, splot, stats コマンドの一部としてのみ使いま
 す。これは、データファイルの最初の行の $x$ 列目の内容を文字列として評
 価します。以下参照: `plot datafile using`。
?expressions functions exists
?exists
 `exists()` の引数は文字列定数、または文字列変数です。その文字列が、定
 義されている変数名を持っていれば 1 を、そうでなければ 0 を返します。
?expressions functions hsv2rgb
?hsv2rgb
?hsv
 関数 `hsv2rgb(h,s,v)` は、HSV (色相(Hue)/彩度(Saturation)/明度(Value))
 の 3 つ組をそれと同等な RGB 値に変換します。
?expressions functions stringcolumn
?stringcolumn
?expressions functions strcol
?strcol
 `stringcolumn(x)` は fit あるいはデータファイルプロットでの `using` の
 操作の数式の一部としてのみ使われます。これは $x$ 列目の内容を文字列変
 数として返します。`strcol(x)` は、`stringcolumn(x)` の省略形です。
 以下も参照: `plot datafile using`。
?expressions functions timecolumn
?timecolumn
 `timecolumn(N,"timeformat")` は fit、あるいはデータファイル描画での
 `using` 処理の数式の一部としてのみ使います。以下参照:
 `plot datafile using`。

 これは、N 列目から始まる文字列データを日時データ値として読み、これをミ
 リ秒精度の "Unix エポック (1970 年 1 月 1 日) からの秒数" として解釈す
 るために "timeformat" を使用します。
 注意: バージョン 5 より前は、この関数は一つの引数しか取らず、また純粋
 に軸の座標を含んでいる列にしか機能していませんでした。
?expressions functions tm_hour
?tm_hour
 関数 `tm_hour(x)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 時刻の何時 (0--23 の範囲の整数) であるかを、実数として返します。
?expressions functions tm_mday
?tm_mday
 関数 `tm_mday(x)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 その月の何日 (1--31 の範囲の整数) であるかを、実数として返します。
?expressions functions tm_min
?tm_min
 関数 `tm_min(x)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 時刻の何分 (0--59 の範囲の整数) であるかを、実数として返します。
?expressions functions tm_mon
?tm_mon
 関数 `tm_mon(x)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 何月 (0--11 の範囲の整数) であるかを、実数として返します。
?expressions functions tm_sec
?tm_sec
 関数 `tm_sec(x)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 時刻の何秒 (0--59 の範囲の整数) であるかを、実数として返します。
?expressions functions tm_wday
?tm_wday
 関数 `tm_wday(x)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 その週の何日目 (0--6 の範囲の整数) であるかを、実数として返します。
?expressions functions tm_yday
?tm_yday
 関数 `tm_yday(x)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 その年の何日目 (1--366 の範囲の整数) であるかを、実数として返します。
?expressions functions tm_year
?tm_year
 関数 `tm_year(x)` は引数を 1970 年 1 月 1 日からの秒数と解釈し、それが
 西暦何年 (整数) であるかを、実数として返します。
?expressions functions time
?time
 関数 `time(x)` は現在のシステム時刻を返します。この値は `strftime` 関
 数で日時文字列に変換できますし、`timecolumn` と組み合わせて相対的な日
 時グラフを作成するのにも使えます。引数の型はそれが返すものを決定します。
 引数が整数の場合は time() は現在の時刻を 1970 年 1 月 1 日からの整数と
 して返し、引数が実数 (または複素数) ならば同様の値を実数として返します。
 引数が文字列ならば、それを書式文字列であるとみなし、書式化された日時文
 字列を提供するようそれを `strftime` に渡します。
?expressions functions valid
?valid
 `valid(x)` は、データ描画か fit における `using` の式の中でしか使われ
 ません。以下参照: `plot datafile using`。


?elliptic integrals
 関数 `EllipticK(k)` は、第 1 種完全楕円積分、すなわち、関数
 `(1-(k*sin(p))**2)**(-0.5)` の 0 からπ/2 までの範囲の広義積分の値を返
 します。`k` の定義域は -1 から 1 です (両端は含まない)。

 関数 `EllipticE(k)` は、第 2 種完全楕円積分、すなわち、関数
 `(1-(k*sin(p))**2)**0.5` の 0 からπ/2 までの範囲の広義積分の値を返し
 ます。`k` の定義域は -1 から 1 です (両端も含む)。

 関数 `EllipticPi(n,k)` は、第 3 種完全楕円積分、すなわち関数
 `(1-(k*sin(p))**2)**(-0.5)/(1-n*sin(p)**2)` の 0 からπ/2 までの範囲の
 広義積分の値を返します。パラメータ `n` は 1 より小さく、`k` は -1 と 1
 の間 (両端は含まない) でなければいけません。定義より、すべての正の `k`
 に対し EllipticPi(0,k) == EllipticK(k) であることに注意してください。
?expressions random
?random
 関数 `rand()` は 0 と 1 の間の疑似乱数列を生成します。これは以下からの
 アルゴリズムを使用しています: P. L'Ecuyer and S. Cote, "Implementing a
 random number package with splitting facilities", ACM Transactions on
 Mathematical Software, 17:98-111 (1991).

       rand(0)     内部に持つ 2 つの 32bit の種 (seed) の現在の値から生
                   成する、開区間 (0:1) 内の疑似乱数値を返す
       rand(-1)    2 つの種の値を標準値に戻す
       rand(x)     0 < x < 2^31-1 の整数なら種の両方を x に設定する
       rand({x,y}) 0 < x,y < 2^31-1 の整数なら seed1 を x に seed2 を y
                   に設定する
?expressions functions value
?value
 A がユーザー定義変数の名前であれば、B = value("A") は事実上 B = A と全
 く同じです。これは、変数の名前自身が文字列変数に収められている場合に有
 用です。以下参照: `user-defined variables`。これは、変数名をデータファ
 イルから読み取ることも可能にします。引数が数式である場合、value() はそ
 の数式の値を返します。引数が文字列で、定義されている変数に対応するもの
 がない場合、value() は NaN を返します。

?expressions functions word
?expressions functions words
?words
?word
 `word("string",n)` は、文字列 (string) の n 番目の単語を返します。例え
 ば `word("one two three",2)` は文字列 "two" を返します。

 `words("string")` は、文字列 (string) の単語数を返します。例えば、
 `words(" a b c d")` は 4 を返します。

 関数 `word` と `words` は、単一引用符、二重引用符で囲まれた文字列も、
 限定的ですがサポートしています:
       print words("\"double quotes\" or 'single quotes'")   # 3
 開始引用符の前は、スペースか、または文字列の先頭でなければいけません。
 これは、単語内、あるいは単語終わりにつくアポストロフィー (') は、それ
 ぞれの単語の要素であると見なされることを意味します:
       print words("Alexis' phone doesn't work") # 4
 引用符文字のエスケープはサポートしていませんので、ある引用符を維持した
 い場合は、それぞれを別の種類の引用符で囲まなければいけません:
       s = "Keep \"'single quotes'\" or '\"double quotes\"'"
       print word(s, 2) # 'single quotes'
       print word(s, 4) # "double quotes"
 最後の例では、引用符のエスケープが文字列の定義時のみに必要であることに
 注意してください。

?expressions operators
?operators
 `gnuplot` の演算子は、C 言語の演算子とほぼ同じですが、特に注意がなけれ
 ば全ての演算子が整数、実数、複素数の引数を取ることができます。また、
 FORTRAN で使える ** (累乗) 演算子もサポートされています。

 演算の評価の順序を変更するにはかっこを使います。
?expressions operators unary
?operators unary
?unary
 以下は、単項演算子とその使用法の一覧です:

     記号          例        説明
       -           -a          マイナス符号
       +           +a          プラス符号 (何もしない)
       ~           ~a        * 1 の補数 (ビット反転)
       !           !a        * 論理的否定
       !           a!        * 階乗
       $           $3        * `using` 内での引数/列指定
       ||          |A|         配列 A の要素数


 説明に星印 (*) のついた演算子の引数は整数でなければなりません。

 演算子の優先順位は Fortran や C と同じです。それらの言語同様、演算の評
 価される順序を変えるためにかっこが使われます。よって -2**2 = -4 で、
 (-2)**2 = 4 です。

 階乗演算子は、大きな値を返せるように実数を返します。
?expressions operators binary
?operators binary
 以下は、二項演算子とその使用法の一覧です:

     記号          例          説明
       **          a**b          累乗
       *           a*b           積
       /           a/b           商
       %           a%b         * 余り
       +           a+b           和
       -           a-b           差
       ==          a==b          等しい
       !=          a!=b          等しくない
       <           a<b           より小さい
       <=          a<=b          以下
       >           a>b           より大きい
       >=          a>=b          以上
       <<          0xff<<1       符号なし左シフト
       >>          0xff>>2       符号なし右シフト
       &           a&b         * ビット積 (AND)
       ^           a^b         * ビット排他論理和 (XOR)
       |           a|b         * ビット和 (OR)
       &&          a&&b        * 論理的 AND
       ||          a||b        * 論理的 OR
       =           a = b         代入
       ,           (a,b)         累次評価
       .           A.B           文字列の連結
       eq          A eq B        文字列が等しい
       ne          A ne B        文字列が等しくない



 説明に星印 (*) のついた演算子の引数は整数でなければなりません。
 大文字の A,B は演算子が文字列引数を要求することを意味します。

 論理演算子の AND (&&) と OR (||) は C 言語同様に必要最小限の評価しかし
 ません。すなわち、`&&` の第 2 引数は、第 1 引数が偽ならば評価されませ
 んし、`||` の第 2 引数は、第 1 引数が真ならば評価されません。

 累次評価 (,) は、カッコの中でのみ評価され、左から右へ順に実行すること
 が保証され、最も右の式の値が返されます。
?expressions operators ternary
?operators ternary
?ternary
 一つだけ三項演算子があります:

      記号          例       説明
       ?:          a?b:c     三項演算子



 三項演算子は C のものと同じ働きをします。最初の引数 (a) は整数でなけれ
 ばいけません。この値が評価され、それが真 (ゼロでない) ならば 2 番目の
 引数 (b) が評価されその値が返され、そうでなければ 3 番目の引数 (c) が
 評価され、その値が返されます。

 三項演算子は、区分的に定義された関数や、ある条件が満たされた場合にのみ
 点を描画する、といったことを行なう場合に有用です。

 例:

 0 <= x < 1 では sin(x) に、1 <= x < 2 では 1/x に等しくて、それ以外の
 x では定義されない関数を描画:
       f(x) = 0<=x && x<1 ? sin(x) : 1<=x && x<2 ? 1/x : 1/0
       plot f(x)
 `gnuplot` は未定義値に対しては何も表示せずにただ無視するので、最後の場
 合の関数 (1/0) は点を何も出力しないことに注意してください。また、この
 関数描画の描画スタイルが lines (線描画) の場合、不連続点 (x=1) の所も
 連続関数として線が結ばれてしまうことにも注意してください。その点を不連
 続になるようにするには、関数を 2 つの部分それぞれに分けてください (こ
 のような場合、媒介変数関数を使うのが便利です)。

 ファイル 'file' のデータで、4 列目のデータが負でないときだけ、1 列目の
 データに関する 2 列目と 3 列目のデータの平均値を描画:

       plot 'file' using 1:( $4<0 ? 1/0 : ($2+$3)/2 )

 `using` の書式の説明に関しては、以下参照: `plot datafile using`。
?expressions operators summation
?operators summation
?summation
 和の式は、以下の形式で表します:
       sum [<var> = <start> : <end>] <expression>
 ここで <var> は、<start> から <end> までの整数値を順に取る整数変数とし
 て扱われます。その各値に対して、式 <expression> の値が合計値に追加され、
 最終的な合計値がこの和の式の値となります。
 例:
       print sum [i=1:10] i
           55.
       # 以下は plot 'data' using 1:($2+$3+$4+$5+$6+...) と同等
       plot 'data' using 1 : (sum [col=2:MAXCOL] column(col))
 <expression> は、必ずしも変数 <var> を含む必要はありません。<start> と
 <end> は変数値や数式で指定もできますが、それらの値は動的に変更すること
 はできません。そうでないと副作用が起こり得ます。<end> が <start> より
 小さい場合は、和の値は 0 となります。
?expressions gnuplot-defined
?gnuplot-defined
?gnuplot-defined variables
?GPVAL
?gpval
 gnuplot は、プログラムの現在の内部状態と直前の描画を反映するような読み
 出し専用の変数をいくつか持っています。これらの変数の名前は、例えば
 GPVAL_TERM, GPVAL_X_MIN, GPVAL_X_MAX, GPVAL_Y_MIN のように "GPVAL_" で
 始まります。これらすべての一覧とその値を見るには、`show variables all`
 と入力してください。ただし、軸のパラメータに関連する値 (範囲、対数軸で
 あるか等) は、現在 `set` したものではなく、最後に描画されたものが使用
 されます。

 例: 点 [X,Y] のスクリーン比での座標を計算する方法
      GRAPH_X = (X - GPVAL_X_MIN) / (GPVAL_X_MAX - GPVAL_X_MIN)
      GRAPH_Y = (Y - GPVAL_Y_MIN) / (GPVAL_Y_MAX - GPVAL_Y_MIN)
      SCREEN_X = GPVAL_TERM_XMIN + GRAPH_X * (GPVAL_TERM_XMAX - GPVAL_TERM_XMIN)
      SCREEN_Y = GPVAL_TERM_YMIN + GRAPH_Y * (GPVAL_TERM_YMAX - GPVAL_TERM_YMIN)
      FRAC_X = SCREEN_X * GPVAL_TERM_SCALE / GPVAL_TERM_XSIZE
      FRAC_Y = SCREEN_Y * GPVAL_TERM_SCALE / GPVAL_TERM_YSIZE

 読み出し専用変数 GPVAL_ERRNO は、任意の gnuplot コマンドがあるエラーの
 ために早く終わってしまった場合に 0 でない値にセットされ、直前のエラー
 メッセージは文字列変数 GPVAL_ERRMSG に保存されます。GPVAL_ERRNO と
 GPVAL_ERRMSG は、コマンド `reset errors` を使ってクリアできます。

 `mouse` 機能が使える対話型入出力形式は、"MOUSE_" で始まる読み出し専用
 変数をいくつか持っています。詳細は、以下参照: `mouse variables`。

 `fit` 機能は、"FIT_" で始まるいくつかの変数を使用しますので、そのよう
 な名前を使うのは避けるべきでしょう。`set fit errorvariables` を使用す
 ると、各当てはめ変数のエラーは、そのパラメータ名に "_err" を追加した変
 数に保存されます。詳細は、以下参照: `fit`。

 以下も参照: `user-defined variables`, `reset errors`,
 `mouse variables`, `fit`。

?expressions user-defined
?user-defined variables
?user-defined
?variables
 新たなユーザ定義変数と 1 個から 12 個までの引数を持つユーザ定義関数を、
 任意の場所で定義したり使ったりすることができます。それは `plot` コマン
 ド上でも可能です。

 ユーザ定義関数書式:
       <func-name>( <dummy1> {,<dummy2>} ... {,<dummy12>} ) = <expression>

 ここで <expression> は仮変数 <dummy1> から <dummy12> で表される数式です。

 ユーザ定義変数書式:
       <variable-name> = <constant-expression>

 例:
       w = 2
       q = floor(tan(pi/2 - 0.1))
       f(x) = sin(w*x)
       sinc(x) = sin(pi*x)/(pi*x)
       delta(t) = (t == 0)
       ramp(t) = (t > 0) ? t : 0
       min(a,b) = (a < b) ? a : b
       comb(n,k) = n!/(k!*(n-k)!)
       len3d(x,y,z) = sqrt(x*x+y*y+z*z)
       plot f(x) = sin(x*a), a = 0.2, f(x), a = 0.4, f(x)

       file = "mydata.inp"
       file(n) = sprintf("run_%d.dat",n)

 最後の 2 行の例は、ユーザ定義文字列変数と、ユーザ定義文字列関数を意味
 しています。

 変数 `pi` (3.14159...) と `NaN` (IEEE 非数 ("Not a Number")) はあらか
 じめ定義されています。これらが必要なければ、他のものに再定義することも
 可能ですし、以下のようにして元の値に復帰することもできます:

       NaN = GPVAL_NaN
       pi  = GPVAL_pi

 他にもいくつかの変数が、例えば対話型入出力形式でのマウス操作や当てはめ
 (fit) などの gnuplot の動作状態に応じて定義されます。詳細は
 以下参照: `gnuplot-defined variables`。

 ある変数 V が既に定義されているかどうかは、式 exists("V") でチェックで
 きます。例:
       a = 10
       if (exists("a")) print "a is defined"
       if (!exists("b")) print "b is not defined"

 変数名や関数名の命名規則は、大抵のプログラミング言語と同じで、先頭はア
 ルファベットで、その後の文字はアルファベット、数字、"_" が使えます。

 各関数の定義式は、'GPFUN_' という接頭辞を持つ特別な文字列値変数として
 利用できます。

 例:
       set label GPFUN_sinc at graph .05,.95

 以下参照: `show functions`, `functions`, `gnuplot-defined variables`,
 `macros`, `value`。
?arrays
?cardinality
 配列は、ユーザ変数の添字付きリストとして実装されています。一つの配列の
 要素は、一つの変数型には限定されていません。配列は、参照する前に明示的
 に作られていなければいけません。配列を作成した後で、そのサイズを変更す
 ることはできません。すべての要素は、最初は未定義 (undefined) です。ほ
 とんどの場面で、名前付きユーザ変数の代わりに配列要素を利用できます。
 配列 A の要素数は、数式 |A| で取得できます。

 例:
      array A[6]
      A[1] = 1
      A[2] = 2.0
      A[3] = {3.0, 3.0}
      A[4] = "four"
      A[6] = A[2]**3
      array B[6] = [ 1, 2.0, A[3], "four", , B[2]**3 ]

      do for [i=1:6] { print A[i], B[i] }
          1 1
          2.0 2.0
          {3.0, 3.0} {3.0, 3.0}
          four four
          <undefined> <undefined>
          8.0 8.0

 注意: 配列と変数は、同じ名前空間を共有します。例えば、あらかじめ FOO
 という名前の配列がある場合、FOO という名前の文字列変数を使うと、配列
 を破壊します。

 配列の名前を `plot`, `splot`, `fit`, `stats` コマンドに与えることもで
 きます。その場合、配列の添字がファイルの 1 列目の値で (1 から size ま
 で)、その値 real(A[i]) がファイルの 2 列目、imag(A[i]) が 3 列目である
 ようなデータファイルを与えたことと同等になります。

 例:
      array A[200]
      do for [i=1:200] { A[i] = sin(i * pi/100.) }
      plot A title "sin(x) in centiradians"

 ただし、plot 時に複素数値配列の虚数部分を描画したい場合、その値は
 imag(A[$1]) かまたは $3 として参照できます。よって以下の 2 つのコマン
 ドは同等です。

      plot A using (real(A[$1])) : (imag(A[$1]))
      plot A using 2:3

?fonts
 gnuplot それ自身にはどんなフォントも含まれてはおらず、外部フォント処理
 に頼っているだけで、その細部は悲しいことに出力形式毎に異なります。ここ
 では、複数の出力形式に適用されるフォント機構について説明します。ここに
 上げたもの以外の出力形式でのフォントの使用に関しては、その出力形式のド
 キュメントを参照してください。

 一時的に、例えば Adobe Symbol フォントのような特別なフォントに切り替え
 ることでアルファベットではない記号を入れることも可能ですが、現在は、
 UTF-8 エンコーディングを使用して、必要な記号を指す Unicode エントリを
 指定するという方法があります。以下参照: `encoding`, `locale`。

?fonts cairo
 これらの出力形式は、フォントの検索とアクセスに外部の fontconfig ツール
 群を使用します。
 fontconfig ユーザマニュアル
 を参照してください。これは、gnuplot で一般的な名前やサイズでフォントを
 要求することを可能にし、必要ならば fontconfig に同等のフォントを代用さ
 せることもできるので、通常はこれで十分でしょう。以下は、多分いずれも機
 能します:
      set term pdfcairo font "sans,12"
      set term pdfcairo font "Times,12"
      set term pdfcairo font "Times-New-Roman,12"

?gd
?fonts gd
 png, gif, jpeg, sixelgd 出力形式のフォント処理は、外部ライブラリ libgd
 によって行われます。libgd は、次の 5 種類の基本フォントを直接提供して
 います: `tiny` (5x8 ピクセル), `small` (6x12 ピクセル), `medium`,
 (7x13 Bold), `large` (8x16), `giant` (9x15 ピクセル)。これらのフォント
 は大きさを変更したり回転したりすることはできません。使用する際は、
 `font` キーワードの代わりに上のキーワードを指定します。例:
      set term png tiny

 多くのシステムで、libgd は Adobe Type 1 フォント (*.pfa) と TrueType
 フォントへのアクセスも提供します。その場合フォント自身の名前ではなく、
 フォントファイルの名前を、"<face> {,<pointsize>}" の形式で与えます。
 ここで、<face> はフォントファイルのフルパス名か、または環境変数
 GDFONTPATH で指示されるディレクトリの一つの中のファイル名の先頭部分、
 のいずれかです。よって、'set term png font "Face"' は、
 <あるディレクトリ>/Face.ttf か <あるディレクトリ>/Face.pfa というファ
 イル名のフォントを探そうとします。例えば、GDFONTPATH に
 `/usr/local/fonts/ttf:/usr/local/fonts/pfa` が含まれている場合は、以下
 のコマンドの 2 つずつはいずれも同じことになります:
      set term png font "arial"
      set term png font "/usr/local/fonts/ttf/arial.ttf"
      set term png font "Helvetica"
      set term png font "/usr/local/fonts/pfa/Helvetica.pfa"
 デフォルトのフォントサイズも同時に指定するには:
      set term png font "arial,11"

 TrueType と Adobe Type 1 フォントは、完全に大きさの変更や回転が可能で
 す。"set term" コマンドでフォントを指定しなかった場合、gnuplot は別の
 デフォルトフォントの設定があるかどうかを調べるために環境変数
 GNUPLOT_DEFAULT_GDFONT を参照します。
?fonts postscript
 PostScript フォント処理は、プリンタか表示ソフトが行います。もし、あな
 たのコンピュータにフォントが一切なくても、gnuplot は正しい PostScript
 ファイル、またはカプセル化 PostScript (*.eps) ファイルを生成できます。
 gnuplot は単に出力ファイル中にフォントを名前として入れるだけで、プリン
 タや表示ソフトがその名前からフォントを見つけるか近似することを仮定して
 います。

 PostScript プリンタや表示ソフトはすべて、標準的な Adobe フォントセット
 `Times-Roman`, `Helvetica`, `Courier`, `Symbol` は知っているはずです。
 多分その他にも多くのフォントが使えるようになっていると思いますが、それ
 ら特定のフォントセットはあなたのシステムやプリンタの設定に依存します。
 gnuplot は、それは知りませんし気にもしません。gnuplot が作成した *.ps
 や *.eps 出力は、あなたの要求したフォント名を単に持っているだけです。

 よって、
      set term postscript eps font "Times-Roman,12"
 は、すべてのプリンタや表示ソフトに適切な出力を作成します。

 一方、
      set term postscript eps font "Garamond-Premier-Pro-Italic"
 は、正しい PostScript を含む出力ファイルを作成しますが、それは特殊なフ
 ォントを参照しますので、一部のプリンタや表示ソフトしか、要求したその特
 定のフォントは表示できないでしょう。大抵の場合は別なフォントで代用され
 ます。

 しかし、指定したフォントを出力ファイル中に埋め込んで、どんなプリンタで
 もそれを使うようにすることも可能です。これには、あなたのシステムに適切
 なフォント記述ファイルがあることが必要となります。この方法でフォントを
 埋め込む場合、特定のライセンスが必要となるフォントファイルもあることに
 注意してください。より詳細な説明や例については、以下参照:
 `postscript fontfile`。
?glossary
 このドキュメント全体に渡って、用語に関する一貫性の維持が考えられていま
 す。しかしこの試みは完全には成功していません。それは `gnuplot` が時間
 をかけて進化してきたように、コマンドやキーワードの名前もそのような完全
 性を排除するかのように採用されて来ているからです。このセクションでは、
 これらのキーワードのいくつかがどのように使われているかを説明します。

 "ページ (page)"、"表示画面 (screen)"、"キャンバス (canvas)" は、
 `gnuplot` がアクセス可能な領域全体を指します。デスクトップではそれはウ
 ィンドウ全体を指し、プロッタでは、一枚の紙全体、svga モードでは、モニ
 タスクリーン全体を指します。

 表示画面は、一つ、またはそれ以上の "グラフ描画 (plot)" を含みます。グ
 ラフ描画は一つの横座標と一つの縦座標で定義されますが、余白 (margin) や
 その中に書かれる文字列 (text) 同様、それらは実際にその上に表示されてい
 る必要はありません。

 グラフ描画は一つの "グラフ" を含みます。グラフは一つの横座標と一つの縦
 座標で定義されますが、これらは実際にその上に表示されている必要はありま
 せん。

 グラフは一つまたはそれ以上の "曲線 (line)" を含みます。曲線は一つの関
 数、またはデータ集合です。用語 "line" は描画スタイルとしても使われます。
 さらにこの用語は "文字列の一行 (a line of text)" のように使われること
 もあります。多分文脈からそれらは区別できるでしょう。

 一つのグラフ上の複数の曲線はそれぞれ名前を持ちます。その名前は、その曲
 線の表現に使われる描画スタイルのサンプルとともに "凡例 (key)" 内に一覧
 表示されます。凡例は、時には "表題 (legend)" とも呼ばれます。

 用語 "タイトル (title)" は `gnuplot` では複数の意味で使われます。この
 ドキュメントではそれらを区別するために、形容詞として "描画の (plot)"、
 "曲線の (line)"、"凡例の (key)" を頭につけたりもします。
 2 次元のグラフは 4 つまでの見出し付けされる軸を持つことができます。こ
 れら 4 つの軸の名前はそれぞれ、グラフ描画の下の境界に沿う軸である "x"、
 左の境界に沿う軸 "y"、上の境界に沿う軸 "x2"、右の境界に沿う軸 "y2" と
 なっています。以下参照: `axes`。

 3 次元のグラフは  3 つまでの見出し付けされる軸 (`axes`) "x","y","z" を
 持つことができます。どの特定の軸に関してもそれがグラフ上でどこに書かれ
 るかを述べることはできません。それは、`set view` でグラフを見る方向を
 変更できるからです。

 データファイルに関する議論では、用語 "行 (record)" を復活し、ファイル
 の一行の文字列、すなわち、改行文字や行末文字同士の間の文字列、を指し示
 すのに使います。"点 (point)" は行から取り出した一つのデータです。デー
 タの "ブロック (block)" は、空行で区切られた連続した複数の行からなる集
 合です。データファイルの議論の中で "line" が参照される場合は、これはブ
 ロックの部分集合を指します。"データのブロック (data block)" という言葉
 は、インラインデータの名前付きブロックを指すのにも使われています。以下
 参照: `datablocks`。

 (訳注: この日本語訳の中ではここに書かれているような用語の統一は考慮さ
 れてはおらず、よって混乱を引き起こす可能性があります。厳密には原文を参
 照すべきでしょう。)
?inline data
?inline
?datablocks
 gnuplot のコマンド入力の中にデータを埋め込む仕組みは 2 種類用意されて
 います。まず、特殊ファイル名 '-' が plot コマンド中に与えると、その
 plot コマンド以下に続く行がインラインデータと解釈されます。以下参照:
 `special-filenames`。この方法で提供されるデータは、その plot コマンド
 で一度しか使用できません。

 もう一つは、ヒアドキュメントとして名前付きのデータブロックを定義する方
 法です。その名前付きのデータは残るので、複数の plot コマンドで参照でき
 ます。例:
      $Mydata << EOD
      11 22 33 first line of data
      44 55 66 second line of data
      # データファイル同様コメントも機能する
      77 88 99
      EOD
      stats $Mydata using 1:3
      plot $Mydata using 1:3 with points, $Mydata using 1:2 with impulses

 データブロック名は、他の変数と区別するために、最初の文字を $ にする必
 要があります。データの終わりの区切り (上の例では EOD) は、任意のアルフ
 ァベット、数字からなる文字列で構いません。

 コマンド `undefine` を使えば、保存した名前付きデータブロックを削除でき
 ます。`undefine $*` は、すべての名前付きデータブロックを一度に削除しま
 す。
?iteration
?iterate
 gnuplot バージョン 4.6 には、繰り返し (iteration) コマンドやブロック構
 造を扱える if/else/while/do が導入されています。以下参照: `if`,
 `while`, `do`。単純な繰り返しは、コマンド `plot`, `set` で利用できま
 す。以下参照: `plot for`。複数のコマンドを包含する一般的な繰り返しは、
 下で紹介するブロック構造を利用することで行えます。関連する新しい機能で
 ある数式型の以下も参照: `summation`。以下は、これらの新しい構文機能を
 いくつか利用した例です:
       set multiplot layout 2,2
       fourier(k, x) = sin(3./2*k)/k * 2./3*cos(k*x)
       do for [power = 0:3] {
           TERMS = 10**power
           set title sprintf("%g term Fourier series",TERMS)
           plot 0.5 + sum [k=1:TERMS] fourier(k,x) notitle
       }
       unset multiplot

 繰り返しは、以下のような書式による繰り返し指定で制御します。

      for [<var> in "string of N elements"]

 または

      for [<var> = <start> : <end> { : <increment> }]

 最初の書式では <var> は文字列変数で、その後ろに指定した文字列に含まれ
 る 1 番目から N 番目までの単語文字列を順に値として取ります。
 2 番目の書式では、<start>, <end>, <increment> は整数、または整数値を取
 る数式です。

?scope
 一つの例外を除いて、gnuplot の変数は大域的です。
 名前で添字づけされた、永続的で有効な変数のリストが一つだけあり、変数の
 割り当ては、そのリストに項を生成するか、または項の置き換えにより行われ
 ます。変数をそのリストから削除するただ一つの方法は、`undefine` コマン
 ドを使うことです。

 これのただ一つの例外は、繰り返し指定で用いられる変数です。繰り返し変数
 の有効範囲 (scope) は、その繰り返しの中だけですから、その値を、繰り返
 しの実行ブロック内から永続的に変更することはできません。繰り返し変数が
 繰り返しの前に値を持っていたとしたら、その値は繰り返しの終了時に保持、
 または復帰されます。
 例えば、以下のコマンドは、1 2 3 4 5 6 7 8 9 10 A を出力します。

      i = "A"
      do for [i=1:10] { print i; i=10; }
      print i

?linetypes
?colors
 古い版の gnuplot では、各出力形式は "線種 (linetype)" をある程度用意し
 ていて、それらは色、太さ、点線/破線のパターン、または色と点線/破線の組
 合せで違いを表現していました。それらの色、点線/破線のパターンは、出力
 形式を越えて同じものになるという保証は何もありませんでしたが、多くは同
 じ色の列、赤/緑/青/紫/水色/黄色を使用していました。この古い挙動は、今
 は `set colorsequence classic` で選択できますが、gnuplot バージョン 5
 のデフォルトは、出力形式に無関係に共通の 8 色列を使用します。

 線種 (linetype) の属性の並びは、対話的か初期化ファイルのいずれかによっ
 てさらにカスタマイズ可能です。以下参照: `set linetype`。配布パッケージ
 に初期化ファイルのサンプルがいくつか用意されています。

 特定の出力形式に対する線種の属性の現在の状態は、その出力形式を設定した
 あとで `test` コマンドを実行することで確認できます。

 一つの描画コマンド内での関数やデータファイルの連続する並びには、現在の
 デフォルトの線種列から線種が順番に割り当てられます。個々の関数、データ
 ファイル、またはその他の描画要素に対する線種は、その描画コマンド上で明
 示的に線の属性を指定することで上書きできます。

 例:

      plot "foo", "bar"                 # 線種 1, 2 で 2 ファイルを描画
      plot sin(x) linetype 4            # 線種色 4 を使用

 一般に、色の指定は、色の名前か、RGB (赤、緑、青) 成分か、HSV (色相、彩
 度、明度) 成分か、現在の pm3d パレットに沿った座標で行います。

 例:

      plot sin(x) lt rgb "violet"       # gnuplot の持つ色名の一つ
      plot sin(x) lt rgb "#FF00FF"      # 明示的な 16 進 RGB 3 つ組
      plot sin(x) lt palette cb -45     # 現在のパレットの cbrange の
                                        # -45 に対応する色
      plot sin(x) lt palette frac 0.3   # パレットに対応する小数値

 以下参照: `colorspec`, `show colornames`, `hsv`, `set palette`,
 `cbrange`。以下も参照: `monochrome`。

 線種 (linetype) には、点線/破線のパターンも結びつけられていますが、す
 べての出力形式でそれが使えるわけではありません。gnuplot バージョン 5
 では、線色とは独立に点線/破線パターンを指定できます。以下参照:
 `dashtype`。

?colorspec
?rgbcolor
?lc
?linecolor
?tc
?textcolor
 多くのコマンドで、明示的な色の指定をともなった線種を指定することができ
 ます。

 書式:

       ... {linecolor | lc} {"colorname" | <colorspec> | <n>}
       ... {textcolor | tc} {<colorspec> | {linetype | lt} <n>}

 <colorspec> は以下の形式のいずれかです:

       rgbcolor "colorname"    # 例: "blue"
       rgbcolor "0xRRGGBB"     # 16 進数値の定数文字列
       rgbcolor "0xAARRGGBB"   # 16 進数値の定数文字列
       rgbcolor "#RRGGBB"      # x11 形式の 16 進数文字列
       rgbcolor "#AARRGGBB"    # x11 形式の 16 進数文字列
       rgbcolor <integer val>  # AARRGGBB を表す整数値
       rgbcolor variable       # 入力ファイルから整数値を読み込む
       palette frac <val>      # <val> は 0 から 1 の値
       palette cb <value>      # <val> は cbrange の範囲の値
       palette z
       variable                # 入力ファイルから色番号を読み込む
       bgnd                    # 背景色
       black

 <n> は、その線種 (linetype) 番号が使う色を意味します。以下参照:
 `test`。

 "colorname" は gnuplot が内部に持っている色の名前のうちの一つを指定し
 ます。有効な名前の一覧に関しては、以下参照: `show colornames`。

 16 進定数は、引用符付きで "#RRGGBB" や "0xRRGGBB" の形で与えることがで
 きます。RRGGBB は、色の赤、緑、青の成分を意味し、それぞれ 00 から FF
 までの範囲内でなければいけません。例えば、マゼンタ (紫) は、最も明るい
 赤 + 最も明るい青、なので "0xFF00FF" と表され、これは 16 進数で
 (255 << 16) + (0 << 8) + (255) を意味しています。

 "#AARRGGBB" は、RGB 色の上位ビットにアルファ値 (透過性) がついているこ
 とを意味します。アルファ値 0 は完全に不透明色であることを意味し、よっ
 て "#00RRGGBB" は "#RRGGBB" と同じになります。アルファ値の 255 (FF) は
 完全に透明であることを意味します。`注意`: この指定法のアルファ値の位置
 は、以前の版の gnuplot の画像描画モード "with rgbalpha" による指定の場
 合の反対になっています。

 カラーパレットとは、色の線型な勾配で、単一の数値を特定の色に滑らかに対
 応づけます。常にそのような 2 つの対応付けが効力を持ちます。
 `palette frac` は 0 から 1 までの小数値を、カラーパレットの全範囲に対
 応付けるもので、`palette cb` は、色軸の範囲を同じカラーパレットへ割り
 当てるものです。以下参照: `set cbrange`, `set colorbox`。これらの対応
 付けのどちらかを使って、現在のパレットから定数色を選び出すことができま
 す。

 "palette z" は、各描画線分や描画要素の z の値を、パレットへ対応づけら
 れている cbrange の範囲に対応づけます。これにより、3 次元の曲線や曲面
 に沿って色を滑らかに変化させることができます。これは、2 次元描画で、パ
 レット値を追加の列データから読み込ませて色付けするのにも使えます (すべ
 ての 2 次元描画スタイルがこの追加列を認識するわけではありません)。
 特殊な色指定が 2 つあります。背景色の `bgnd` と、`black` です。
?background
?bgnd
 多くの出力形式でグラフの背景色を明示的に設定できます。特別な線種
 (linetype) `bgnd` はその色で描画しますが、その `bgnd` は色としても認識
 されます。
 例:
      # 以下はキャンバスの一部分を背景色で上書きすることで消去します。
      set term wxt background rgb "gray75"
      set object 1 rectangle from x0,y0 to x1,y1 fillstyle solid fillcolor bgnd
      # 以下は x 軸に沿った「見えない」線を描きます。
      plot 0 lt bgnd
?linecolor variable
?lc variable
?textcolor variable
?tc variable
?variable linecolor
 `lc variable` は、入力データの一つの列から読んだ値を線種 (linetype) の
 番号として使い、その線種に属する色を使うようプログラムに指示します。よ
 ってこれは、`using` 指定子へ対応する列の指定の追加を必要とします。文字
 の色も同様に、`tc variable` で指定できます。

 例:
       # データの 3 列目を、個々の点に色を割り当てるのに使用
       plot 'data' using 1:2:3 with points lc variable

       # 一つのデータファイルには複数のデータ集合を入れることが可能で、
       # それらは 2 行の空行で分離されています。個々のデータ集合には
       # index 値が割り当てられていて (以下参照: `index`)、using 指定の
       # column(-2) で取得できます。以下参照: `pseudocolumns`。以下の例
       # は -2 の column 値を使って、個々のデータ集合を異なる線色で描画
       # します。
       plot 'data' using 1:2:(column(-2)) with lines lc variable

?rgbcolor variable
?lc rgbcolor variable
?tc rgbcolor variable
?variable rgbcolor
?variable textcolor
 グラフの各データ点、各線分、または各ラベルにそれぞれ異なる色を割り当て
 ることができます。`lc rgbcolor variable` は、データファイルの各行から
 RGB 色の情報を読み込むようプログラムに指示します。よってこれは、
 `using` 指定子による対応する列の指定の追加を必要とし、その列は 24-bit
 形式の RGB の 3 つ組であるとみなされます。その値をデータファイルから直
 接与える場合は、これは最も簡単な形式の 16 進値で与えます (以下参照:
 `rgbcolor`)。一方で、以下の例のように 24-bit RGB 色として評価されるよ
 うな数式を `using` 指定子に入れることもできます。文字の色も同様に、
 `tc rgbcolor variable` で指定できます。

 例:
       # 3 次元描画で、各 x,y,z 座標に対応した赤、緑、青の成分を持つ色
       # のついた点を配置
       rgb(r,g,b) = 65536 * int(r) + 256 * int(g) + int(b)
       splot "data" using 1:2:3:(rgb($1,$2,$3)) with points lc rgb variable

?dashtype
 gnuplot バージョン 5 で、`linecolor` や `linewidth` と同様に、点線/破
 線パターン (`dashtype`) が各曲線毎の属性として独立しました。従来のよう
 な、使用中の出力形式の点線を書くための特別なモードとして指定する必要は
 ありません。すなわち、`set term <termname> {solid|dashed}` のようなコ
 マンドは現在は無視されます。バージョン 4 用に書いた古いスクリプトへの
 後方互換性が必要な場合は、以下のような書き方で代用できます:

      if (GPVAL_VERSION >= 5.0) set for [i=1:9] linetype i dashtype i
      if (GPVAL_VERSION < 5.0) set termoption dashed

 すべての線は、ほかに指定しなければ、`dashtype solid` という属性を持ち
 ますが、このデフォルト値をコマンド `set linetype` で特定の線種に変更し
 その後のコマンドで使えるようにできます。または、`plot` や他のコマンド
 の一部分として使用したい点線/破線の型を指定できます。

 書式:
       dashtype N          # 定義済み点線/破線型を番号で呼び出し
       dashtype "pattern"  # 点 (.) 横線 (-) 下線 (_) と空白の組み合わ
                           # せ文字列による指定
       dashtype (s1,e1,s2,e2,s3,e3,s4,e4)  # 1~4 個の <実線長>,<空白長>
                           # の組による点線/破線パターン指定

 例:
       # 2 つの関数が線種 1 を使うが dashtype で区別
       plot f1(x) with lines lt 1 dt solid, f2(x) with lines lt 1 dt 3

 いくつかの出力形式は、それが提供する定義済み点線/破線パターンに、ユー
 ザ定義パターンを追加することをサポートしています。

 例:
      plot f(x) dt 3            # 出力形式の持つパターン 3 を使用
      plot f(x) dt ".. "        # 一時的なパターンを作成
      plot f(x) dt (2,5,2,15)   # 同じパターンを数値で表現
      set dashtype 11 (2,4,4,7) # 新パターンを番号で呼び出せるよう定義
      plot f(x) dt 11           # 新パターンを使って描画

 点線/破線パターンを文字列で指定した場合、gnuplot はそれを <実線長>,
 <空白長> の組の列に変換します。ドット "." は (2,5) に、ダッシュ "-" は
 (10,10) に、下線 "_" は (20,10) に、また空白 " " は直前の <空白長> の
 値に 10 を追加します。その場合、コマンド `show dashtype` は、元の文字
 列と変換後の数値の列の両方を表示します。

?linestyles vs linetypes
 `linestyle` は、属性 linecolor, linewidth, dashtype, pointtype の一時
 的な組み合わせで、これはコマンド `set style line` で定義します。一度
 linestyle を定義すると、1 回の plot コマンド上でそれを使って、1 つ、ま
 たはより多くの描画要素の見た目を制御できます。言い換えれば、これは丁度
 linetype から永続性を取り除いたもの、と言うことができるでしょう。
 `linetypes` は永続的 (明示的にそれらを再定義するまでは保持される) です
 が、`linestyles` は、次のグラフィックの状態がリセットされるまでの間し
 か保持されません。

 例:

      # 新しいラインスタイルを、出力形式に依存しない色 cyan、線幅が 3、
      # 点種 6 (丸の中に点) と定義
      set style line 5 lt rgb "cyan" lw 3 pt 6
      plot sin(x) with linespoints ls 5          # 定義スタイル 5 で

?layers
?behind
?front
?back
 gnuplot のグラフは、色々な要素を固定された順番で描き上げていくことで構
 成されています。この順番は、キーワード `behind`, `back`, `front` を使
 って要素に特定の階層を割り当てることで変更できます。例えば、グラフ領域
 の背景色を変更するには、色のついた長方形を属性 `behind` で定義すればい
 いわけです。
      set object 1 rectangle from graph 0,0 to graph 1,1 fc rgb "gray" behind
 描画の順番は以下の通りです:
      behind
      back
      グラフ自体
      グラフの表題 (`key`)
      front
 各階層内では、要素の描画は以下の順番です:
      番号順のオブジェクト (rectangle, circle, ellipse, polygon)
      番号順のラベル (label)
      番号順の矢印 (arrow)
 1 ページに複数のグラフがある場合 (multiplot モード)、この順序は、複数
 グラフを全体として適用するのではなく、各描画要素に別々に適用します。
?mouse input
 多くの出力形式で、現在の描画にマウスを使って作用をすることが可能になっ
 ています。そのうちいくつかはホットキーの定義もサポートしていて、マウス
 カーソルが有効な描画ウィンドウにあるときに、あるキーを押すことであらか
 じめ定義した関数を実行させることができます。マウス入力を `batch` コマ
 ンドスクリプトと組み合わせることも可能で、例えば `pause mouse` として、
 その後にマウスクリックによってパラメータとして返って来るマウス変数をそ
 の後のスクリプト動作に反映させることができます。以下参照: `bind`,
 `mouse variables`。また以下も参照: `set mouse`。
?commands bind
?hotkey
?hotkeys
?bind
 書式:
       bind {allwindows} [<key-sequence>] ["<gnuplot commands>"]
       bind <key-sequence> ""
       reset bind

 `bind` は、ホットキーの定義、再定義に使用します。ホットキーとは、入力
 カーソルがドライバのウィンドウ内にあるときに、あるキー、または複数のキ
 ーを押すことで、gnuplot のコマンド列を実行させる機能のことを言います。
 `bind` は、gnuplot が `mouse` をサポートするようにコンパイルされていて
 かつマウスが有効な出力形式上で使われてる場合にのみ有効であることに注意
 してください。ユーザ指定のキー割当 (binding) は、組み込み (builtin) キ
 ー割当を置き換えますが、<space> と 'q' は通常は再定義はできません。そ
 の唯一の例外については、以下参照: `bind space`。

 マウスボタンは、ボタン 1 のみ、2 次元描画用にのみ定義可能です。

 ホットキーの一覧を得るには `show bind`, または `bind` とタイプするか、
 グラフウィンドウ上でホットキー 'h' を入力してください。

 キー定義は、`reset bind` でデフォルトの状態に復帰できます。

 修飾キーを含む複数のキーの定義は引用符で囲む必要があることに注意してく
 ださい。

 標準ではホットキーは現在の描画ウィンドウ上に入力カーソルがある場合のみ
 認識されます。`bind allwindows <key> ...` (`bind all <key> ...` と省略
 可) は、<key> の割当を、それが現在の有効なものか否かに関わらず、すべて
 の gnuplot の描画ウィンドウ上で可能にします。この場合、gnuplot 変数
 MOUSE_KEY_WINDOW にそれが行なわれたウィンドウの ID が保存されるのでそ
 れをキーに割り当てたコマンドで使用することができます。

 例:

 - キー割当の設定:

     bind a "replot"
     bind "ctrl-a" "plot x*x"
     bind "ctrl-alt-a" 'print "great"'
     bind Home "set view 60,30; replot"
     bind all Home 'print "This is window ",MOUSE_KEY_WINDOW'

 - キー割当を表示:
     bind "ctrl-a"          # ctrl-a に対するキー割当を表示
     bind                   # 全てのキー定義を表示
     show bind              # 全てのキー定義を表示

 - キー割当を削除:
     bind "ctrl-alt-a" ""   # ctrl-alt-a のキー割当を削除
                              (組み込みキー定義は削除されません)
     reset bind             # デフォルト (組み込み) のキー定義を導入

 - トグルスイッチ形式にキー割当:
   v=0
   bind "ctrl-r" "v=v+1;if(v%2)set term x11 noraise; else set term x11 raise"

 修飾キー (ctrl / alt) は大文字小文字の区別はありませんが、キーはそうで
 はありません:
     ctrl-alt-a == CtRl-alT-a
     ctrl-alt-a != ctrl-alt-A

 修飾キー (alt == meta) の一覧:
     ctrl, alt, shift (ボタン 1 でのみ有効)

 サポートされている特殊キーの一覧:

    "BackSpace", "Tab", "Linefeed", "Clear", "Return", "Pause", "Scroll_Lock",
    "Sys_Req", "Escape", "Delete", "Home", "Left", "Up", "Right", "Down",
    "PageUp", "PageDown", "End", "Begin",

    "KP_Space", "KP_Tab", "KP_Enter", "KP_F1", "KP_F2", "KP_F3", "KP_F4",
    "KP_Home", "KP_Left", "KP_Up", "KP_Right", "KP_Down", "KP_PageUp",
    "KP_PageDown", "KP_End", "KP_Begin", "KP_Insert", "KP_Delete", "KP_Equal",
    "KP_Multiply", "KP_Add", "KP_Separator", "KP_Subtract", "KP_Decimal",
    "KP_Divide",

    "KP_1" - "KP_9", "F1" - "F12"

 以下は、実際のキーではなく、ウィンドウに関するイベントです:

    "Button1" "Close"

 以下も参照: `mouse`。
?commands bind space
?bind space
 gnuplot が、configure 時にオプション --enable-rase-console をつけてイ
 ンストールされた場合は、描画ウィンドウ内で <space> をタイプすると
 gnuplot のコマンドウィンドウが前面に出ます。このホットキーは、
 'gnuplot -ctrlq' のようにして gnuplot を起動するか、または X リソース
 の 'gnuplot*ctrlq' を設定することで ctrl-space に変更できます。
 以下参照: `x11 command-line-options`。
?mouse variables
 `mousing` (マウス機能) が有効な場合、現在のウィンドウ上でのマウスクリ
 ックによって gnuplot のコマンドライン上で使うことができる色々なユーザ
 変数が設定されます。クリック時のマウスの座標は変数 MOUSE_X, MOUSE_Y,
 MOUSE_X2, MOUSE_Y2 に代入されます。クリックされたボタンや、そのときの
 メタキーの状態は MOUSE_BUTTON, MOUSE_SHIFT, MOUSE_ALT, MOUSE_CTRL に代
 入されます。これらの変数は任意の描画の開始時には未定義で、有効な描画ウ
 ィンドウ中でのマウスクリックイベントによって初めて定義されます。有効な
 描画ウィンドウ中でマウスが既にクリックされたかどうかをスクリプトから調
 べるには、これらの変数のうちのどれか一つが定義されているかどうかをチェ
 ックすれば十分です。

       plot 'something'
       pause mouse
       if (exists("MOUSE_BUTTON")) call 'something_else'; \
       else print "No mouse click."

 描画ウィンドウ上での一連のキー入力を追跡することも、マウスコードを使う
 ことで可能となります。

       plot 'something'
       pause mouse keypress
       print "Keystroke ", MOUSE_KEY, " at ", MOUSE_X, " ", MOUSE_Y

 `pause mouse keypress` が、キー入力で終了した場合は MOUSE_KEY には押さ
 れたキーの ASCII コードが保存されます。MOUSE_CHAR にはその文字自身が文
 字列値として保存されます。pause コマンドが (例えば ctrl-C や描画ウィン
 ドウが外部から閉じられるなどして) 異常終了した場合は MOUSE_KEY は -1
 になります。

 マウスによる拡大の後の新しい描画範囲は、GPVAL_X_MIN, GPVAL_X_MAX,
 GPVAL_Y_MIN, GPVAL_Y_MAX で参照できることに注意してください。
 以下参照: `gnuplot-defined variables`。
?persist
 gnuplot の多くの出力形式 (aqua, pm, qt, x11, windows, wxt, ...) が、ス
 クリーン上にグラフをその中に描いた表示用のウィンドウを別に開きます。オ
 プション `persist` は、主たるプログラムが終了したときにも、それらのウ
 ィンドウを残すよう gnuplot に指示します。
 これは、非対話型出力形式出力では何もしません。
 例えば、以下のコマンドを実行すると

      gnuplot -persist -e 'plot [-5:5] sinh(x)'

 gnuplot は、表示ウィンドウを開き、その中にグラフを描き、そして終了し、
 表示ウィンドウはグラフをその中に持ったままスクリーンに残ります。出力形
 式によっては、その残ったウィンドウ上でも多少のマウス操作が可能な場合も
 あります。しかし、グラフの再描画を要求するズーム (とその逆) のような操
 作は、既にプログラムが終了しているので一般的には無理です。

 新しい出力形式を設定するときにも `persist` や `nopersist` を指定できま
 す。例:

      set term qt persist size 700,500

?plotting
 `gnuplot` にはグラフを描画する 4 つのコマンド `plot`, `splot`, `replot`,
 `refresh` があります。他のコマンドは、最終的にグラフ上に生成される描画
 要素や、レイアウト、スタイルの制御を行います。
 `plot` は 2 次元グラフを生成します。`splot` は 3 次元グラフ (もちろん
 実際にはその 2 次元面への射影) を生成します。`replot` は、直前の `plot`
 や `splot` コマンドを再実行します。`refresh` は、`replot` と似ています
 が、入力データをファイルや入力ストリームから再読み込みする代わりに、前
 に保存したデータを再使用します。

 これら 4 つのコマンドのうちの一つを実行した場合は、現在定義されている
 軸、ラベル、タイトル、および元の plot コマンドで指定されたさまざまな関
 数やデータのすべてを含む出力のスクリーンを再描画するか、新しい出力ペー
 ジを生成します。もし、一つのページに複数のグラフを隣り合うように並べて
 出力したい場合、例えば複数の図のパネルを作成したり、大きなグラフの中に
 小さなグラフを挿入したりしたい場合は、コマンド `set multiplot` を使用
 し、各描画コマンドで新しいページが作られるのを抑制してください。

 描画に関する一般的な情報の大半は、`plot` に関する項で見つかります。3
 次元描画に固有の情報は `splot` の項にあります。

 `plot` は xy 直交座標系と極座標系が使えます。以下参照: `set polar`。
 `splot` は xyz 直交座標が使えますが、3 次元極座標、円柱座標データも入
 力できます。以下参照: `set mapping`。
 `plot` では、4 つの境界 x (下), x2 (上), y (左), y2 (右) をそれぞれ独
 立な軸として扱うこともできます。オプション `axes` で、与えられた関数や
 データ集合をどの軸のペアで表示させるかを選べます。また、各軸の縮尺や見
 出しづけを完全に制御するために十分な補佐となる `set` コマンド群が存在
 します。いくつかのコマンドは、`set xlabel` のように軸の名前をその中に
 持っていますし、それ以外のものは `set logscale xy` のように、1 つ、ま
 たは複数の軸の名前をオプションとしてとります。z 軸を制御するオプション
 やコマンドは 2 次元グラフには効力を持ちません。

 `splot` は、点や線に加えて曲面や等高線を書くことができます。3 次元の関
 数の格子定義に関する情報については、以下参照: `set isosamples`。3 次元
 データのファイルに必要な形態については、以下参照: `splot datafile`。等
 高線に関する情報については、以下参照: `set contour`, `set cntrlabel`,
 `set cntrparam`。

 `splot` での縮尺や見出し付けの制御は、z 軸にも有効であること、および
 x2 軸、y2 軸のラベル付けが `set view map` を使って作られる疑似的な 2
 次元描画にのみ可能であることを除けば `plot` と全く同じです。
?startup
?start
?start-up
?initialization
?.gnuplot
 起動時に、gnuplot はまずシステム用の初期設定ファイル `gnuplotrc` を探
 します。そのファイルの置き場所は gnuplot のインストール時に決定され、
 `show loadpath` で知ることができます。次にユーザのホームディレクトリ内
 に個人用の設定ファイルを探します。そのファイルは Unix 系のシステムでは
 `.gnuplot` であり、その他の処理系では `GNUPLOT.INI` となっています。
 (OS/2 では、環境変数 `GNUPLOT` に設定されている名前のディレクトリ内に
 それを探します; Windows では、`APPDATA` を使用します)。注意: インスト
 ール時に `gnuplot` が最初にカレントディレクトリを探すように設定できま
 すが、セキュリティ上危険なのでそれは推奨しません。
?string
?strings
?string variables
 文字列定数に加えて、ほとんどの gnuplot コマンドは文字列変数、文字列式
 または文字列を返す関数も受け付けます。例えば、以下の 4 つの plot のや
 り方は結果として全て同じ描画タイトルを生成します:

       four = "4"
       graph4 = "Title for plot #4"
       graph(n) = sprintf("Title for plot #%d",n)

       plot 'data.4' title "Title for plot #4"
       plot 'data.4' title graph4
       plot 'data.4' title "Title for plot #".four
       plot 'data.4' title graph(4)

 整数は、それが文字列結合演算子 (文字 '.') によって作用された場合は、文
 字列に変換されますので、以下の例も上と同様に動作します:

       N = 4
       plot 'data.'.N title "Title for plot #".N

 一般に、コマンドラインの各要素は、それらが標準的な gnuplot への命令文
 法の一部分と認識されるもの以外は、有効な文字列変数としての評価のみが行
 なわれます。よって、以下のコマンド列は、恐らくは混乱を引き起こさないよ
 うに避けられるべきですが、文法的には間違ってはいません:

       plot = "my_datafile.dat"
       title = "My Title"
       plot plot title title

 次の 3 つの二項演算子は文字列に作用します: 文字列の結合演算子 ".", 文
 字列の等号演算子 "eq", および文字列の不等号演算子 "ne" です。以下の例
 では TRUE が表示されます。

      if ("A"."B" eq "AB") print "TRUE"

 以下も参照: 2 つの文字列書式関数 `gprintf`, `sprintf`。

 任意の文字列、文字列変数、文字列値関数に、範囲指定子をつけることにより
 部分文字列を指定できます。範囲指定子は [begin:end] の形で、begin は部
 分文字列の先頭位置、end は最後の位置です。位置指定は、最初の文字を 1
 番目と見ます。先頭の位置、最後の位置は空、あるいは '*' でも構いません。
 その場合、それは元の文字列自体の先頭、あるいは最後を意味します。例えば、
 str[:] や str[*:*] はどちらも str の文字列全体を意味します。
?substitution
 gnuplot への命令文字列が最初に読み込まれた時点、すなわちまだそれが解釈
 され、もしくは実行される前の段階で、2 つの形式の単語の置換が実行されま
 す。それらは逆引用符 (｀) (ASCII 番号 96) で囲まれているか、または @
 (ASCII 番号 64) が頭についた文字列に対して行なわれます。
?substitution backquotes
?backquotes
?shell commands
 シェルコマンドを逆引用符 (｀) で囲むことによってコマンド置換を行うこと
 ができます。このコマンドは子プロセスで実行され、その出力結果でコマンド
 ラインの逆引用符で囲まれた部分を置き換えます。システムコマンドの終了ス
 テータスは、変数 GPVAL_SYSTEM_ERRNO と GPVAL_SYSTEM_ERRMSG に返されま
 す。

 置換実行中は、復帰 ('\r') と改行 ('\n') 文字を入力列から削除します。こ
 れは、system() 関数からの戻り値の文字列とは違うところで、そちらはこれ
 らの文字を削除しません。以下参照: `system`。

 コマンド置換は、単一引用符内の文字列以外は、`gnuplot` のコマンドライ
 ン中、どこででも使用可能です。

 例:

 以下の例は、`leastsq` というプログラムを実行し、その出力結果で、
 `leastsq` を (まわりの引用符こみで) 置き換えます:
       f(x) = `leastsq`

 ただし VMS では、
       f(x) = `run leastsq`

 以下は現在の日付とユーザー名のラベルを生成します:
       set label "generated on `date +%Y-%m-%d` by `whoami`" at 1,1
       set timestamp "generated on %Y-%m-%d by `whoami`"
?substitution macros
?macros
 文字 @ は、コマンドライン上でその文字列変数の値への置換を行なうのに使
 われます。文字列変数の値としての文は、複数の単語からなることも可能です。
 これにより文字列変数をコマンドラインマクロとして使うことが可能になりま
 す。この機能により展開できるのは文字列定数のみで、文字列を値に取る数式
 を使うことはできません。
 例:

       style1 = "lines lt 4 lw 2"
       style2 = "points lt 3 pt 5 ps 2"
       range1 = "using 1:3"
       range2 = "using 1:5"
       plot "foo" @range1 with @style1, "bar" @range2 with @style2

 この @ 記号を含む行は、その入力時に展開され、それが実際に実行されると
 きには次のように全部打ち込んだ場合と同じことになります。

       plot "foo" using 1:3 with lines lt 4 lw 2, \
            "bar" using 1:5 with points lt 3 pt 5 ps 2

 関数 exists() はマクロの評価に関して有用でしょう。以下の例は、C が安全
 にユーザ定義変数の名前に展開できるかどうかをチェックします。

       C = "pi"
       if (exists(C)) print C," = ", @C

 マクロの展開は、単一引用符内、または二重引用符内では行なわれませんが、
 逆引用符 (｀) 内ではマクロ展開されます。

 マクロの展開は、gnuplot が新しいコマンド行を見たときに非常に早い段階で
 gnuplot が処理し、そしてただ一度だけそれを行います。よって、

      A = "c=1"
      @A

 のようなコードは正しく実行しますが、以下のような行はだめです。それは、
 マクロの定義が同じ行にあるため展開に間に合わないからです。

      A = "c=1"; @A   # will not expand to c=1

 中カッコ内でのマクロの展開は、ループの実行前に行われます。すなわち、
 A 自身をループ内で変更しても @A は常に元の A の値として作用します。

 コマンドを完成させて実行するには、コマンド `evaluate` も有用でしょう。
?mixing_macros_backquotes
?substitution mixing_macros_backquotes
 文字列変数や逆引用符 (｀) による置換、マクロによる置換の相互関係は少し
 ややこしいです。逆引用符はマクロ置換を妨げないので、

       filename = "mydata.inp"
       lines = ` wc --lines @filename | sed "s/ .*//" `

 は、mydata.ipn の行数を整数変数 lines に保存することになります。また、
 二重引用符は逆引用符の置換を妨げないので、

       mycomputer = "`uname -n`"

 は、システムコマンド `uname -n` の返す文字列を文字列変数 mycomputer に
 保存することになります。

 しかし、マクロ置換は二重引用符内では機能しないので、システムコマンドを
 マクロとして定義してそれをマクロとして利用しかつ逆引用符置換を行なうこ
 とはでできません。

        machine_id = "uname -n"
        mycomputer = "`@machine_id`"  # うまくいかない !

 この失敗は、二重引用符が @machine_id をマクロとして解釈することを妨げ
 ているからです。システムコマンドをマクロとして保存し、その後それを実行
 するには、逆引用符自体もマクロ内に含める必要があります。これは以下のよ
 うにマクロを定義することで実現できます。sprintf の書式には 3 種類の引
 用符全てが入れ子になっていることに注意してください。

       machine_id = sprintf('"`uname -n`"')
       mycomputer = @machine_id
?syntax
?specify
?punctuation
 リストや座標がコンマ (,) 区切りであるのに対し、オプションやそれに伴う
 パラメータはスペース ( ) 区切りです。範囲はコロン (:) で区切ってかぎか
 っこ ([]) でくくりますし、文字列やファイル名は引用符でくくり、他にいく
 つかカッコ (()) でくくるものがあります。

 コンマは以下の区切りで使用されます。`set` コマンドの `arrow`, `key`,
 `label` の座標; 当てはめ (fit) られる変数のリスト (コマンド `fit` のキ
 ーワード `via` に続くリスト); コマンド `set cntrparam` で指定されると
 びとびの等高線の値やそのループパラメータのリスト; `set` コマンドの
 `dgrid3d` `dummy`, `isosamples`, `offsets`, `origin`, `samples`,
 `size`, `time`, `view` の引数; 目盛りの位置やそのループパラメータのリ
 スト; タイトルや軸の見出しの位置; `plot`, `replot`, `splot` コマンドの
 x,y,z 座標の計算に使われる媒介変数関数のリスト; `plot`, `replot`,
 `splot` コマンドの複数の描画 (データ、または関数) のそれぞれの一連のキ
 ーワードのリスト。

 (丸) カッコは、目盛りの見出しを (ループパラメータではなく) 明示的に集
 合与える場合の区切りとして、または `fit`, `plot`, `replot`, `splot` コ
 マンドの `using` フィルタでの計算を指示するために使われます。

 (カッコやコンマは通常の関数の表記でも使われます。)

 かぎかっこは、`set`, `plot`, `splot` コマンドでは範囲を区切るのに使わ
 れます。

 コロンは `range` (範囲) 指定 (`set`, `plot`, `splot` コマンドで使われ
 る) の両端の値を区切るのに、または `plot`, `replot`, `splot`, `fit` コ
 マンドの `using` フィルタの各エントリを区切るのに使われます。

 セミコロン (;) は、一行のコマンド行内で与えられる複数のコマンドを区切
 るのに使われます。

 中カッコ ({}) は、拡張文字列処理モード (enhanced text mode) の記述や、
 if/then/else 文のブロックの区切りとして使われますし、または複素数を記
 述するのにも使われます: {3,2} = 3 + 2i となります。

 EEPIC, Imagen, Uniplex, LaTeX, TPIC の各出力形式では、単一引用符内の
 \\ または二重引用符内の \\\\ で改行を示すことが可能です。
?quotes
?syntax quotes
 gnuplot は、文字列を区切るのに、二重引用符 (ASCII コード 34 番)、単一
 引用符 (ASCII コード 39 番)、および逆引用符 (｀) (ASCII コード 96 番)
 の 3 種類の引用符を使います。

 ファイル名は単一引用符、あるいは二重引用符内で囲みます。このマニュアル
 では一般にコマンドの例示では、わかりやすくするためにファイル名は単一引
 用符でくくり、他の文字列は二重引用符でくくります。

 見出し (label)、タイトル (title)、またはその他の描画要素で使用される文
 字列定数や複数行文字列は単一引用符、あるいは二重引用符内で囲みます。引
 用符で囲まれた文字列のさらなる処理の結果は、どの引用符記号を選ぶかによ
 って変わります。

 \n (改行) や \345 (8 進表記の文字コード) のようなバックスラッシュ (\)
 による特殊文字表現は、2 重引用符内の文字列でのみ効力を持ちます。単一引
 用符内では、バックスラッシュ自体が通常の文字と見なされます。単一引用符
 内の文字列で単一引用符自体 (ASCII コード 39 番) を使うには、それを重ね
 て書く必要があります。つまり、文字列 "d\" s' b\\" と、'd" s'' b\' は完
 全に同じものとなります。

 1 つの複数行文字列に関する行揃えは各行に同等に働きます。よって、中央に
 行揃えされた文字列
       "This is the first line of text.\nThis is the second line."
 は次のように表示されます:
                        This is the first line of text.
                           This is the second line.
 しかし
       'This is the first line of text.\nThis is the second line.'
 だと次のようになります。
           This is the first line of text.\nThis is the second line.

 拡張文字列処理 (enhanced text processing) は二重引用符に対しても単一引
 用符に対しても機能します。しかし、そのモードをサポートしている出力形式
 でのみ働きます。以下参照: `enhanced text`。

 逆引用符は,コマンドライン中の置換のためにシステムコマンドを囲むのに使
 います。以下参照: `substitution`。
?time/date
 `gnuplot` は入力データとして時間/日付情報の使用をサポートしています。
 この機能は `set xdata time`, `set ydata time` などのコマンドによって有
 効になります。

 内部では全ての時間/日付は 1970 年からの秒数に変換されます。コマンド
 `set timefmt` は全ての入力に対するデフォルトの書式を定義します。データ
 ファイル、範囲、軸の目盛りの見出し、ラベルの位置と、日時データ値を受け
 入れるすべてのものへの入力の書式が、デフォルトでこれになります。一時に
 は一つのデフォルト入力書式のみが有効です。よって、ファイル内の x と y
 の両方が時間/日付データである場合は、デフォルトではそれは同じ書式と解
 釈されます。しかし、このデフォルトは、`using` 指定で関数 `timecolumn`
 を用いて、それに対応する特定のファイルや列からデータを読みこむことによ
 り、変えることが可能です。

 秒数へ (秒数から) の変換は国際標準時 (UT; グリニッジ標準時 (GMT) と同
 じ) が使われます。各国標準時や夏時間への変換の機能は何も持ち合わせてい
 ません。もしデータがすべて同じ標準時間帯に従っているなら (そして全てが
 夏時間か、そうでないかのどちらか一方にのみ従うなら) これに関して何も心
 配することはありません。しかし、あなたが使用するアプリケーションで絶対
 的な時刻を厳密に考察しなければいけない場合は、あなた自身が UT に変換す
 べきでしょう。

 `show xrange` のようなコマンドは、その整数値を `timefmt` に従って解釈
 し直します。`timefmt` を変更してもう一度 `show` でその値を表示させると、
 それは新しい `timefmt` に従って表示されます。このため、(`set xdata` な
 どにより) その軸に対するデータ型をリセットすると、その値は整数値として
 表示されることになります。

 コマンド `set format` または `set tics format` は、指定された軸に対す
 る入力が時間/日付であるなしに関わらず目盛りの見出しに使われる書式を定
 義します。

 時間/日付情報がファイルから描画される場合、`plot`, `splot` コマンドで
 は `using` オプションを「必ず」使う必要があります。`plot`, `splot` で
 は各行のデータ列の分離にスペースを使いますが、時間/日付データはその中
 にスペースを含み得るからです。もしタブ区切りを使用しているのなら、あな
 たのシステムがそれをどう扱うか確かめるために何度もテストする必要がある
 でしょう。

 関数 `time` は、現在のシステム時刻を得るのに使えます。この値は、
 `strftime` 関数で日時文字列に変換できますし、`timecolumn` と組み合わせ
 て相対的な日時グラフを作成するのにも使えます。引数の型はそれが返すもの
 を決定します。引数が整数の場合は time() は現在の時刻を 1970 年 1 月 1
 日からの整数として返し、引数が実数 (または複素数) ならば同様の値を実数
 として返しますが、小数 (秒以下) 部分の精度は、オペレーティングシステム
 に依存します。引数が文字列ならば、それを書式文字列であるとみなし、書式
 化された日時文字列を提供するようそれを `strftime` に渡します。

 次の例は時間/日付データの描画の例です。

 ファイル "data" は以下のような行からなるとします:

       03/21/95 10:00  6.02e23

 このファイルは以下のようにして表示されます:

       set xdata time
       set timefmt "%m/%d/%y"
       set xrange ["03/21/95":"03/22/95"]
       set format x "%m/%d"
       set timefmt "%m/%d/%y %H:%M"
       plot "data" using 1:3

 ここで、x 軸の目盛りの見出しは "03/21" のように表示されます。

 現在の gnuplot は、時刻をミリ秒精度で追跡し、時刻のフォーマットもそれ
 に伴って変更されています。
 例: 現在の時刻をミリ秒精度で表示
      print strftime("%H:%M:%.3S %d-%b-%Y",time(0.0))
      18:15:04.253 16-Apr-2011

 以下参照: `time_specifiers`。
?plotting styles

 gnuplot では、たくさんの描画スタイルが利用できます。
 それらは、アルファベット順に以下に紹介されています。
 コマンド `set style data` と `set style function` は、それ以降の
 `plot` や `splot` コマンドに対してデフォルトの描画スタイルを変更
 します。

 描画スタイルは、コマンド `plot` や `splot` の一部分として、明示的にオ
 プション指定することもできます。一つの描画の中で、複数の描画スタイルを
 組み合わせたい場合は、各要素に対して描画スタイルを指定する必要がありま
 す。

 例:

      plot 'data' with boxes, sin(x) with lines

 各描画スタイルは、それ自体がデータファイルからのいくつかのデータの組
 を期待します。例えば、デフォルトでは `lines` スタイルは、y の値だけの
 1 列のデータ (x の値は暗黙に順番に取られる)、または最初が x, 次が y の
 2 つの列を期待しています。ファイルの何列のデータを描画データと解釈させ
 るうまい方法に関する情報については、以下参照: `using`。

?plotting styles boxerrorbars
?style boxerrorbars
?boxerrorbars
 描画スタイル `boxerrorbars` は 2 次元のデータ描画でのみ利用可能です。
 これは、3 列、または 4 列、または 5 列のデータが必要です。入力列を追加
 (4,5,6 列目) すると、それらは各データ点毎の variable color 情報 (以下
 参照: `linecolor`, `rgbcolor variable`) として使われます。誤差線は、箱
 の境界と同じ色で描画されます。

      3 列:  x  y  ydelta
      4 列:  x  y  ydelta xdelta        # 箱の幅 != -2
      4 列:  x  y  ylow  yhigh          # 箱の幅 == -2
      5 列:  x  y  ylow  yhigh  xdelta

 y の誤差が "ydelta" の形式で与えられて、箱の横幅があらかじめ -2.0 に設
 定されて (`set boxwidth -2.0`) いなければ、箱の横幅は 4 列目の値で与え
 られます。y の誤差が "ylow yhigh" の形式で与えられる場合は箱の横幅は 5
 列目の値で与えられます。特別な場合として、"ylow yhigh" の誤差形式の 4
 列のデータに対する `boxwidth = -2.0` という設定があります。この場合箱
 の横幅は、隣接する箱にくっつくように自動的に計算されます。3 列のデータ
 の場合も、横幅は自動的に計算されます。

 箱の高さは、`yerrorbars` スタイル同様に y の誤差の値から決定されます。
 y-ydelta から y+ydelta まで、あるいは ylow から yhigh まで、これらは何
 列のデータが与えられているかによって決まります。
?plotting styles boxes
?style boxes
?boxes
 `boxes` スタイルは 2 次元描画でのみ利用可能です。これは与えられた x 座
 標を中心とし、x 軸から (グラフの境界から、ではありません) 与えられた y
 座標までの箱を書きます。これは基本的に、2 列、または 3 列のデータを使
 用します。余分な入力列は、variable 行や塗り潰し色の情報が提供されたも
 のとして使用されます (以下参照: `rgbcolor variable`)。

      2 列:  x  y
      3 列:  x  y  x_width

 箱の幅は 3 つのうち一つの方法で決定されます。入力データが 3 列目のデー
 タを持っている場合は、それが箱の幅にセットされます。そうでなくて
 `set boxwidth` コマンドで箱の幅がセットされていた場合は、それが使われ
 ます。そのどちらでもない場合、箱の幅は、隣接する箱がくっつくように自動
 的に計算されます。

 箱の中身は現在の塗りつぶしスタイル (fillstyle) に従って塗りつぶされま
 す。詳細は、以下参照: `set style fill`。新しい塗りつぶしスタイルを
 plot コマンド上で指定することもできます。
 塗りつぶしスタイルが `empty` の場合は、箱は塗りつぶされません。
 塗りつぶしスタイルが `solid` の場合は、箱は現在の描画色でベタ塗りされ
 ますが、fillstyle パラメータを追加することで塗りつぶし密度を制御できま
 す。0 は背景色、1 は描画色そのものになります。
 塗りつぶしスタイルが `pattern` の場合は、箱は現在の描画色で、あるパタ
 ーンで塗りつぶします。

 例:

 データファイルを塗りつぶした箱で描画し、箱同士を少し垂直方向にスペース
 を空ける (棒グラフ):

       set boxwidth 0.9 relative
       set style fill solid 1.0
       plot 'file.dat' with boxes

 パターンでの塗りつぶしスタイルの箱で sin と cos のグラフを描画:

       set style fill pattern
       plot sin(x) with boxes, cos(x) with boxes

 sin はパターン 0 で、cos はパターン 1 で描画されます。追加される描画は
 出力ドライバがサポートするパターンを循環的に使用します。

 それぞれのデータ集合で明示的に塗りつぶしスタイルを指定:

      plot 'file1' with boxes fs solid 0.25, \
           'file2' with boxes fs solid 0.50, \
           'file3' with boxes fs solid 0.75, \
           'file4' with boxes fill pattern 1, \
           'file5' with boxes fill empty

?plotting styles boxplot
?style boxplot
?boxplot
 boxplot は、値の統計的な分布を表現する一般的な方法です。四分位境界は、
 1/4 の点が第一四分位境界以下の値を持つように、1/2 の点が第二四分位境界
 (メジアン) 以下の値を持つように、等と決定されます。第一四分位と第三四
 分位の間の領域を囲むように箱を描画し、メジアン値のところには水平線を描
 きます。箱ひげは、箱からユーザ指定限界まで延長されます。それらの限界の
 外にある点は、ひとつひとつ描画されます。

 例:

     # x 座標は 1.0、y は 5 列目の値のところに boxplot を配置
     plot 'data' using (1.0):5

     # 上と同じだが、範囲外の点は隠し、boxplot の幅を 0.3 にする
     set style boxplot nooutliers
     plot 'data' using (1.0):5:(0.3)

 デフォルトでは、using 指定による 2 列目の y のすべての値に対する
 boxplot を 1 つだけ生成します。しかし、追加の (4 つ目の) 列を指定する
 と、その列の値をある因子変数の離散的なレベル値であると見なし、その離散
 値のレベルの値の数だけの boxplot を描画します。それらの boxplot の間隔
 はデフォルトでは 1.0 ですが、これは `set style boxplot separation` で
 変更できます。デフォルトでは、因子変数の値は、各 boxplot の下 (または
 上) の目盛りのラベルに表示します。

 例

     # 'data' の 2 列目は "control" か "treatment" のいずれかの文字列で
     # 以下の例は、その因子毎の 2 つの boxplot を生成する
     plot 'data' using (1.0):5:(0):2

 その箱のデフォルトの幅は `set boxwidth <width>` で設定できますが、plot
 コマンドの `using` による 3 番目のオプション列でも指定できます。1 番目
 と 3 番目の列 (x 座標と幅) は通常データ列ではなく定数として与えます。

 デフォルトでは、箱ひげは箱の端から、y の値が四分位範囲の 1.5 倍の中に
 収まっていて最も離れているような点まで延長されます。デフォルトでは、範
 囲外の点 (outlier) は円 (pointtype 7) で描かれます。箱ひげの端の棒の幅
 は `set bars` または `set errorbars` を使って制御できます。

 これらのデフォルトの性質は `set style boxplot` コマンドで変更できます。
 以下参照: `set style boxplot`, `boxwidth`, `errorbars`, `fillstyle`,
 `candlesticks`。

?plotting styles boxxyerror
?style boxxyerror
?boxxyerror
 `boxxyerror` 描画スタイルは 2 次元のデータ描画でのみ利用可能です。これ
 は、`xyerrorbars` スタイルが線分の交差で表現するところを長方形で表現す
 ることを除けば、ほぼ同じです。これは、入力データの 4 列、または 6 列を
 使用します。余分な入力列は、variable 行や塗り潰し色の情報が提供された
 ものとして使用されます (以下参照: `rgbcolor variable`)。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  xlow  xhigh  ylow  yhigh

 箱の幅と高さは `xyerrorbars` スタイル同様 x, y の誤差から決定されます
 つまり、xlow から xhigh までと ylow から yhigh まで、または x-xdelta
 から x+xdelta までと y-ydelta から y+ydelta まで。これらは何列のデータ
 が与えられているかによって決まります。

 6 列の形式のコマンドは、任意の x, y の幅の長方形を書く簡単な方法を提供
 します。

 入力列を追加 (5,7 列目) すると、それらは各データ点毎の variable color
 情報 (以下参照: `linecolor`, `rgbcolor variable`) であるとして使われま
 す。

 箱の内部は現在の塗りつぶしスタイル (fillstyle) に従って塗られます。詳
 細は、以下参照: `set style fill`, `boxes`。plot コマンド上で新しい塗り
 つぶしスタイルを指定することもできます。
?plotting styles candlesticks
?style candlesticks
?candlesticks
 `candlesticks` スタイルは、金融データの 2 次元のデータ描画、および統計
 データのひげ付きの棒グラフを生成するのに使えます。
 記号は、水平方向には x を中心とし、垂直方向には開始値 (open) と終値
 (close) を境界とする長方形が使われます。そして、その x 座標のところに
 長方形のてっぺんから最高値 (high) までと、長方形の底から最安値 (low)
 までの垂直線が引かれますが、この垂直線は最高値と最安値が入れ替わっても
 変更されません。

 基本的に 5 列のデータが必要です:

       金融データ:   date  open  low  high  close
       箱ひげ描画:   x  box_min  whisker_min  whisker_high  box_high

 長方形の幅はコマンド `set boxwidth` で制御できますが、以前の gnuplot
 への後方互換性として、boxwidth パラメータが設定されていない場合は
 `set errorbars <width>` で制御されるようになっています。

 これの代わりに、箱ひげ (box-and-whisker) のグループ化に関する明示的な
 幅の指定を、追加の 6 番目のデータで指定できます。その幅は、x 座標と同
 じ単位で与えなければいけません。

 入力列を追加 (6 列目、または 6 列目がデータの幅として使れる場合は 7 列
 目) すると、それらは各データ点毎の variable color 情報 (以下参照:
 `linecolor`, `rgbcolor variable`) として使われます。

 デフォルトでは、鉛直線分のてっぺんと底には垂直に交わる水平線は引かれま
 せん。それを引きたい場合、例えば典型的な例は箱ひげ図 (box-and-whisker
 plot) での使用ですが、描画コマンドにキーワード `whiskerbars` を追加し
 てください。デフォルトでは、水平線は箱 (candlestick) の水平幅一杯に引
 かれますが、それは全体の幅に対する割合を指定することで変更できます。

 金融データの通常の慣習では、(開始値) < (終値) の場合は長方形は空で、
 (終値) < (開始値) の場合は塗り潰されます。現在の fillstyle に "empty"
 をセットしている場合は、実際にこうなります。以下参照: `fillstyle`。
 fillstyle に塗り潰し、またはパターンをセットしている場合は、開始値、終
 値に関係なく、すべての箱にそれが使われます。以下参照: `set errorbars`,
 `financebars`。また、以下も参照してください。
 candlestick
 と
 finance
 のデモ。

 注意: 中央値を表すための記号などを追加したい場合、以下の例のように、ひ
 げ付きの棒グラフに他の描画コマンドを追加する必要があります:

   # データ列:  X '最小値' '1/4 位の値' '中央値' '3/4 位の値' '最大値'
   set errorbars 4.0
   set style fill empty
   plot 'stat.dat' using 1:3:2:6:5 with candlesticks title 'Quartiles', \
        ''         using 1:4:4:4:4 with candlesticks lt -1 notitle

   # ひげの上に水平線を伴う描画で、水平線の幅を全体幅の 50% にする
   plot 'stat.dat' using 1:3:2:6:5 with candlesticks whiskerbars 0.5

 以下参照: `set boxwidth`, `set errorbars`, `set style fill`, `boxplot`。
?plotting styles circles
?style circles
?circles
 スタイル `circles` は、各データ点に明示された半径の円を描画します。3
 列のデータを与えた場合は、それを x, y, 半径と解釈します。半径は、常に
 描画の水平軸 (x または x2) の単位で解釈されます。y 方向の縮尺と描画の
 アスペクト比は、いずれも無視されます。2 列のデータしか与えないと、半径
 は `set style circle` から取ります。この場合、半径は graph か screen
 の座標系で与えることができます。

 デフォルトでは完全な円を描画しますが、4 列目、5 列目に開始角、終了角を
 指定することで扇形を描画することもできます。4 列目、あるいは 6 列目の
 データを追加して部分円の色を指定することもできます。扇形の開始角、終了
 角の単位は度で指定する必要があります。以下参照: `set style circle`,
 `set style fill`。

 例:

     # 面積が 3 列目の値に比例するような円を描画
     set style fill transparent solid 0.2 noborder
     plot 'data' using 1:2:(sqrt($3)) with circles, \
          'data' using 1:2 with linespoints

     # 円の代わりにパックマンを描画
     plot 'data' using 1:2:(10):(40):(320) with circles

     # インランデータで円グラフを描画
     set xrange [-15:15]
     set style fill transparent solid 0.9 noborder
     plot '-' using 1:2:3:4:5:6 with circles lc var
     0    0    5    0    30    1
     0    0    5   30    70    2
     0    0    5   70   120    3
     0    0    5  120   230    4
     0    0    5  230   360    5
     e

 これは、pointstyle 7 で点のサイズを variable とした `points` による描
 画と似ていますが、circles は x 軸の範囲で伸縮される点が異なります。以
 下も参照: `set object circle`, `fillstyle`。
?plotting styles ellipses
?style ellipses
?ellipses
 スタイル `ellipses` は、各データ点に楕円 (ellipse) を描画します。この
 スタイルは、2 次元描画にのみ適用されます。各楕円は、中心、主軸直径、副
 軸直径、x 軸と主軸のなす角、で表現されます。

      2 列: x y
      3 列: x y major_diam
      4 列: x y major_diam minor_diam
      5 列: x y major_diam minor_diam angle

 2 列のデータのみが与えられた場合は、それらは中心の座標とみなされ、楕円
 はデフォルトの大きさで描画されます (以下参照: `set style ellipse`)。楕
 円の向きは、主軸と x 軸のなす角で定義されますが、それもデフォルトの
 ellipse のスタイルから取られます (以下参照: `set style ellipse`)。
 3 列のデータが与えられた場合は、3 列目は主、副両軸の直径 (幅) として使
 われます。向きはデフォルトで 0 になります。
 4 列のデータが与えられた場合は、それらは中心の座標、主軸直径 (幅)、副
 軸直径として使わわれます。これらは直径であり、半径でないことに注意して
 ください。
 5 列のデータが与えられた場合は、5 列目の値は度単位の向きの角度の指定と
 して使われます。
 楕円は、3,4,5 列の値は負の値として指定することで、それらのデフォルトの
 値を利用して楕円を書かせることもできます。

 上のすべての場合で、variable color データを最後の列 (3,4,5,6 列目) と
 して追加できます。詳細は以下参照: `colorspec`。

 デフォルトでは、主軸直径は水平軸 (x または x2) の単位、副軸直径は垂直
 軸 (y または y2) の単位であるとみなされます。これは、x 軸と y 軸の縮尺
 が異なる場合、主軸と副軸の比は回転後には正しくはならない、ということを
 意味しています。しかしこの挙動は、キーワード `units` で変更できます。

 これに関しては、3 種類の代用品があります:
 `units xy` が描画指定に含まれている場合、その軸は上に述べたように縮尺
 されます。`units xx` とすると、直径は両軸とも x 軸の単位で計算され、
 `units yy` は両軸とも y 軸の単位で計算されます。後の 2 つは、描画のサ
 イズを変更しても、楕円は正しいアスペクト比を持ちます。

 `units` を省略した場合は、デフォルトの設定が使用され、`units xy` とな
 りますが、これは、`set style ellipse` で再定義可能です。

 例 (楕円を有効な線種を周期的に使用して描画):

     plot 'data' using 1:2:3:4:(0):0 with ellipses

 以下も参照: `set object ellipse`, `set style ellipse`, `fillstyle`。
?plotting styles dots
?style dots
?dots
 `dots` スタイルは各点に小さなドットを描画します。これはたくさんの点か
 らなる散布図の描画に便利でしょう。2 次元描画では 1 列、または 2 列の入
 力データが、3 次元描画では 3 列のデータが必要です。

 出力形式によっては (post, pdf など)、ドットの大きさは linewidth を変更
 することで制御できることもあります。

      1 列:  y         # x は行番号
      2 列:  x  y
      3 列:  x  y  z   # 3D のみ (splot)

?plotting styles filledcurves
?style filledcurves
?filledcurves
 スタイル `filledcurves` は 2 次元描画でのみ利用します。これは 3 種類の
 異なる指定が可能です。最初の 2 種類は 1 つの関数描画、あるいは (x,y) 2
 列の入力データ用のもので、後で紹介するようにオプションで更なる指定がで
 きます。

 書式:

     plot ... with filledcurves [option]

 ここで、オプションは以下のうちのいずれかです:

     [closed | {above | below}
     {x1 | x2 | y | r}[=<a>] | xy=<x>,<y>]

 最初のものは `closed` で、これは曲線それ自身を閉多角形と見なします。入
 力データが 2 列の場合にはこれがデフォルトです。

 2 種類目は指定された軸、あるいは水平線、垂直線、与えられた点などと、曲
 線との間に作られる領域を塗りつぶします。

     filledcurves closed   ... 丁度閉曲線で囲まれる領域
     filledcurves x1       ... x1 軸
     filledcurves x2       ... x2 軸 (y1, y2 軸も同様)
     filledcurves y=42     ... 直線 y=42, すなわち x 軸と平行
     filledcurves xy=10,20 ... x1,y1 軸での点 10,20 (扇型のような形状)
     filledcurves above r=1.5  極座標での動径軸の 1.5 の外側の領域

 3 種類目は、x 座標の集合が同じである 2 つの曲線の間の領域を塗り潰しま
 す。これは、(x, y1, y2) の 3 列の入力データが必要です。入力データが 3
 列以上の場合にはこれがデフォルトです。2 列目が y の値で、3 列目がその
 誤差データである場合は、不確定領域を陰影で表現することができます。
 これに似た 3 次元描画スタイル `zerrorfill` も参照してください。

      3 列:  x  y  yerror

     plot $DAT using 1:($2-$3):($2+$3) with filledcurves, \
          $DAT using 1:2 smooth mcs with lines

 `above` と `below` オプションは
     ... filledcurves above {x1|x2|y|r}=<val>
 および
     ... using 1:2:3 with filledcurves below
 の形のコマンドに適用可能です。どちらの場合でも、これらのオプションは
 塗りつぶし領域を、境界線、または境界曲線の片側に制限します。

 注意: この描画モードは全ての出力形式でサポートされるとは限りません。
       3 列のデータ描画では、x= と y= のキーワードは無視します。

 データファイルから描かれた曲線の塗りつぶしを拡大すると、何もなくなった
 り正しくない領域になることがありますが、それは gnuplot が、領域ではな
 く点や線をクリッピングしているからです。

 <x>, <y>, <a> が描画領域の外にある場合、それらはグラフの境界へ移動され
 ます。よって、オプション xy=<x>,<y> を指定した場合の実際の塗りつぶし領
 域は、xrange や yrange に依存します。
?filledcurves border
 `with filledcurves` での描画は、fillstyle (solid/transparent/pattern)
 や fillcolor を指定することでさらにカスタマイズできます。plot コマンド
 で fillstyle (`fs`) を指定しなければ、現在のデフォルトの fill スタイル
 を使用します。以下参照: `set style fill`。plot コマンドで fillcolor
 (`fc`) を指定しなければ、通常の線種 (linetype) の色列に従います。

 fillstyle の属性の {{no}border} は、filledcurves のモードがデフォルト
 の `closed` である場合に受け付けます。
 例:
      plot 'data' with filledcurves fc "cyan" fs solid 0.5 border lc "blue"
?plotting styles financebars
?style financebars
?financebars
 `financebars` スタイルは金融データの 2 次元のデータ描画でのみ利用可能
 です。これは、x 座標 1 つ (通常日付) と、4 つの y 座標 (金額) を必要と
 します。

      5 列:   date  open  low  high  close

 入力列を追加 (6 列目) すると、それらは各行毎の variable color 情報 (以
 下参照: `linecolor`, `rgbcolor variable`) として使われます。

 記号は、水平方向にはその x 座標に置かれ、垂直方向には最高値 (high) と
 最安値 (low) を端とする線分が使われます。そして、その線分に水平左側の
 刻みが開始値 (open) の所に、水平右側の刻みが終り値 (close) の所につき
 ます。その刻みの長さは `set errorbars` で変更できます。記号は最高値と
 最安値が入れ替わっても変わりません。以下参照: `set errorbars`,
 `candlesticks`。以下も参照してください。
 金融データデモ。
?plotting styles fsteps
?style fsteps
?fsteps
 `fsteps` スタイルは 2 次元描画でのみ利用可能です。これは 2 本の線分で
 隣り合う点をつなぎます: 1 本目は (x1,y1) から (x1,y2) まで、2 本目は
 (x1,y2) から (x2,y2) まで。入力列の条件は、`lines` や `points` に対す
 るものと同じです。`fsteps` と `steps` の違いは、`fsteps` は、折れ線を
 先に y 方向に書いてから次に x 方向に書くのに対し、`steps` は先に x 方
 向に書いてから次に y 方向に書きます。

 以下も参照
 steps デモ。
?style fillsteps
?fillsteps
 `fillsteps` スタイルは、`steps` とほぼ同じですが、曲線と y=0 との間の
 領域を現在の fillstyle で塗り潰します。以下参照: `steps`。
?plotting styles histeps
?style histeps
?histeps
 `histeps` スタイルは 2 次元描画でのみ利用可能です。これはヒストグラム
 の描画での利用を意図しています。y の値は、x の値を中心に置くと考え、
 x1 での点は ((x0+x1)/2,y1) から ((x1+x2)/2,y1) までの水平線として表現
 されます。端の点では、その線はその x 座標が中心になるように延長されま
 す。隣り合う点同士の水平線の端は、その両者の平均値のところでの鉛直線、
 すなわち ((x1+x2)/2,y1) から ((x1+x2)/2,y2) の線分で結ばれます。
 入力列の条件は、`lines` や `points` に対するものと同じです。

 `autoscale` が有効である場合、x の範囲は、その延長された水平線の範囲で
 はなく、データ点の範囲が選択されます。よって、端の点に関してはその水平
 線は半分しか描かれないことになります。
 以下も参照
 steps デモ。

?style histograms
?set style histogram
?plotting styles histograms
?histograms
 スタイル `histograms` は 2 次元描画でのみ有効です。これは、データの各
 列の並びから平行な棒グラフを作ります。`plot` コマンドの各要素は、それ
 に関する目盛りの値や凡例 (key) のタイトルが付属するかも知れませんが、
 単一の入力データを指定する必要があります (例えば入力ファイルの 1 つの
 列)。現在は、4 種類のヒストグラム形式のスタイルをサポートしています。

       set style histogram clustered {gap <gapsize>}
       set style histogram errorbars {gap <gapsize>} {<linewidth>}
       set style histogram rowstacked
       set style histogram columnstacked
       set style histogram {title font "name,size" tc <colorspec>}

 デフォルトのスタイルは `set style histogram clustered gap 2` に対応し
 ています。このスタイルでは、並列に指定されたデータの値の集合は、選択さ
 れたデータ列のそのそれぞれの序列 (行番号) に対応する x 座標の場所に、
 各々箱のグループとして固められて置かれます。よって、<n> 個のデータ列を
 並列に指定した場合、最初の固まりは x=1 を中心とする <n> 個の箱の固まり
 からなり、その各々の高さは、その <n> データ列各々の最初 (1 行目) の値
 が取られます。その後に少し空白 (gap) が空けられ、次に各データ列の次 (2
 行目) の値に対応する箱の固まりが x=2 を中心として置かれます。以下同様
 です。デフォルトの空白 (gap) 幅の 2 は、箱の固まり同士の間の空白が、箱
 2 つの幅に等しいことを意味します。同じ列に対する箱は全て同じ色または同
 じパターンで与えられます (以下参照: `set style fill`)。

 箱の固まりそれぞれは、データファイルの 1 つの行から得られます。そのよ
 うな入力ファイルの各行の最初の項目が見出し (ラベル) でることは良くある
 ことです。その列にある見出し (ラベル) は、`using` に `xticlabels` オプ
 ションをつけることで、それに対応する箱の固まりの真下の x 軸に沿ったと
 ころに置くことができます。

 `errorbars` スタイル は、各エントリに対して追加の入力列を必要とする以
 外は `clustered` スタイルにとても良く似ています。最初の列は、
 `clustered` スタイルの場合と全く同様に箱の高さ (y の値) として保持され
 ます。
      2 列:       y yerr          # 線は y-yerr から y+err へ伸びる
      3 列:       y ymin ymax     # 線は ymin から ymax へ伸びる
 誤差線の見た目は、現在の `set errorbars` の値と <linewidth> オプション
 指定で制御できます。

 積み上げ型のヒストグラムも 2 つの形式がサポートされています。それらは
 コマンド `set style histogram {rowstacked|columnstacked}` で選択できま
 す。これらのスタイルにおいて、選択された列のデータの値は積み上げられた
 箱として集められます。正の値は、y=0 から上の方へ積み上げられ、負の値は
 下へ向かって積み上げられます。正の値と負の値が混じってい場合は、上向き
 と下向きの両方の積み上げが生成されます。デフォルトの積み上げモードは
 `rowstacked` です。

 スタイル `rowstacked` は、まず最初に選択された列の各行の値を x 軸のそ
 れぞれの位置に配置します: 1 行目の値は x=1 の箱、2 行目のは x=2、以下
 同様となります。2 番目以降に選択された列に対応する箱は、それらの上に積
 み重ねられて行きます。そして結果として、x=1 にできる箱の積み重ねは、各
 列の最初の値 (1 行目の値) からなり、x=2 の箱の積み重ねは各列の 2 行目
 の値、などのようになります。同じ列に対する箱は全て同じ色または同じパタ
 ーンで与えられます (以下参照: `set style fill`)。

 スタイル `columnstacked` も同様ですが、こちらは各箱の積み上げは (各行
 のデータからではなく) 各列のデータからなります。最初に指定された列の各
 行のデータが x=1 の箱の積み上げを生成し、2 番目に指定した列の各行のデ
 ータが x=2 の箱の積み上げ、などのようになります。このスタイルでは、各
 箱の色は、各データ項目の (列番号ではなく) 行番号から決定されます。

 箱の幅はコマンド `set boxwidth` で変更できます。
 箱の塗りつぶしスタイルはコマンド `set style fill` で設定できます。

 histograms は x 軸は常に x1 軸を使いますが、y 軸に関しては y1 軸か y2
 軸かを選択できます。plot 命令が、histograms と他のスタイルの描画の両方
 を含む場合、histogram でない方は、x1 軸を使うか x2 軸を使うかを選択で
 きます。

 例:
 入力ファイルは、2, 4, 6, ... の列にデータ値を持ち、3, 5, 7, ...  の列
 に誤差評価を持つとします。以下の例は、2 列目、4 列目の値を箱の固まり型
 (clustered; デフォルトスタイル) のヒストグラムとして描画します。ここで
 は、plot コマンドで繰り返し (iteration) を使用していますので、任意の個
 数のデータ列を一つのコマンドで処理できます。以下参照: `plot for`。

       set boxwidth 0.9 relative
       set style data histograms
       set style histogram cluster
       set style fill solid 1.0 border lt -1
       plot for [COL=2:4:2] 'file.dat' using COL

 これは、x 軸上の各整数値を中心とするそれぞれ 2 つの箱 (鉛直な棒) 毎の
 固まりによる描画を生成します。入力ファイルの最初の列にラベルが含まれて
 いるならそれを、以下の少し変更したコマンドで x 軸に沿って配置できます。

       plot for [COL=2:4:2] 'file.dat' using COL:xticlabels(1)

 ファイルが、各データの測定値と範囲の情報の両方を含んでいる場合、描画に
 誤差線を追加することができます。以下のコマンドは誤差線を (y-<error>)
 から (y+<error>) に引き、その頭に箱と同じ幅の水平線をつけます。誤差線
 と誤差線の端の線は、黒で線幅 2 で描画されます。

       set errorbars fullwidth
       set style fill solid 1 border lt -1
       set style histogram errorbars gap 2 lw 2
       plot for [COL=2:4:2] 'file.dat' using COL:COL+1

 以下は、同じデータを行毎の積み上げ型 (rowstacked) のヒストグラムで描画
 する方法を示しています。これまでとは違い、以下の例では繰り返しを使うの
 でなく、明示的に別々の列を指定します。

       set style histogram rowstacked
       plot 'file.dat' using 2, '' using 4:xtic(1)

 これは、一つ一つの鉛直な棒が、データの一つの列に対応する描画を生成しま
 す。各棒は、2 つの部分の積み上げの形であり、それぞれの部分の高さが、デ
 ータファイルの 2 列目と 4 列目の値に対応します。
 最後に以下のコマンド

       set style histogram columnstacked
       plot 'file.dat' using 2, '' using 4

 は、一つ一つがそれぞれデータ列に対応する、2 つの鉛直な積み重ねの棒を生
 成します。x=1 にある棒は、データファイルの 2 列目の各行の値に対応する
 箱からなります。x=2 にある棒は、データファイルの 4 列目の各行の値に対
 応する箱からなります。

 これは、gnuplot の通常の入力の縦、横の解釈を入れ換えることになりますの
 で、凡例のタイトルや x 軸の目盛りの見出しの指定も変更する必要がありま
 す。以下のコメント部分を参照してください。

       set style histogram columnstacked
       plot '' u 5:key(1)            # 1 列目を凡例タイトルに使用
       plot '' u 5 title columnhead  #

 この 2 つの例は、全く同じデータ値を与えているのですが、異なる書式であ
 ることに注意してください。
?newhistogram
?histograms newhistogram
?plotting style histograms newhistogram
 書式:

      newhistogram {"<title>" {font "name,size"} {tc <colorspec>}}
                   {lt <linetype>} {fs <fillstyle>} {at <x-coord>}

 一回の描画に 2 つ以上のヒストグラムの組を作ることもできます。この場合
 コマンド `newhistogram` を使うことで、それらを強制的に分離し、またそれ
 ぞれのラベルを分離することができます。
 例:

       set style histogram  cluster
       plot newhistogram "Set A", 'a' using 1, '' using 2, '' using 3, \
            newhistogram "Set B", 'b' using 1, '' using 2, '' using 3

 ラベル "Set A" と "Set B" は、それぞれのヒストグラムの組の下、x 軸の全
 てのラベルの下の位置に現われます。

 コマンド newhistogram は、ヒストグラムの色付けを強制的に指定した色
 (linetype) で始めるのにも使えます。デフォルトでは、色の番号はヒストグ
 ラムの境界をまたいでさえも連続的に増加し続けます。次の例は、複数のヒス
 トグラムに同じ色付けを施します。
       plot newhistogram "Set A" lt 4, 'a' using 1, '' using 2, '' using 3, \
            newhistogram "Set B" lt 4, 'b' using 1, '' using 2, '' using 3

 同様に、次のヒストグラムを指定した fillstyle で始めさせることが可能で
 す。その fillstyle を `pattern` にセットした場合、塗り潰しに使用される
 パターン番号は自動的に増加されていきます。

 オプション `at <x-coord>` は、その後のヒストグラムの x 座標の位置を
 <x-coord> に設定します。例:

        set style histogram cluster
        set style data histogram
        set style fill solid 1.0 border -1
        set xtic 1 offset character 0,0.3
        plot newhistogram "Set A", \
             'file.dat' u 1 t 1, '' u 2 t 2, \
             newhistogram "Set B" at 8, \
             'file.dat' u 2 t 2, '' u 2 t 2

 この場合、2 つ目のヒストグラムの位置は x=8 から始まります。
?automated
?histograms automated
?styles histograms automated
?plotting styles histograms automated
 一つのデータファイルのたくさんの列から、一つのヒストグラムを生成したい
 場合、plot の繰り返し (iteration) 機能を使うと便利でしょう。以下参照:
 `plot for`。例えば、3 列目から 8 列目までのデータを積み上げた形のヒス
 トグラムを生成する例:

       set style histogram columnstacked
       plot for [i=3:8] "datafile" using i title columnhead
?plotting styles image
?style image
?image
?rgbimage
?rgbalpha
 描画スタイル `image`, `rgbimage`, `rgbalpha` は、いずれも一様に標本点
 を取った格子状データ値を、2 次元、または 3 次元中のある平面上に射影し
 ます。入力データは、既にあるビッマップ画像ファイル (PNG のような標準的
 なフォーマットから変換したものでよい) か、単純な数値配列です。

 この図は、スカラー値の配列から温度分布を生成した例です (訳注: 図が表示
 されている場合)。現在のパレットを、各スカラー値から対応するピクセルの
 色への割り当てに使用します。
       plot '-' matrix with image
       5 4 3 1 0
       2 2 0 0 1
       0 0 0 1 0
       0 1 2 4 3
       e
       e

 入力 2 次元画像の各ピクセル (データ点) は、描画グラフ中では長方形、ま
 たは平行六面体となります。画像の各データ点の座標は、平行六面体の中心を
 決定します。すなわち、M x N 個のデータ集合は M x N ピクセルの画像を生
 成します。これは、M x N 個のデータ集合が (M-1) x (N-1) 要素を作成する
 pm3d の構造とは異なります。バイナリ画像データの格子の走査方向は、追加
 キーワードでさらに制御可能です。以下参照: `binary keywords flipx`,
 `keywords center`, `keywords rotate`。

 各ピクセルの x と y の大きさを示すことで、画像データを 2 次元描画座標
 系内の特定の長方形に収まるように伸縮することができます。以下参照:
 `binary keywords dx`, `dy`。右の画像を生成するのには、同じ入力画像を、
 それぞれ dx, dy, origin を指定して複数回配置しました。入力 PNG 画像で
 あるビルの絵は 50x128 ピクセルです。高いビルは、`dx=0.5 dy=1.5` で割り
 当てて描画し、低いビルは、`dx=0.5 dy=0.35` としています (訳注: 図が表
 示されている場合)。

 スタイル `image` は、グレイスケール (灰色階調)、またはカラーパレット値
 を含んでいるピクセルの入力を処理します。よって 2 次元描画 (`plot` コマ
 ンド) では 3 列のデータ (x,y,value) を、3 次元描画 (`splot` コマンド)
 では 4 列のデータ (x,y,z,value) が必要になります。

 スタイル `rgbimage` は、赤、緑、青の 3 つの色成分 (RGB) で記述されたピ
 クセルの入力を処理します。よって `plot` では 5 次元データ (x,y,r,g,b)
 が、`splot` では 6 次元データ (x,y,z,r,g,b) が必要になります。赤、緑、
 青の各成分は [0:255] の範囲内にあると仮定されます。
 これは、PNG や JPEG ファイルで使用されている仕組みに合っています (以下
 参照: `binary filetype`)。しかし、RGB 成分として [0:1] の範囲の実数値
 を取る仕組みを使用するようなデータファイルも中にはあります。そのような
 データで `rgbimage` スタイルを使用するには、色成分を [0:255] の範囲に
 スケール変換しなければいけません。

 スタイル `rgbalpha` は、赤、緑、青の RGB 成分に加えて、アルファ値 (透
 過パラメータ) の情報も含んだピクセルの入力を処理します。よって、`plot`
 では 6 次元データ (x,y,r,g,b,a) が、`splot` では 7 次元データ
 (x,y,z,r,g,b,a) が必要になります。赤、緑、青、およびアルファの各成分は
 [0:255] の範囲内にあると仮定されます。RGBA 成分が [0:1] の範囲の実数値
 であるデータを描画するには、色成分を [0:255] の範囲内にスケール変換し
 なければいけません。
?image transparency
?transparency
?alpha channel
 描画スタイル `rgbalpha` は、入力データの各ピクセルが [0:255] の範囲内
 のアルファ値を持っている必要があります。alpha = 0 のピクセルは完全な透
 明で、その下 (奥) の描画要素を全く変えません。alpha = 255 のピクセルは
 完全な不透明です。すべての出力形式は、これら 2 つの両極端な値をサポー
 トします。0 < alpha < 255 のピクセルは半透明で、半透明をサポートしてい
 ない出力形式では、その値を 0 か 255 のいずれかに丸めます。
?plotting styles image pixels
?style image pixels
?image pixels
?pixels
?plotting styles image failsafe
?style image failsafe
?image failsafe
?failsafe
 出力形式によっては、2 次元の長方形領域内での画像データ描画の、デバイス
 やライブラリに依存した最適化ルーチンを使用しています。これは、例えばク
 リッピングや伸縮がうまくなかったり、縁が欠けるなど、望ましくない出力を
 生成することがあります。キーワード `pixels` は、そのようなルーチンの代
 わりに、画像を 1 ピクセルずつ描画するような一般的なコードを使用するよ
 う gnuplot に指示します。この描画モードでは、描画は遅く、とても大きな
 出力ファイルを生成しますが、どの出力形式でも共通的な見た目を作成してく
 れるでしょう (オプション `pixels` は、以前の gnuplot では `failsafe`
 と呼ばれていました)。
 例:
       plot 'data' with image pixels
?plotting styles impulses
?style impulses
?impulses
 `impulses` スタイルは、2 次元描画では y=0 から各点の y の値への、3 次
 元描画では z=0 から各点の z の値への、垂直な線分を表示します。y や z
 の値は負の値でもよいことに注意してください。データの追加列を各垂直線分
 の色の制御に利用できます。このスタイルを 3 次元描画で使用する場合、太
 い線 (linewidth > 1) を利用するとより効果的でしょう。それは 3 次元の棒
 グラフに似たものになります。

      1 列:  y
      2 列:  x  y     # [x,0] から [x,y] への線 (2D)
      3 列:  x  y  z  # [x,y,0] から [x,y,z] への線 (3D)

?plotting styles labels
?style labels
?labels
 スタイル `labels` は、データファイルから座標と文字列を読み込み、その文
 字列をその 2 次元、または 3 次元座標に置きます。これは基本的に 3 列、
 または 4 列の入力を必要とします。さらに余分な入力列は、文字列の回転角
 (キーワード `rotate variable`) や文字色 (以下参照: `textcolor variable`)
 のような、点毎に変動する属性値が指定されたとみなされます。

      3 列:  x  y  string    # 2 次元版
      4 列:  x  y  z  string # 3 次元版

 フォント、色、回転角やその他の描画テキストの属性は追加オプションとして
 指定可能です (以下参照: `set label`)。次の例は、入力ファイルの 1 列目
 から取った市の名前から作られる文字列を、4, 5 列目から取った地図座標に
 描画します。フォントサイズは、3 列目の値から計算していて、この場合はそ
 れは人口を意味しています。

   CityName(String,Size) = sprintf("{/=%d %s}", Scale(Size), String)
   plot 'cities.dat' using 5:4:(CityName(stringcolumn(1),$3)) with labels

 フォントサイズを、個々の市の名前に対して異なるサイズに合わせなくていい
 ならば、コマンドはもっと簡単です:

   plot 'cities.dat' using 5:4:1 with labels font "Times,8"

 labels に `hypertext` がついている場合、その文字列はマウスがそれに対応
 する点の上に来たときにだけ現われます。以下参照: `hypertext`。この場合
 ハイパーテキストの置き場所として機能する点を作るためにそのラベルの
 `point` 属性を有効にする必要があります:

   plot 'cities.dat' using 5:4:1 with labels hypertext point pt 7

 スタイル `points` であらかじめ定義されている点の記号が適切でない、ある
 いは十分でない場合、その代わりとしてスタイル `labels` を使うこともでき
 ます。例えば、以下は単一文字として選択される組を定義し、3 列目のデータ
 値に対応するその一つをグラフの各点に割り当てる例です (訳注: 以下のサン
 プルの <UTF-8 文字列> の部分には、元々、丸に中点記号や□、＋、トランプ
 記号などの UTF-8 文字列が並んでいますが、この日本語訳とは両立しないた
 め取り除いています):

   set encoding utf8
   symbol(z) = "<UTF-8 文字列>"[int(z):int(z)]
   splot 'file' using 1:2:(symbol($3)) with labels

 以下は、4 列目の値を可変値の回転角とし、5 列目の値を文字色 ("tc") とす
 るラベルの使用例です。可変値の色指定は、常に `using` 指定の最後の列か
 ら取ることに注意してください。

   plot $Data using 1:2:3:4:5 with labels tc variable rotate variable
?plotting styles lines
?style lines
?lines
 `lines` スタイルは隣接する点を真直な線分で結びます。
 これは、2 次元描画でも、3 次元描画でも使用でき、基本的には、1 列か 2
 列か 3 列かの入力データを必要とします。
 余分な入力列は、線の色の変更などの情報が提供されたものとして使用されま
 す (以下参照: `rgbcolor variable`)。

 2 次元 ("using" 指定なし) の場合
      1 列:  y       # 行番号による暗黙の x
      2 列:  x  y
 3 次元 ("using" 指定なし) の場合
      1 列:  z       # x は暗黙の行番号、y は index から
      3 列:  x  y  z

 以下も参照: `linetype`, `linewidth`, `linestyle`。
?plotting styles linespoints
?style linespoints
?style lp
?linespoints
?lp
?pointinterval
?pointnumber
 `linespoints` スタイル (省略形 `lp`) は、隣接する点を真っ直ぐな線分で
 結び、その後で最初に戻って各点に小さな記号を描きます。点記号は、
 `set pointsize` で決まるデフォルトの大きさで描きますが、plot コマンド
 上で点のサイズを指定したり、あるいは入力データの追加列で個別の点サイズ
 を指定することもできます。追加の入力列は、個別の線の色などの情報を提供
 するのにも使われます。以下参照: `lines`, `points`。

 グラフのすべての点に記号の印をつけるか否かを制御する 2 つのキーワード
 `pointinterval` (省略形 `pi`), `pointnumber` (省略形 `pn`) があります。

 `pi N` あるいは `pi -N` は、N 個毎に 1 つだけ記号を置くよう gnuplot に
 指示します。負の値を指定すると、記号の下の線分の部分を消します。その消
 す部分のサイズは `set pointintervalbox` で制御できます。

 `pn N` あるいは `pn -N` は、データ点のうち N 個だけラベル付けするよう
 gnuplot に指示します。点はそのデータ全体に渡って均等な間隔に取ります。
 `pi` 同様、負の値を指定すると、記号の下の線分の部分を消します。

?plotting style parallelaxes
?style parallelaxes
?parallelaxes
 平行座標描画 (parallel axis plot, parallel coordinates plot とも呼ばれ
 る) は、多次元データの相関を視覚化します。各入力列は、別々のスケールの
 縦軸に割り当てられます。入力 1 行から読み込んだそれぞれの列の値は、1
 つ目の軸から 2 つ目の軸へ、2 つ目の軸から 3 つ目の軸へと線分で結ばれま
 す。すなわち平行座標描画中では、入力の各行がそれぞれ独立した折れ線にな
 ります。それらを数種類に分類して色を割り当てることはよく行われますが、
 それは、その分類と軸との間の関係を視覚的に調査することを可能にします。
 デフォルトでは、gnuplot は自動的に個々の軸の範囲、スケールを入力データ
 から決定しますが、通常の `set axis range` コマンドによってそれをカスタ
 マイズすることも可能です。以下参照: `set paxis`。

 平行軸の最大個数は、gnuplot のコンパイル時に固定され、その最大値は、
 `show version long` で表示されます。
?plotting styles points
?style points
?points
?point type
?pointtype
 `points` スタイルは各点に小さな記号を表示します。その記号のデフォルト
 の大きさを変更するにはコマンド `set pointsize` が使えます。デフォルト
 の点種は、線種と同じものになります。以下参照: `linetype`。plot コマン
 ドに `using` 指定がない場合は、入力データ列は仮定された方法で解釈され
 ます。以下参照: `style lines`。

 最初の 8 つの点種は、すべての出力形式で共通ですが、より多くの点種を個
 別にサポートする出力形式もあります。現在の出力形式の設定でどのような点
 種が用意されているかを見るには、コマンド `test` を使用してください。ま
 た、下の例のようにして、任意の印字可能文字を点種番号の代わりに使用する
 こともできます。より長い文字列は、描画スタイル `points` ではなく
 `labels` を使えば出力できます。

      plot sin(x) with points pt "#"

 点種として、任意の UTF-8 文字を使用できます。以下参照: `utf8`。
?variable
?variable pointtype
?variable pointsize
?pointtype variable
?pointsize variable
 plot コマンド上でキーワード `pointtype`, `pointsize`, `linecolor` を使
 う際、番号の代わりにキーワード `variable` を追加することができます。こ
 の場合、各点の対応する属性値を入力データの追加列から取得します。可変
 (variable) pointsize 値は、常に `using` 指定で与えられる最初の追加列か
 ら取り、可変 color 値は、常に最後の追加列から取ります。今のところは、
 スタイル `linespoints` の描画で線と点の色を別々に指定することはできま
 せん。各点に対して 3 つの属性をすべて指定する場合は、入力データ列指定
 の順番は以下のようになります。

      plot DATA using x:y:pointsize:pointtype:color \
           with points lc variable pt variable ps variable

 注意: 「ユーザ定義変数」の方の variable に関する情報については、以下参
 照: `variables`。
?plotting styles steps
?style steps
?steps
 `steps` スタイルは 2 次元描画でのみ利用可能です。これは 2 本の線分で隣
 り合う点をつなぎます: 1 本目は (x1,y1) から (x2,y1) まで、2 本目は
 (x2,y1) から (x2,y2) まで。入力列の条件は、`lines` や `points` に対す
 るものと同じです。`fsteps` と `steps` の違いは、`fsteps` は、折れ線を
 先に y 方向に書いてから次に x 方向に書くのに対し、`steps` は先に x 方
 向に書いてから次に y 方向に書きます。曲線とベースラインである y=0 との
 間の領域を塗り潰すには、`fillsteps` を使用してください。
 以下も参照
 steps デモ。

?plotting styles rgbalpha
?style rgbalpha
 以下参照: `image`。
?plotting styles rgbimage
?style rgbimage
 以下参照: `image`。
?plotting styles vectors
?style vectors
?vectors
 2 次元の `vectors` スタイルは (x,y) から (x+xdelta,y+ydelta) までのベ
 クトルを書きます。3 次元の `vectors` スタイルも同様ですが、データは基
 本的に 6 列必要です。いずれの場合も、入力列を追加 (2D では 5 列目、3D
 では 7 列目) すると、それらは各データ点毎の variable color 情報 (以下
 参照: `linecolor`, `rgbcolor variable`) として使われます。
 各ベクトルの先端には小さな矢先も書かれます。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  z  xdelta  ydelta  zdelta

 キーワード "with vectors" は、その後ろに、インラインの arrow スタイル
 指定や、あらかじめ定義されている arrow スタイルの参照、あるいは列から
 各ベクトルに対する必要な arrow スタイルのインデックスを読むような指定
 を伴うことができます。注意: "arrowstyle variable" を使用する場合、対応
 するベクトルが描画される際にはそれが arrow の属性値すべてを埋めるので
 その plot コマンド内に他の線属性や arrow スタイル指定をこのキーワード
 と混在させることはできません。

      plot ... with vectors filled heads
      plot ... with vectors arrowstyle 3
      plot ... using 1:2:3:4:5 with vectors arrowstyle variable

 例:
       plot 'file.dat' using 1:2:3:4 with vectors head filled lt 2
       splot 'file.dat' using 1:2:3:(1):(1):(1) with vectors filled head lw 2

 vectors スタイルを使っての splot は `set mapping cartesian` のみでサポ
 ートされています。
 `set clip one` と `set clip two` は 2 次元のベクトルの描画に影響を与え
 ます。以下参照: `set clip`, `arrowstyle`。
?plotting styles xerrorbars
?style xerrorbars
?xerrorbars
 `xerrorbars` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xerrorbars` は、水平の誤差指示線 (error bar) が表示される以外は
 `points` と同じです。各点 (x,y) において (xlow,y) から (xhigh,y) まで、
 または (x-xdelta,y) から (x+xdelta,y) までの線分が引かれますが、これら
 はいくつのデータ列が与えられるかによって変わります。誤差指示線の端の刻
 みの印の見た目は、`set errorbars` で制御できます。このスタイルは基本的
 に、3 列か 4 列のデータが必要です:

      3 列:  x  y  xdelta
      4 列:  x  y  xlow  xhigh

 入力列を追加 (4,5 列目) すると、それらは点の variable color 情報として
 使われます。

?plotting styles xyerrorbars
?style xyerrorbars
?xyerrorbars
 `xyerrorbars` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xyerrorbars` は、水平、垂直の誤差指示線 (error bar) も表示される以外
 は `points` と同じです。各点 (x,y) において (x,y-ydelta) から
 (x,y+ydelta) までと (x-xdelta,y) から (x+xdelta,y) まで、または
 (x,ylow) から (x,yhigh) までと (xlow,y) から (xhigh,y) までの線分が引
 かれますが、これらはいくつのデータ列が与えられるかによって変わります。
 誤差指示線の端の刻みの印の見た目は、`set errorbars` で制御できます。こ
 れは 4 列か、6 列のデータが必要です。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  xlow  xhigh  ylow  yhigh

 データが、サポートされていない混合型の形式で与えられた場合、`plot` コ
 マンドの `using` フィルタを使って適切な形に直さないといけません。例え
 ばデータが (x,y,xdelta,ylow,yhigh) という形式である場合、以下のように
 します:

       plot 'data' using 1:2:($1-$3):($1+$3):4:5 with xyerrorbars

 入力列を追加 (5,7 列目) すると、それらは各データ点毎の variable color
 情報として使われます。

?plotting styles yerrorbars
?plotting styles errorbars
?style yerrorbars
?style errorbars
?yerrorbars
 `yerrorbars` (または `errorbars`) スタイルは 2 次元のデータ描画のみで
 利用可能です。`yerrorbars` は、垂直の誤差指示線 (error bar) が表示され
 る以外は `points` に似ています。各点 (x,y) において (x,y-ydelta) から
 (x,y+ydelta) まで、または (x,ylow) から (x,yhigh) までの線分が引かれま
 すが、これらはいくつのデータ列が与えられるかによって変わります。誤差指
 示線の端の刻みの印の見た目は、`set errorbars` で制御できます。

      2 列:  [暗黙の x]  y  ydelta
      3 列:  x  y  ydelta
      4 列:  x  y  ylow  yhigh

 入力列を追加 (4,5 列目) すると、それらは点の variable color 情報として
 使われます。

 以下も参照
 errorbar デモ。
?plotting styles xerrorlines
?style xerrorlines
?xerrorlines
 `xerrorlines` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xerrorlines` は `linespoints` に似ていますが、水平の誤差線が描かれる
 ことが違います。各点 (x,y) で、データ列の個数に応じて (xlow,y) から
 (xhigh,y) まで、または (x-xdelta,y) から (x+xdelta,y) までの線分が描か
 れます。誤差線の端の刻みの印の見た目は、`set errorbars` で制御できます。
 基本的には、3 列か 4 列のデータが必要です:

      3 列:  x  y  xdelta
      4 列:  x  y  xlow  xhigh

 入力列を追加 (4,5 列目) すると、それらは点の variable color 情報として
 使われます。

?plotting styles xyerrorlines
?style xyerrorlines
?xyerrorlines
 `xyerrorlines` スタイルは 2 次元のデータ描画のみで利用可能です。
 `xyerrorlines` は `linespoints` に似ていますが、水平と垂直の誤差線も描
 かれることが違います。各点 (x,y) で、データ列の個数に応じて、
 (x,y-ydelta) から (x,y+ydelta) までと (x-xdelta,y) から (x+xdelta,y)
 まで、あるいは (x,ylow) から (x,yhigh) までと (xlow,y) から (xhigh,y)
 までの線分が描かれます。誤差線の端の刻みの印の見た目は、`set errorbars`
 で制御できます。これは、4 列か 6 列の入力データが必要です。

      4 列:  x  y  xdelta  ydelta
      6 列:  x  y  xlow  xhigh  ylow  yhigh

 データが、サポートされていない混合型の形式で与えられた場合、`plot` コ
 マンドの `using` フィルタを使って適切な形に直さないといけません。例え
 ばデータが (x,y,xdelta,ylow,yhigh) という形式である場合、以下のように
 します:

       plot 'data' using 1:2:($1-$3):($1+$3):4:5 with xyerrorlines

 入力列を追加 (5,7 列目) すると、それらは各データ点毎の variable color
 情報として使われます。

?plotting styles yerrorlines
?plotting styles errorlines
?style yerrorlines
?style errorlines
?yerrorlines
 `yerrorlines` (または `errorlines`) スタイルは 2 次元のデータ描画のみ
 で利用可能です。`yerrorlines` は `linespoints` に似ていますが、垂直の
 誤差線が描かれることが違います。各点 (x,y) で、データ列の個数に応じて
 (x,y-ydelta) から (x,y+ydelta) まで、または (x,ylow) から (x,yhigh)
 までの線分が描かれます。誤差線の端の刻みの印の見た目は、
 `set errorbars` で制御できます。これは、3 列か 4 列の入力が必要です。

      3 列:  x  y  ydelta
      4 列:  x  y  ylow  yhigh

 入力列を追加 (4,5 列目) すると、それらは点の variable color 情報として
 使われます。

 以下も参照。
 エラーバーのデモ
?plotting styles zerrorfill
?style zerrorfill
?zerrorfill
 書式:

      splot DATA using 1:2:3:4[:5] with zerrorfill {fc|fillcolor <colorspec>}
                 {lt|linetype <n>} {<line properties>}

 描画スタイル `zerrorfill` は、2 次元の描画スタイルの一つの変種のような
 ものです。これは、2 つの関数の間、または同じ x に対して 2 つの y 座標
 の点を与えて得られるデータの折れ線の間の領域を塗り潰します。これは、4
 列か 5 列の入力が必要です。

      4 列:  x  y  z  zdelta
      5 列:  x  y  z  zlow  zhigh

 zlow と zhigh の間の領域を塗り潰し、その後 z の値のところに線を描きま
 す。デフォルトでは、その線と塗り潰しには同じ色を使いますが、その色は
 splot コマンド上で変更できます。塗り潰しの設定は、大域的な fill style
 の影響も受けます。以下参照 `set style fill`。

 splot コマンドに複数の曲線を指定した場合は、後に描いた曲線が、前のすべ
 ての曲線を隠してしまう可能性があります。見る人側の手前の曲線のみが隠す
 ように適切な深さ順の並べかえを行うには、`set pm3d depthorder base` を
 使用してください。残念ながら、これは z の値に対応するすべての折れ線を
 描いた後に、すべての領域の塗り潰しを行います。よって、折れ線を見えるよ
 うにして、かつ領域の塗り潰しの深さ順の並べかえを行うには、領域の塗り潰
 しは部分的に透過 (transparent) させるか、ベタ塗り (solid fill) の代わ
 りにパターン塗り (pattern fill) を使用するといいかもしれません。

 以下の最初の 2 つの例の塗り潰し領域は、同じものになります。

      splot 'data' using 1:2:3:4 with zerrorfill fillcolor "grey" lt black
      splot 'data' using 1:2:3:($3-$4):($3+$4) with zerrorfill
      splot '+' using 1:(const):(func1($1)):(func2($1)) with zerrorfill
      splot for [k=1:5] datafile[k] with zerrorfill lt black fc lt (k+1)

 この描画スタイルは、柵グラフ (fence plot) を作成するのに使うこともでき
 ます。以下参照: `fenceplots`。

?3D plots
?plotting styles 3D plots
 3 次元グラフは、コマンド `plot` ではなくコマンド `splot` を使って生成
 します。多くの 2 次元描画スタイル (points, images, impulse, labels,
 vectors) は、z 座標データ列を追加指定すれば 3 次元でも使えます。2 次元
 射影グラフのみが欲しい場合でも、`splot` コマンドを使って生成しなければ
 いけない描画型 (pm3d coloring, surfaces, contours) も中にはあります。
?surface plots
 描画スタイル `splot with lines` や `splot with surface` はいずれも曲面
 を格子線で生成します。曲面の塗り潰しは、スタイル `splot with pm3d` で
 行うことができます。曲面は通常、それが 3 次元の曲面であるとはっきりわ
 かるような適切な視方向から表示されます。以下参照: `set view`。
 その場合、X, Y, Z 軸はすべて描画内に表示されます。3 次元的な錯覚は、隠
 線処理や、曲面要素の深さ整列により、より増幅されます。以下参照:
 `hidden3d`, および `set pm3d` のオプションである `depthorder`。
 コマンド `splot` は、定数の Z 値に対する等高線を計算し描画することもで
 きます。これらの等高線は、曲面それ自体の上に書くこともできますし、XY
 平面へ射影することもできます。以下参照: `set contour`。
?2D projection (set view map)
?projection
 コマンド `splot` の特別な場合として、描画の Z 方向の射影による、Z 座標
 の 2 次元曲面への地図作成 (map) があります。以下参照: `set view map`。
 この描画モードは、等高線の描画や温度分布を生成するのに利用できます。こ
 の図は描画スタイル `lines` を一度、`labels` を一度描画した等高線を示し
 ています (訳注: 図が表示されている場合)。
 極座標描画 (polar) は、plot コマンドを入力する前に現在の座標系を極座標
 に変更することによって生成します。オプション `set polar` は、入力する
 2 次元座標を <x>,<y> の代わりに <角>,<半径> と解釈することを gnuplot
 に指示します。すべてではないですが、多くの 2 次元描画スタイルが極座標
 モードでも機能します。図は、描画スタイル `lines` と `filledcurves` の
 組み合わせを示しています。(訳注: 図が表示されている場合) 以下参照:
 `set polar`, `set rrange`, `set size square`, `set theta`, `set ttics`。
?beeswarm
?bee swarm
 ビースウォーム (bee swarm) グラフは、揺らぎ (jitter) を適用して重複点
 を分離することにより得られる結果です。その典型的な例は、各点に x 座標
 を決定する 2 つ以上のカテゴリによって表わされる y の値の分布の比較です。
 重なりの判定基準や、jitter で使用する移動パターンを制御する方法に関し
 ては、以下参照: `set jitter`。この図のグラフは、異なる jitter の設定に
 対する同じ plot コマンドによって作られたものです。
      `plot $data using 1:2:1 lc variable`
?fenceplots
 柵グラフ (fence plot) は、複数の 2 次元グラフを、その Y 座標は揃え、そ
 れぞれを区別するために X に沿ってはずらした形で結合したものです。土台
 の値から個々のグラフの Z 座標までの間の領域を塗り潰すことで、Y 方向の
 整列と Z 座標の高さの違いの見た目を強調します。gnuplot でこの形式のグ
 ラフを書くにはいくつかの方法があります。最も単純なのは、5 列の形式の
 `zerrorfill` スタイルを利用する方法です。i で添字化された複数の曲線 z
  = Fi(y) があるとき、`splot with zerrorfill` で以下のような入力列を使
 えば柵グラフを書くことができます:
      i y z_base z_base Fi(y)

?commands
 このセクションでは `gnuplot` が受け付けるコマンドをアルファベット順に
 並べています。このドキュメントを紙に印刷したものは全てのコマンドを含ん
 でいますが、対話型で参照できるドキュメントの方は完全ではない可能性があ
 ります。実際、この見出しの下に何のコマンドも表示されないシステムがあり
 ます。

 ほとんどの場合、コマンド名とそのオプションは、紛らわしくない範囲で省略
 することが可能です。すなわち、"`plot f(x) with lines`" の代わりに
 "`p f(x) w li`" とすることができます。

 書式の記述において、中カッコ ({}) は追加指定できる引数を意味し、
 縦棒 (|) は互いに排他的な引数を区切るものとします。
?commands break
?break
 コマンド `break` は、`do`, `while` 文の繰り返し実行部分のカッコ内での
 み意味を持ちます。このコマンドは、その中カッコ内の残りの命令をスキップ
 し、繰り返しを中断し、その閉じカッコの次の文から実行を再開します。以下
 も参照: `continue`。
?commands cd
?cd
 `cd` コマンドはカレントディレクトリを変更します。

 書式:
         cd '<ディレクトリ名>'

 ディレクトリ名は引用符に囲まれていなければなりません。

 例:
         cd 'subdir'
         cd '..'

 バックスラッシュ (\) は二重引用符内 (") では特別な意味を持ってしまうた
 めにエスケープする必要がありますので、Windows ユーザには単一引用符を使
 うことを勧めます。例えば、
         cd "c:\newdata"
 では失敗しますが、
         cd 'c:\newdata'
         cd "c:\\newdata"
 なら期待通りに動くでしょう。
?commands call
?call
 `call` コマンドは、読み込むファイル名の後ろに、9 つまでのパラメータを
 与えることができることを除けば `load` コマンドと等価です。

      call "inputfile" <param-1> <param-2> <param-3> ... <param-9>

 gnuplot の以前のバージョンでは、そのパラメータ文字列の内容を、特別な記
 号 $0, $1, ..., $9 をマクロのように置換することで表現していました。こ
 の仕組みは、現在は非推奨です (以下参照: `call old-style`)。

 現在の gnuplot は、文字列変数 ARG0, ARG1, ..., ARG9 と、整数変数 ARGC
 を提供します。`call` コマンドを実行すると、ARG0 には入力ファイル名が、
 ARGC にはパラメータ数が設定され、ARG1 から ARG9 にはコマンドラインに並
 べられたパラメータの値が読み込まれます。

 通常パラメータは文字列値として保存されるので、それをマクロ展開して参照
 することもできます (古い形式の書式の類似)。しかし、多くの場合、それらは
 他の変数と同様に利用する方がより自然でしょう。
?call example
?commands call example
      以下を call すると:
          MYFILE = "script1.gp"
          FUNC = "sin(x)"
          call MYFILE FUNC 1.23 "This is a plot title"
      呼び出されたスクリプト内では以下のようになり:
          ARG0 は "script1.gp"
          ARG1 は文字列値 "sin(x)"
          ARG2 は文字列値 "1.23"
          ARG3 は文字列値 "This is a plot title"
          ARGC は 3
      そのスクリプト内では以下のようなものを実行できる:
          plot @ARG1 with lines title ARG3
          print ARG2 * 4.56, @ARG2 * 4.56
          print "This plot produced by script ", ARG0

 この例の ARG1 はマクロとして参照しなければいけませんが、ARG2 はマクロ
 参照でも (数値定数になる)、変数のままでも (文字列 "1.23" が実数値に自
 動的に変換された後の同じ数値になる) 構わないことに注意してください。

 シェルスクリプトで gnuplot をコマンドラインオプション `-c` つきで実行
 することで、これと同じことを直接行うこともできます:

      gnuplot -persist -c "script1.gp" "sin(x)" 1.23 "This is a plot title"

?commands call old-style
?call old-style
 以下は、古いバージョンの gnuplot で使われていた call の仕組みの記述で
 すが、現在は非推奨です。

       call "<input-file>" <param-0> <param-1> ... <param-9>

 入力ファイル名は引用符で囲まなければなりません。入力ファイルの各行を読
 み込む際に、以下の特別な文字列を走査します: $0 $1 $2 $3 $4 $5 $6 $7 $8
 $9 $#。それが見つかったら、「`$`+数字」の列は `call` コマンドラインの
 対応するパラメータに置き換えます。引用符はコピーせず、文字列変数置換は
 行いません。文字列 `$#` はパラメータ数に置き換えます。その他の文字が後
 ろについている `$` は、エスケープシーケンスとして処理します。例えば 1
 個 の `$` を使うには `$$` とします。

 例:

 ファイル 'calltest.gp' は以下の行を含んでいるとすると:
     print "argc=$# p0=$0 p1=$1 p2=$2 p3=$3 p4=$4 p5=$5 p6=$6 p7=x$7x"

 次の行を入力すると:
     call 'calltest.gp' "abcd" 1.2 + "'quoted'" -- "$2"

 以下のように表示されるでしょう:
     argc=7 p0=abcd p1=1.2 p2=+ p3='quoted' p4=- p5=- p6=$2 p7=xx

 注意: 文字 `$` は、gnuplot 自身のデータ列用の書式とぶつかりますし、
 Unix 系のシェルの環境変数を参照する `$` ともぶつかります。特別な文字列
 `$#` は、gnuplot のバージョン 4.5 から 4.6.3 までは、間違えてコメント
 文字列の区切り文字として解釈されていました。文字列置換では引用符は無視
 されるので、文字列定数は簡単に壊れてしまいます。
?commands clear
?clear
?inset
 `clear` コマンドは、`set terminal` や `set output` で選択した画面、出
 力装置をクリアします。ハードコピー装置に対しては通常改ページを行います。

 いくつかの出力装置は `clear` コマンドでは `set size` で定義された描画
 領域のみを消去します。そのため、`set multiplot` とともに使用することで
 挿入図を一つ作ることができます。

 例:
       set multiplot
       plot sin(x)
       set origin 0.5,0.5
       set size 0.4,0.4
       clear
       plot cos(x)
       unset multiplot

 詳細については、以下参照: `set multiplot`, `set size`, `set origin`。
?commands continue
?continue
 コマンド `continue` は、`do`, `while` 文の繰り返し実行部分のカッコ内で
 のみ意味を持ちます。このコマンドは、その中カッコ内の残りの命令をスキッ
 プし、次の繰り返しに進みます (もしループの残りがあれば)。以下も参照:
 `break`。
?commands do
?do
 書式:
       do for <iteration-spec> {
            <commands>
            <commands>
       }
 これは、コマンド列を複数回実行します。コマンドは中カッコ {} で囲み、か
 つ開始カッコ "{" は、キーワード `do` と同じ行に置く必要があります。こ
 のコマンドは、古い形式 (かっこなし) の if/else 構文と一緒に使うことは
 できません。繰り返し指定 <iteration-spec> の例については、以下参照:
 `iteration`。例:
       set multiplot layout 2,2
       do for [name in "A B C D"] {
           filename = name . ".dat"
           set title sprintf("Condition %s",name)
           plot filename title name
       }
       unset multiplot
 以下も参照: `while`, `continue`, `break`。
?commands evaluate
?evaluate
 コマンド `evaluate` は、引数文字列として与えられたコマンドを実行します。
 その文字列中に改行文字を入れてはいけません。

 書式:
       eval <string expression>

 これは、特に同様のコマンドの繰り返しに有用です。

 例:
       set_label(x, y, text) \
         = sprintf("set label '%s' at %f, %f point pt 5", text, x, y)
       eval set_label(1., 1., 'one/one')
       eval set_label(2., 1., 'two/one')
       eval set_label(1., 2., 'one/two')

 文字列からコマンドを実行する別の方法に関しては、以下参照:
 `substitution macros`。
?commands exit
?exit
      exit
      exit message "エラーメッセージ文字列"
      exit status <整数のエラーコード>

 `exit` と `quit` の両コマンドは END-OF-FILE 文字 (通常 Ctrl-D) 同様、
 現在の入力ストリーム、すなわち端末の対話やパイプ入力、ファイル入力 (パ
 イプ) からの入力を終了させます。入力ストリームが入れ子 (階層的な
 `load` のスクリプトで) になっている場合、読み込みは親のストリームで継
 続されます。トップレベルのストリームが閉じられると、プログラムはそれ自
 身終了します。

 コマンド `exit gnuplot` は、直ちに、無条件に、そして例え入力ストリーム
 が多段階にネストされていても、gnuplot を終了させます。その場合、開かれ
 ていた全ての出力ファイルはきれいに完全な形では閉じられない可能性があり
 ます。使用例:

       bind "ctrl-x" "unset output; exit gnuplot"

 コマンド `exit error "error message"` は、疑似プログラムエラーを行いま
 す。対話型モードでは、そのエラーメッセージを表示し、すべのネストされた
 ループや call を中断してコマンドラインに帰ります。非対話型モードでは、
 プログラムを終了します。

 gnuplot が終了しシェルの制御に戻る場合、その返り値は意味のないものにな
 ることがありますが、このコマンドを以下のように実行すれば、シェルに特定
 の値を返すことが可能です。
 このコマンドは試験段階のもので、仕様の細かい部分は変更する可能性があり
 ます。5.4 に現れるかは保証できません。

      exit status <value>

 詳細は、以下参照: `batch/interactive`。
?commands fit
?fit
?least-squares
?Marquardt
 コマンド `fit` は、Marquardt-Levenberg 法による非線形最小自乗法 (NLLS)
 を用いて、データ点の集合にユーザが与える式を当てはめます。独立変数は
 12 まで許されていて、従属変数は常に 1 つで、任意個数のパラメータを当て
 はめることができます。さらに追加で、データ点の重み付け用に誤差評価を入
 力することも可能です。

 `fit` の最も基本的な使用法は、以下の単純な例が示しています:

       f(x) = a + b*x + c*x**2
       fit f(x) 'measured.dat' using 1:2 via a,b,c
       plot 'measured.dat' u 1:2, f(x)

 書式:
       fit {<ranges>} <expression>
           '<datafile>' {datafile-modifiers}
           {{unitweights} | {y|xy|z}error | errors <var1>{,<var2>,...}}
           via '<parameter file>' | <var1>{,<var2>,...}

 範囲 (xrange, yrange 等) は、当てはめに使用するデータを制限する目的で
 使うことができ、その範囲を超えたデータは無視します。その書式は `plot`
 コマンド同様
       [{dummy_variable=}{<min>}{:<max>}],
 です。以下参照: `plot ranges`。

 <expression> は、通常はあらかじめユーザ定義された f(x) または f(x,y)
 の形の関数ですが、`gnuplot` で有効などんな数式でも指定できます。ただし
 実数値関数でなければいけません。
 独立変数の名前は、コマンド `set dummy` で設定するか、fit の範囲指定部
 分 (<rangse>) で設定します (以下を参照)。デフォルトでは、最初の 2 つは
 x, y となります。
 さらに、その数式は、当てはめの作業により決定する値を持つ 1 つ以上の変
 数 (パラメータ) に依存すべきです。

 <datafile> は `plot` コマンドと同様に扱われます。`plot datafile` の修
 飾子 (`using`, `every`,...) は、`smooth` を除いて、全て `fit` に使うこ
 とができます。以下参照:`plot datafile`。

 データファイルの内容は、plot コマンドに使用するのと同じ `using` 指定を
 使うことで柔軟に解釈させることができます。例えば、独立変数 x を2 列目
 と 3 列目の和として生成し、z の値を 6 列目から取り、重みを 1 としたい
 場合は以下のようにします:

       fit ... using ($2+$3):6

 `using` 指定がない場合、fit は暗黙に独立変数は 1 つだけと仮定します。
 ファイル自身、または using 指定が 1 列だけのデータを持つ場合、その行番
 号を独立変数値として使用します。
 `using` 指定を与えた場合、最大 12 個 (指定してコンパイルしていればさら
 にそれ以上) の独立変数を利用できます。

 オプション `unitweights` (これがデフォルト) は、すべてのデータ点が等し
 い重みを持つとみなします。これは、キーワード `error` を使用することで
 変更でき、これはデータファイルから 1 つ以上の変数の誤差評価を読み込み、
 その誤差評価を対応する変数値の標準偏差 s とみなし、各データに 1/s**2
 の重みを計算するのに使用します。

 独立変数の誤差評価において、その重みには、"有効分散法" (effective
 variance method; Jay Orear, Am. J. Phys., Vol. 50, 1982) に従って、さ
 らに当てはめ関数の微分係数をかけます。

 キーワード `errors` には、その後ろに、入力がどの変数の誤差であるのかを
 示すコンマ区切りの 1 つ以上の変数名のリストが付きます。従属変数 z は常
 にその中になければいけませんが、独立変数は必須ではありません。
 そのリストの各変数に対し、ファイルからその分の、各変数の誤差評価を持つ
 追加の列を読み込みます。繰り返しになりますが、`using` 指定により柔軟な
 解釈が可能になります。
 よって、独立変数の数は暗黙に、`using` 指定内の列の数から 1 を引いて
 (従属変数分)、さらに `errors` 指定内の変数の個数を引いた数になることに
 注意してください。

 例として、2 つの独立変数があり、そして 1 つ目の独立変数と従属変数の誤
 差データがある場合は、`errors x,z` 指定と 5 列の `using` 指定を使うこ
 とになりますが、それは x:y:z:sx:sz のように解釈されます (x, y は独立変
 数、z が従属変数、sx, sz は x, z の標準偏差)。

 `errors` 指定のちょっとした略記法も 2,3 用意されています:
 `yerrors` (独立変数が 1 列ある当てはめ用)、
 `zerrors` (より一般の場合) は、いずれも `errors z` と同値で、1 列だけ
 追加の従属変数用の誤差列があることを意味しています。

 `xyerrors` は、独立変数は 1 列で、その独立変数と従属変数の両方の 2 列
 の誤差列が追加されることを意味します。この場合、x と y の誤差は Orear
 の有効分散法 (effective variance method) で処理されます。

 `yerror` と `xyerror` の形式および解釈は、それぞれ 2 次元描画スタイル
 の `yerrorlines` と `xyerrorlines` に同等であることに注意してください。

 コマンド `set fit v4` を使用すると、fit のコマンド書式は `gnuplot` バ
 ージョン 4 以前と互換の書式になります。その場合、`using` には、独立変
 数が 2 つ以上ならば、独立変数の数より 2 つ (z と s) 多い指定が必要で、
 `gnuplot` は、`using` 指定で与えられた列の数に応じて、以下の書式に従い
 ます:

       z                           # 独立変数は 1 つ (行番号)
       x:z                         # 独立変数は 1 つ (第 1 列)
       x:z:s                       # 独立変数は 1 つ (全部で 3 列)
       x:y:z:s                     # 独立変数は 2 つ (全部で 4 列)
       x1:x2:x3:z:s                # 独立変数は 3 つ (全部で 5 列)
       x1:x2:x3:...:xN:z:s         # 独立変数は N 個 (全部で N+2 列)

 これは、2 つ以上の独立変数で fit をする場合、z-誤差 s を与える必要があ
 ることを意味することに注意してください。重みを 1 にしたい場合は、それ
 を、例えば x:y:z:(1) のような書式を using に指定することで明示的に与え
 る必要があります。

 仮変数名は、下で紹介するように範囲指定で指定することで変更できます。最
 初の範囲は `using` 指定の最初のものに対応し、以下同様です。従属変数で
 ある z の範囲指定もできますが、それは、f(x,...) の値をその範囲外にして
 しまうようなデータ点が、残差を最小化することには寄与しない場合に有効で
 す。

 複数のデータ集合も複数の 1 変数関数に同時に当てはめることも、y を '仮
 変数' とすれば可能です。例えばデータ行番号を使い、2 変数関数への当ては
 め、とすればいいでしょう。以下参照: `fit multi-branch`。

 `via` 指定子は、パラメータの最適化を、直接行うか、またはパラメータファ
 イルを参照することによって行うかを指定します。

 例:
       f(x) = a*x**2 + b*x + c
       g(x,y) = a*x**2 + b*y**2 + c*x*y
       set fit limit 1e-6
       fit f(x) 'measured.dat' via 'start.par'
       fit f(x) 'measured.dat' using 3:($7-5) via 'start.par'
       fit f(x) './data/trash.dat' using 1:2:3 yerror via a, b, c
       fit g(x,y) 'surface.dat' using 1:2:3 via a, b, c
       fit a0 + a1*x/(1 + a2*x/(1 + a3*x)) 'measured.dat' via a0,a1,a2,a3
       fit a*x + b*y 'surface.dat' using 1:2:3 via a,b
       fit [*:*][yaks=*:*] a*x+b*yaks 'surface.dat' u 1:2:3 via a,b

       fit [][][t=*:*] a*x + b*y + c*t 'foo.dat' using 1:2:3:4 via a,b,c

       set dummy x1, x2, x3, x4, x5
       h(x1,x2,x3,x4,s5) = a*x1 + b*x2 + c*x3 + d*x4 + e*x5
       fit h(x1,x2,x3,x4,x5) 'foo.dat' using 1:2:3:4:5:6 via a,b,c,d,e

 反復の個々のステップの後で、当てはめの現在の状態についての詳細な情報が
 画面に表示されます。そし最初と最後の状態に関する同じ情報が "fit.log"
 というログファイルにも書き出されます。このファイルは前の当てはめの履歴
 を消さないように常に追加されていきます。これは望むなら削除、あるいは別
 な名前にできます。コマンド `set fit logfile` を使ってログファイルの名
 前を変更することもできます。

 `set fit errorvariables` を使用した場合、各当てはめパラメータの誤差は
 そのパラメータと似た名前 ("_err" が追加された名前) の変数に保存されま
 すので、その誤差をその後の計算の入力として使用することができます。

 `set fit prescale` とした場合、当てはめパラメータを、それらの初期値か
 らスケール変換します。これにより、個々のパラメータの大きさにかなり違い
 があるような場合でも、Marquardt-Levenberg ルーチンがより早く、より信頼
 性のある値に収束させられるようになります。

 当てはめの反復は Ctrl-C (wgnuplot では Ctrl-Break) を押すことで中断で
 きます。現在の反復が正常に終了した後、以下のいずれかを選ぶことができま
 す:
 (1) 当てはめを止めて現在のパラメータの値を採用する
 (2) 当てはめを続行する
 (3) `set fit script` か、環境変数 `FIT_SCRIPT` で指定した `gnuplot` コ
 マンドを実行する。そのデフォルトは `replot` で、もしデータと当てはめ関
 数を一つのグラフにあらかじめ描画してあれば、現在の当てはめの状態を表示
 することができます。

 `fit` が終了した後は、最後のパラメータの値を保存するのに `save fit` コ
 マンドを使います。その値は再びパラメータの値として使うことができます。
 詳細は、以下参照: `save fit`。
?commands fit parameters
?fit parameters
?commands fit adjustable_parameters
?fit adjustable_parameters
?fit_parameters
 `via` はパラメータを調節するための 2 つの方法を指定できます。一つは
 コマンドラインから直接指示するもので、もう一つはパラメータファイルを
 参照して間接的に行うものです。この 2 つは初期値の設定で違った方法を取
 ります。

 調整するパラメータは、`via` キーワードの後ろにコンマで区切られた変数名
 のリストを書くことで指定できます。定義されていない変数は初期値 1.0 と
 して作られます。しかし当てはめは、変数の初期値があらかじめ適切な値に設
 定されている方が多分速く収束するでしょう。

 パラメータファイルは個々のパラメータを、個別に 1 行に一つずつ、初期値を
 次のような形で指定して書きます。
       変数名 = 初期値

 '#' で始まるコメント行や空行も許されます。特別な形式として
       変数名 = 初期値       # FIXED

 は、この変数が固定されたパラメータであることを意味し、それはこのファイ
 ルで初期化されますが、調節はされません。これは、`fit` でレポートされる
 変数の中で、どれが固定された変数であるかを明示するのに有用でしょう。な
 お、`# FIXED` と言うキーワードは厳密にこの形でなくてはなりません。

?commands fit beginners_guide
?fit beginners_guide
?fit guide
?fitting
 `fit` は、与えられたデータ点を与えられたユーザ定義関数にもっとも良く
 当てはめるようなパラメータを見つけるのに使われます。その当てはめは、
 同じ場所での入力データ点と関数値との自乗誤差、あるいは残差 (SSR:Sum
 of the Squared Residuals) の和を基に判定されます。この量は通常χ(カイ)
 自乗と呼ばれます。このアルゴリズムは SSR を 最小化することをしようと
 します。もう少し詳しく言うと、データ誤差 (または 1.0) の重みつき残差の
 自乗和 (WSSR) の最小化を行っています。詳細は、以下参照:
 `fit error_estimates`。

 これが、(非線形) 最小自乗当てはめ法と呼ばれるゆえんです。`非線形` が
 何を意味しているのかを見るための例を紹介しますが、その前にいくつかの
 仮定について述べておきます。ここでは簡単のため、1 変数のユーザー定義
 関数は z=f(x), 2 変数の関数は z=f(x,y) のようにし、いずれも従属変数と
 して z を用いることにします。パラメータとは `fit` が調整して適切な値を
 決定するユーザ定義変数で、関数の定義式中の未知数です。ここで言う、線形
 性/非線形性とは、従属変数 z と `fit` が調整するパラメータとの関係に対
 するものであり、z と独立変数 x (または x と y) との関係のことではあり
 ません (数学的に述べると、線形最小自乗問題では、当てはめ関数のパラメー
 タによる 2 階 (そして更に高階の) 導関数は 0、ということになります)。

 線形最小自乗法 (LLS) では、ユーザ定義関数は単純な関数の和であり、それ
 ぞれは一つのパラメータの定数倍で他のパラメータを含まない項になります。
 非線形最小自乗法 (NLLS) ではより複雑な関数を扱い、パラメータは色んな
 使われ方をされます。フーリエ級数は線形と非線形の最小自乗法の違いを表す
 一つの例です。フーリエ級数では一つの項は
      z=a*sin(c*x) + b*cos(c*x).
 のように表されます。もし、a と b が未知なパラメータで c は定数だとすれば
 パラメータの評価は線形最小自乗問題になります。しかし、c が未知なパラメー
 タならばそれは非線形問題になります。

 線形の場合、パラメータの値は比較的簡単な線形代数の直接法によって決定で
 きます。しかしそのような LLS は特殊な場合であり、'gnuplot' が使用する
 反復法は、もちろんそれも含めて、より一般的な NLLS 問題を解くことができ
 ます。`fit` は検索を行うことで最小値を探そうとします。反復の各ステップ
 は、パラメータの新しい値の組に対して WSSR を計算します。Marquardt-
 Levenberg のアルゴリズムは次のステップのパラメータの値を選択します。そ
 してそれはあらかじめ与えた基準、すなわち、(1) 当てはめが "収束した"
 (WSSR の相対誤差がある限界値より小さくなった場合。以下参照:
 `set fit limit`)、または (2) あらかじめ設定された反復数の限界に達した
 場合 (以下参照: `set fit maxiter`)、のいずれかを満たすまで続けられます。
 キーボードからその当てはめの反復は中断できますし、それに続いて中止する
 こともできます (以下参照: `fit`)。ユーザ変数 FIT_CONVERGED は、 直前の
 fit コマンドが収束により終了した場合は 1 を持ち、それ以外の理由で中断
 した場合は 0 を持ちます。FIT_NITER は、直前の当てはめで行われた繰り返
 しの回数を持ちます。

 当てはめに使われる関数はしばしばあるモデル (またはある理論) を元にして
 いて、それはデータの振舞を記述したり、あるいは予測しようとします。よっ
 て `fit` は、データがそのモデルにどれくらいうまく当てはまっているのかを
 決定するため、そして個々のパラメータの誤差の範囲を評価するために、モデ
 ルの自由なパラメータの値を求めるのに使われます。以下参照:
 `fit error_estimates`。

 そうでなければ、曲線による当てはめにおける関数は、モデルとは無関係に選
 ばれています (それは十分な表現力と最も少ない数のパラメータを持ち、デー
 タの傾向を記述しそうな関数として経験に基づいて選ばれるでしょう)。

 しかし、もしあなたが全てのデータ点を通るような滑らかな曲線を欲しいなら
 `fit` ではなく、むしろ `plot` の `smooth` オプションでそれを行うべきで
 しょう。
?commands fit error_estimates
?fit error_estimates
?fit errors
 `fit` において "誤差" という用語は 2 つの異なった文脈で用いられます。
 一つはデータ誤差、もう一つはパラメータ誤差です。

 データ誤差は、平方残差の重み付きの和 WSSR、すなわちχ自乗を決定する際
 個々のデータ点の相対的な重みを計算するのに用いられます。それらはパラメ
 ータの評価に影響を与えます。それは、それらが、当てはめられた関数からの
 個々のデータ点の偏差が最終的な値に与える影響の大きさを決定することによ
 ります。正確なデータ誤差評価が与えられている場合には、パラメータの誤差
 評価等の `fit` が出力する情報はより役に立つでしょう。

 `statistical overview` では `fit` の出力のいくつかを説明し、
 'practical guidelines' に対する背景を述べています。
?commands fit error statistical_overview
?fit error statistical_overview
?statistical_overview
 非線形最小自乗法 (Non-Linear Least-Squares; NLLS) の理論は、誤差の正規
 分布の点から一般的に記述されています。すなわち、入力データは与えられた
 平均とその平均に対する与えられた標準偏差を持つガウス (正規) 分布に従う
 母集団からの標本と仮定されます。十分大きい標本、そして母集団の標準偏差
 を知ることに対しては、χ自乗分布統計を用いて、通常「χ自乗」と呼ばれる
 値を調べることにより「当てはめの良さ」を述べることができます。減らされ
 た自由度のχ自乗 (χ自乗の自由度は、データ点の数から当てはめられるパラ
 メータの個数だけ引いた数) が 1.0 である場合は、データ点と当てはめられた
 関数との偏差の重みつき自乗和が、現在のパラメータ値に対する関数と与えら
 れた標準偏差によって特徴付けられた母集団の、ランダムなサンプルに対する
 自乗和とが全く同じであることを意味します。

 分散 = 総計である数え上げ統計学同様、母集団の標準偏差が定数でない場合、
 各点は観測される偏差の和と期待される偏差の和を比較するときに個別に重み
 づけされるべきです。

 最終段階で `fit` は 'stdfit'、すなわち残差の RMS (自乗平均平方根) で求
 められる当てはめの標準偏差と、データ点が重みづけられている場合に '減ら
 されたχ自乗' とも呼ばれる残差の分散をレポートします。自由度 (データ点
 の数から当てはめパラメータの数を引いたもの) はこれらの評価で使用されま
 す。なぜなら、データ点の残差の計算で使われるパラメータは同じデータから
 得られるものだからです。データ点が重みを持つ場合、`gnuplot` はいわゆる
 p-値を計算します。それはその自由度と結果のχ自乗値に対するχ自乗分布の
 累積分布関数値を 1 から引いた値です。以下参照: `practical_guidelines`。
 これらの値は以下の変数に代入されます:
       FIT_NDF = 自由度の数
       FIT_WSSR = 重みつき残差の自乗和
       FIT_STDFIT = sqrt(WSSR/NDF)
       FIT_P = p-値

 パラメータに関する信頼レベルを評価することで、当てはめから得られる最小
 のχ自乗と、要求する信頼レベルのχ自乗の値を決定するためのχ自乗の統計
 を用いることが出来ます。しかし、そのような値を生成するパラメータの組を
 決定するには、相当のさらなる計算が必要となるでしょう。

 `fit` は信頼区間の決定よりむしろ、最後の反復後の分散-共分散行列から直
 ちに得られるパラメータの誤差評価を報告します。これらの評価は、標準偏差
 として計算される量の指定に関する統計上の条件が、一般には非線形最小自乗
 問題では保証されないのですが、線形最小自乗問題での標準誤差 (各パラメー
 タの標準偏差) と同じ方法で計算されます。そしてそのため慣例により、これ
 らは "標準誤差" とか "漸近標準誤差" と呼ばれています。漸近標準誤差は一
 般に楽観過ぎ、信頼レベルの決定には使うべきではありませんが、定性的な指
 標としては役に立つでしょう。

 最終的な解は、解の範囲におけるパラメータの相関を示す相関行列も生成しま
 す: その主対角要素、すなわち自己相関は常に 1 で、全てのパラメータが独
 立ならば非対角要素はすべて 0 に近い値になります。完全に他を補いあう 2
 つの変数は、大きさが 1 で、関係が正の相関か負の相関かによって正か負に
 なる符号を持つ非対角要素を持ちます。非対角要素の大きさが小さいほど、各
 パラメータの標準偏差の評価は、漸近標準誤差に近くなります。
?commands fit error practical_guidelines
?fit error practical_guidelines
?practical_guidelines
?guidelines
 個々のデータ点への重みづけの割り当ての基礎を知っているなら、それが測定
 結果に対するより詳しい情報を使用させようとするでしょう。例えば、幾つか
 の点は他の点より当てになるということを考慮に入れることが可能です。そし
 て、それらは最終的なパラメータの値に影響します。

 データの重み付けは、最後の反復後の `fit` の追加出力に対する解釈の基礎
 を与えます。各点に同等に重み付けを行なうにしても、重み 1 を使うことよ
 りもむしろ平均標準偏差を評価することが、χ自乗が定義によりそうであるよ
 うに、WSSR を 無次元変数とすることになります。

 当てはめ反復の各段階で、当てはめの進行の評価に使うことが出来る情報が表
 示されます ('*' はより小さい WSSR を見つけられなかったこと、そして再試
 行していることを意味します)。'sum of squares of residuals' (残差の自乗
 和) は、'chisquare' (χ自乗) とも呼ばれますが、これはデータと当てはめ
 関数との間の WSSR を意味していて、`fit` はこれを最小化しようとします。
 この段階で、重み付けされたデータによって、χ自乗の値は自由度 (= データ
 点の数 - パラメータの数) に近付くことが期待されます。WSSR は補正された
 χ自乗値 (WSSR/ndf; ndf = 自由度)、または当てはめ標準偏差 (stdfit =
 sqrt(WSSR/ndf)) を計算するのに使われます。それらは最終的な WSSR に対し
 てレポートされます。

 データが重み付けされていなければ、stdfit は、ユーザの単位での、データ
 と当てはめ関数の偏差の RMS (自乗平均平方根) になります。

 もし妥当なデータ誤差を与え、データ点が十分多く、モデルが正しければ、
 補正χ自乗値はほぼ 1 になります (詳細は、適当な統計学の本の 'χ自乗分
 布' の項を参照してください)。この場合、この概要に書かれていること以外
 に、モデルがデータにどれくらい良く当てまっているかを決定するための追加
 の試験方法がいくつかあります。

 補正χ自乗が 1 よりはるかに大きくなったら、それは不正なデータ誤差評価、
 正規分布しないデータ誤差、システム上の測定誤差、孤立した標本値
 (outliers)、または良くないモデル関数などのためでしょう。例えば
 `plot 'datafile' using 1:($2-f($1))` などとして残差を描画することは、
 それらのシステム的な傾向を知るための手がかりとなります。データ点と関数
 の両者を描画することは、他のモデルを考えための手がかりとなるでしょう。

 同様に、1.0 より小さい補正χ自乗は、WSSR が、正規分布する誤差を持つラ
 ンダムなサンプルと関数に対して期待されるものよりも小さいことを意味しま
 す。データ誤差評価が大きすぎるのか、統計的な仮定が正しくないのか、また
 はモデル関数が一般的すぎて、内在的傾向に加えて特殊なサンプルによる変動
 の当てはめになっているのでしょう。最後の場合は、よりシンプルな関数にす
 ればうまく行くでしょう。

 当てはめの p-値は、自由度と結果のχ自乗値に対するχ自乗分布の累積分布
 関数値を 1 から引いた値です。これは、当てはめの良さのものさしを提供し
 ます。p-値の範囲は 0 から 1 までで、p-値がとても小さい、あるいはとても
 大きい場合は、モデルがデータとその誤差をちゃんと記述していないことを意
 味します。上で述べたように、これはデータに問題があるか、誤差かモデルに
 問題がある、またはそれらの組み合わせなのだろうと思います。p-値が小さい
 ことは、誤差が過小評価されているので、よって最終的なパラメータ誤差をス
 ケール変換すべきだろうということを意味するでしょう。以下も参照:
 `set fit errorscaling`。

 標準的なエラーを、パラメータの不確定性に関する、あるより現実的な評価に
 関係付けること、および相関行列の重要性を評価することができるようになる
 前に、あなたは `fit` と、それを適用しようとするある種の問題に慣れてお
 く必要があるでしょう。

 `fit` は、大抵の非線形最小自乗法の実装では共通して、距離の自乗
 (y-f(x))**2 の重み付きの和を最小化しようとすることに注意してください。
 それは、x の値の "誤差" を計算に関してはどんな方法も与えてはおらず、単
 に y に関する評価のみです。また、"孤立点" (正規分布のモデルのから外れ
 ているデータ点) は常に解を悪化させる可能性があります。
?commands fit control
?fit control
 コマンド `fit` の設定は、`set fit` で制御します。以前の `gnuplot` のユ
 ーザ変数は、バージョン 5 で非推奨となっています。以下参照:
 `fit control variables`。

 `gnuplot` の起動前に `fit` に影響を与えるように定義できる多くの環境変
 数があります。以下参照: `fit control environment`。
?commands fit control variables
?fit control variables
 ここで説明するユーザ定義変数は、非推奨です。以下参照: `set fit`。

 デフォルトのもっとも小さい数字の限界 (1e-5) は、変数
       FIT_LIMIT
 で変更できます。残差の平方自乗和が 2 つの反復ステップ間で、この数値よ
 り小さい数しか変化しなかった場合、当てはめルーチンは、これを '収束した'
 と見なします。

 反復数の最大値は変数
       FIT_MAXITER
 で制限されます。0 (または定義しない場合) は制限無しを意味します。

 更にそのアルゴリズムを制御したい場合で、かつ Marquardt-Levenberg アル
 ゴリズムを良く知っている場合は、さらにそれに影響を与える変数があります。
 `lambda` (λ) の最初の値は、通常 ML 行列から自動的に計算されますが、も
 しそれをあらかじめ用意した値にセットしたければ
       FIT_START_LAMBDA
 にセットしてください。FIT_START_LAMBDA を 0 以下にセットすると、自動的
 に計算されるようになります。変数
       FIT_LAMBDA_FACTOR
 は、χ自乗化された関数が増加、あるいは減少するにつれて `lambda` が増加
 あるいは減少する因数を与えます。FIT_LAMBDA_FACTOR を 0 とすると、それは
 デフォルトの因数 10.0 が使用されます。

 `fit` には FIT_ から始まる変数が他にもありますから、ユーザ定義変数とし
 てはそのような名前で始まる変数は使わないようにするのが安全でしょう。

 変数 FIT_SKIP と FIT_INDEX は、以前の版の `gnuplot` の、`gnufit` と呼
 ばれていた `fit` パッチで使われていたもので、現在は使用されていません。
 FIT_SKIP の機能はデータファイルに対する `every` 指定子で用意されていま
 す。FIT_INDEX は複数当てはめ法 (multi-branch fitting) で使われていたも
 のですが、1 変数の複数当てはめ法は、今では 疑似 3 次元当てはめとして行
 なわれていて、そこでは枝の指定には 2 変数と `using` が使われています。
 以下参照: `fit multi-branch`。
?commands fit control environment
?fit control environment
 環境変数は `gnuplot` が立ち上がる前に定義しなければなりません。その設
 定方法はオペレーティングシステムに依存します。

       FIT_LOG
 は、当てはめのログが書かれるファイル名 (およびパス) を変更します。デフ
 ォルトでは、作業ディレクトリ上の "fit.log" となっています。そのデフォ
 ルトの値はコマンド `set fit logfile` を使って上書きできます。

       FIT_SCRIPT
 は、ユーザが中断した後に実行するコマンドを指定します。デフォルトでは
 `replot` ですが、`plot` や `load` コマンドとすれば、当てはめの進行状
 況の表示をカスタマイズするのに便利でしょう。その設定は、
 `set fit script` を使って変更できます。
?commands fit multi-branch
?fit multi-branch
?multi-branch
?branch
 複数当てはめ法 (multi-branch fitting) では、複数のデータ集合を、共通の
 パラメータを持つ複数の 1 変数の関数に、WSSR の総和を最小化することによ
 って同時に当てはめることが出来ます。各データ集合に対する関数とパラメー
 タ (枝) は '疑似変数' を使うことで選択できます。例えば、データ行番号
 (-1; 'データ列' の番号) またはデータファイル番号 (-2) を 2 つ目の独立
 変数とします。

 例: 2 つの指数減衰形 z=f(x) が与えられていて、それぞれ異なるデータ集合
 を記述しているが、共通した減衰時間を持ち、そのパラメータの値を評価する。
 データファイルが x:z:s の形式であったとすると、この場合以下のようにす
 ればよい。
      f(x,y) = (y==0) ? a*exp(-x/tau) : b*exp(-x/tau)
      fit f(x,y) 'datafile' using  1:-2:2:3  via a, b, tau

 より複雑な例については、デモファイル "fit.dem" で使われる "hexa.fnc"
 を参照してください。

 もし従属変数のスケールに差がある場合、単位の重み付けでは 1 つの枝が支
 配してしまう可能性があるので、適当な重み付けが必要になります。各枝をバ
 ラバラに当てはめるのに複数当てはめ法の解を初期値として用いるのは、全体
 を合わせた解の各枝に対する相対的な影響に関する表示を与えることになるで
 しょう。
?commands fit starting_values
?fit starting_values
?starting_values
 非線形当てはめは、大域的な最適値 (残差の自乗和 (SSR) の最小値を持つ解)
 への収束は保証はしませんが、局所的な極小値を与えることはできます。その
 サブルーチンはそれを決定する方法を何も持ち合わせていないので、これが起
 こったかどうかを判断するのはあなたの責任となります。

 `fit` は、解から遠くから始めると失敗するかも知れませんし、しばしばそれ
 は起こり得ます。遠くというのは、SSR が大きく、パラメータの変化に対して
 その変化が小さい、あるいは数値的に不安定な領域 (例えば数値が大きすぎて
 浮動小数の桁あふれを起こす) に到達してしまって、その結果 "未定義値
 (undefined value)" のメッセージか `gnuplot` の停止を引き起こしてしまう
 ような場合を意味します。

 大域的な最適値を見つける可能性を改善するには、最初の値をその解に少なく
 ともほぼ近くに取るべきでしょう。例えば、もし可能ならば一桁分の大きさの
 範囲内で。最初の値が解に近いほど不正な解で終了してしまう可能性は低くな
 ります。最初の値を見つける一つの方法は、データと当てはめ関数を同じグラ
 フの上に描画して適当な近さに達するまで、パラメータの値を変更して
 `replot` することを繰り返すことです。その描画は、不正な極小値を見つけ
 たことで当てはめが終了したかどうかをチェックするのにも有用です。

 もちろん、見た目が良い当てはめが見つかっても、それは "それよりよい" 当
 てはめ (ある改良された当てはめの良さの基準によって特徴付けられた統計学
 的な意味で、あるいはそのモデルのより適切な解である、という物理的な意味
 で) が存在しないことの証明にはなりません。問題によっては、各パラメータ
 の意味のある範囲をカバーするような様々な初期値の集合に対して `fit` す
 ることが望ましいかも知れません。
?commands fit tips
?fit tips
?tips
 ここでは、`fit` を最大限に利用するためにいくつか覚えておくべきヒントを
 紹介します。それらは組織的ではないので、その本質がしみ込むまで何回もよ
 く読んでください。

 `fit` の引数の `via` には、2 つの大きく異なる目的のための 2 つの形式が
 あります。`via "file"` の形式は、バッチ処理 (非対話型での実行が可能)
 で最も良く使われ、そのファイルの中で初期値を与えることができます。

 `via var1, var2, ...` の形式は対話型の実行で良く使われ、コマンドヒスト
 リの機構が使ってパラメータリストの編集を行い、当てはめを実行したり、あ
 るいは新しい初期値を与えて次の実行を行なったりします。これは難しい問題
 に対しては特に有用で、全てのパラメータに対して 1 度だけ当てはめを直接
 実行しても、良い初期値でなければうまくいかないことが起こり得るからです。
 それを見つけるには、いくつかのパラメータのみに対して何回か反復を行ない、
 最終的には全てのパラメータに対する 1 度の当てはめがうまくいくところに
 十分近くなるまでそれを繰り返すことです。

 当てはめを行なう関数のパラメータ間に共通の依存関係がないことは確認して
 おいてください。例えば、a*exp(x+b) を当てはめに使ってはいけません。そ
 れは a*exp(x+b)=a*exp(b)*exp(x) だからです。よってこの場合は a*exp(x)
 または exp(x+b) を使ってください。

 技術的なお話: 絶対値が最も大きいパラメータと最も小さいパラメータの比が
 大きい程当てはめの収束は遅くなります。その比が、マシンの浮動小数の精度
 の逆数に近いか、またはそれ以上ならば、ほぼずっと収束しないか収束する前
 に実行が中断するでしょう。よってそのような場合は、その関数の定義で例え
 ば 'parameter' を '1e9*parameter' にするとか、最初の値を 1e9 で割ると
 かしてこれを避けるように改良するか、または `set fit prescale` でパラメ
 ータの初期値に従ってそのスケール変換を内部でやらせる機能を用いるか、の
 いずれかが必要でしょう。

 もし、関数を、当てはめるパラメータを係数とする、単純な関数の線形結合で
 書けるなら、それはとてもいいので是非そうしてください。何故なら、問題が
 もはや非線形ではないので、反復は少ない回数で収束するでしょう。もしかし
 たらたった一回ですむかもしれません。

 実際の実験の講義ではデータ解析に対するいくつかの指示が与えられ、それで
 データへの最初の関数の当てはめが行なわれます。もしかすると、基礎理論の
 複数の側面にひとつずつ対応する複数回のプロセスが必要かも知れませんが、
 そしてそれらの関数の当てはめのパラメータから本当に欲しかった情報を取り
 出すでしょう。しかし、`fit` を使えば、求めるパラメータの視点から直接モ
 デル関数を書くことにより、それはしばしば 1 回で済むのです。時々はより
 難しい当てはめ問題の計算コストがかかりますが、データ変換もかなりの割合
 で避けることが出来ます。もしこれが、当てはめ関数の単純化に関して、前の
 段落と矛盾してると思うなら、それは正解です。

 "singular matrix" のメッセージは、この Marquardt-Levenberg アルゴリズ
 ムのルーチンが、次の反復に対するパラメータの値の計算が出来ないことを意
 味します。この場合、別な初期値から始めるか、関数を別な形で書き直すか、
 より簡単な関数にしてみてください。

 最後に、他の当てはめパッケージ (fudgit) のマニュアルから、これらの文書
 を要約するようないい引用を上げます: "Nonlinear fitting is an art! (非
 線形当てはめ法は芸術だ !)"
?commands help
?help
 `help`コマンドは、組み込みヘルプを表示します。ある項についての説明を指
 定したいときには、次の書式を使って下さい:

         help {<項目名>}

 もし <項目名> が指定されなかった場合は、`gnuplot` についての簡単な説明
 が表示されます。指定した項目についての説明が表示された後、それに対する
 細目のメニューが表示され、その細目名を入力することで細目に対するヘルプ
 を続けることができます。そして、その細目の説明が表示された後に、さらな
 る細目名の入力を要求されるか、または 1 つ前の項目のレベルへ戻ります。
 これを繰り返すとやがて、`gnuplot` のコマンドラインへと戻ります。

 また、疑問符 (?) を項目として指定すると、現在のレベルの項目のリストが
 表示されます。
?commands history
?history
 コマンド `history` は、コマンド履歴の一覧を表示したり、保存したり、一
 覧の中のコマンドを再実行したりします。このコマンドの挙動を変えるには、
 以下参照: `set history`。

 `history` コマンドで始まる入力行は、コマンド履歴には保存しません。

 例:

       history               # 履歴全体を表示
       history 5             # 履歴内の直前の 5 つを表示
       history quiet 5       # エントリ番号なしで直前の 5 つを表示
       history "hist.gp"     # 履歴全体をファイル hist.gp に書き出す
       history "hist.gp" append # 履歴全体をファイル hist.gp に追加する
       history 10 "hist.gp"  # 直前の 10 個をファイル hist.gp に出力
       history 10 "|head -5 >>diary.gp" # パイプで履歴を 5 つ書き出す
       history ?load         # 履歴内の "load" で始まるものすべてを表示
       history ?"set c"      # 上と同様 (複数の語は引用符で囲む)
       hi !reread            # "reread" で始まる最も新しい行を実行
       hist !"set xr"        # 上と同様 (複数の語は引用符で囲む)
       hist !55              # 55 番目の履歴項目のコマンドを再実行
?commands if
?if
 新しい書式:
       if (<condition>) { <commands>;
              <commands>
              <commands>
       } else {
              <commands>
       }
 以前の書式:
       if (<条件>) <コマンド行> [; else if (<条件>) ...; else ...]

 このバージョンの gnuplot は、if/else のブロック形式をサポートしていま
 す。キーワード `if`, `else` の後ろに開始カッコ "{" が続く場合、"}" で
 終了するブロックまでのすべての文 (複数の入力行も可) に条件的な実行が適
 用されます。if コマンドは入れ子にすることもできます。

 古い形式の 1 行の if/else 文もまだサポートされていますが、新しいブロッ
 ク形式の書式とは混ぜてはいけません。以下参照: `if-old`。
?if if-old
?if-old
 gnuplot バージョン 4.4 までは、if/else コマンドの通用範囲は 1 行内に留
 まっていましたが、現在は複数行を中カッコ { } で囲んで書くことができま
 す。古い形式も一応残されていますが、それは中カッコのブロック内で使うこ
 とはできません。

 キーワード `if` が "{" をともなわない場合は、<条件> が真 (ゼロでない)
 ならば <コマンド行> のコマンド (複数も可) が実行され、偽 (ゼロ) ならば
 スキップされます。いずれの場合も入力行の最後になるか、`else` が現れる
 ところまでそれが行われます。`;` を使うと同じ行に複数のコマンド置くこと
 が可能ですが、条件付きのコマンド (`if` の構文自体) はそこでは終らない
 ことに注意してください。

 例:
       pi=3
       if (pi!=acos(-1)) print "?Fixing pi!"; pi=acos(-1); print pi
 を実行すると、
       ?Fixing pi!
       3.14159265358979
 と表示されますが、
       if (1==2) print "Never see this"; print "Or this either"
 とすると、何も表示されません。

 その他:
       v=0
       v=v+1; if (v%2) print "2" ; else if (v%3) print "3" ; else print "fred"
 (何度も最後の行を繰り返してみてください !)
?for
 `plot`, `splot`, `set`, `unset` コマンドでは、繰り返しの for 節を使う
 こともできます。これは、基本的なコマンドを複数回実行する効果を持ち、そ
 のおのおのの実行では繰り返し制御変数によって数式は再評価されます。`do`
 コマンドでは、どんなコマンド列でも繰り返し実行させることができます。繰
 り返し節は現在は以下の 2 つの形式をサポートしています:

       for [intvar = start:end{:increment}]
       for [stringvar in "A B C D"]

 例:

       plot for [filename in "A.dat B.dat C.dat"] filename using 1:2 with lines
       plot for [basename in "A B C"] basename.".dat" using 1:2 with lines
       set for [i = 1:10] style line i lc rgb "blue"
       unset for [tag = 100:200] label tag

 繰り返しの入れ子もサポートしています:

       set for [i=1:9] for [j=1:9] label i*10+j sprintf("%d",i*10+j) at i,j

 さらなる説明については、以下参照: `iteration`, `do`。
?commands import
?import
 コマンド `import` は、ユーザ定期関数名を外部共有オブジェクトから取り込
 まれる関数に結びつけます。これは、gnuplot で利用可能な関数の設定を拡張
 するプラグイン機構を構成します。

 書式:
       import func(x[,y,z,...]) from "sharedobj[:symbol]"

 例:
       # 関数 myfun を "mylib.so" か "mylib.dll" から取り込んで作成する
       # gnuplot では描画、または数値計算で利用可能
       import myfun(x) from "mylib"
       import myfun(x) from "mylib:myfun"    # 上と同様

       # "theirlib.so" か "theirlib.dll" で定義済の関数 theirfun を作成
       # 異なる名前で利用可能
       import myfun(x,y,z) from "theirlib:theirfun"

 プログラムは共有オブジェクトとして与えられた名前に、オペレーティングシ
 ステムに従って ".so" か ".dll" を追加し、まずそれをフルパス名として検
 索し、次にカレントディレクトリからの相対パス名として検索します。オペレ
 ーティングシステム自体も LD_LIBRARY_PATH か DYLD_LIBRARY_PATH の任意の
 ディレクトリを検索します。

?commands load
?load
 `load` コマンドは、指定された入力ファイルの各行を、それが対話的に入力
 されたかのように実行します。`save` コマンドでつくられたファイルは、
 `load` することができます。有効なコマンドの書かれたテキストファイルを
 つくれば、それは、`load`コマンドによって、実行することができます。
 `load` 中のファイルの中にさらに `load` または `call` コマンドがあって
 も構いません。コマンド中のコメントについては、以下参照: `comments`。
 `load` するときに引数を与える方法については、以下参照: `call`。

 書式:
         load "<入力ファイル名>"

 入力ファイル名は引用符で囲まなければなりません。

 `load` コマンドは、標準入力からのコマンドの入力のために、特別なファイ
 ル名 "-" を用意しています。これは、`gnuplot` のコマンドファイルが、い
 くつかのコマンドを標準入力から受け付けることを意味します。詳細について
 は、以下参照: `batch/interactive`。

 Unix のように popen 関数をサポートするようなシステムでは、'<' で始まる
 ファイル名にすることで、入力ファイルをパイプから読み込むことができます。

 例:
         load 'work.gnu'
         load "func.dat"
         load "< loadfile_generator.sh"

 `gnuplot` への引数として与えられたファイル名は、暗黙のうちに `load` コ
 マンドによって実行されます。これらは、指定された順にロードされ、その後
 `gnuplot` は終了します。
 以下参照: `raise`。
?commands pause
?pause
?pause mouse
 `pause` コマンドは、コマンドに続く任意の文字列を表示した後、指定され
 た時間または、改行キーが押されるまで待ちます。`pause` コマンドは、
 `load` 用のファイルと共に使用すると、便利になるでしょう。

 書式:
       pause <time> {"<string>"}
       pause mouse {<endcondition>}{, <endcondition>} {"<string>"}

 <time> は、任意の定数または実数値の式です。`pause -1` は改行キーが押さ
 されるまで待ち、0 を指定すると一切待たず、正の数を指定するとその秒数だ
 け待ちます。`pause 0` は `print` と同じです。

 使用している出力形式が `mousing` (マウス機能) をサポートしている場合、
 `pause mouse` は、マウスクリックがあるか ctrl-C が押されるまで待つよう
 になります。そうでない出力形式、またはマウス機能が有効になってない場合
 `pause mouse` は `pause -1` と同じです。

 一つ、あるいは複数の終了条件 (endcondition) が `pause mouse` の後に与
 えられた場合、そのうちのどの一つでも pause は終了します。指定できる終
 了条件は、`keypress`, `button1`, `button2`, `button3`, `close`, `any`
 のいずれかです。pause がキー入力によって終了した場合、押されたキーの
 ASCII コードは MOUSE_KEY に保存され、文字それ自身は、1 文字の文字列値
 として MOUSE_CHAR に返されます。`keypress` が終了条件の一つであれば、
 ホットキー (キー割り当てコマンド) は無効になります。`buttons3` が終了
 条件の一つであれば、拡大機能は無効になります。

 どの場合でもマウスの座標は変数 MOUSE_X, MOUSE_Y, MOUSE_X2, MOUSE_Y2 に
 保存されます。以下参照: `mouse variables`。

 注意: `pause` コマンドは OS へのコマンドであり描画の一部ではないので、
 異なる出力装置では異なる動作をする可能性があります。(これは、テキスト
 とグラフィックスが、どのように混在するかによります。)

 例:
       pause -1    # 改行キーが押されるまで待つ
       pause 3     # 3 秒待つ
       pause -1  "続けるには return を打ってください"
       pause 10  "これは美しくないですか ? 3 次の spline です"
       pause mouse "選択したデータ点上で任意のボタンをクリックしてください"
       pause mouse keypress "有効なウィンドウ内で A-F の文字を入力してください"
       pause mouse button1,keypress
       pause mouse any "任意のキー、ボタンで終了します"

 亜種である "pause mouse key" は、有効な描画ウィンドウ内での任意のキー
 入力によって再開されます。特別なキー入力まで待つようにしたい場合は、以
 下のような reread によるループを使うことができます:

       print "描画ウィンドウ内で Tab キーを打つと復帰します。"
       load "wait_for_tab"

 ファイル "wait_for_tab" は以下のようなものです:

       pause mouse key
       if (MOUSE_KEY != 9) reread

?commands plot
?plot
 `plot` は `gnuplot` で図を描くための基本的なコマンドです。 それは関数
 やデータの、多くの種類のグラフ表現を提供します。`plot` は 2 次元の関数
 やデータを描くのに使われ、`splot` は 3 次元の曲面やデータの 2 次元投影
 を描きます。

 書式:
       plot {<ranges>} <plot-element> {, <plot-element>, <plot-element>}

 各描画要素 (plot-element) は、定義 (definition) か関数 (function) かデ
 ータ (data source) のいずれか 1 つに、オプションの属性、修正子などがつ
 いたものです:
       描画要素 (plot-element):
            {<iteration>}
            <definition> | {sampling-range} <function> | <data source>
                         | keyentry
            {axes <axes>} {<title-spec>}
            {with <style>}

 各描画要素のグラフ表現形式は、例えば `with lines` や `with boxplot` な
 どのようにキーワード `with` で決定します。以下参照: `plotting styles`。

 描画するデータは、1 つの関数から生成されるもの (媒介変数モード
 (parametric) では 2 つの関数から)、または一つのデータファイルから読み
 込まれるもの、または事前に定義された名前付きデータブロックから読み込ま
 れるもの、のいずれかです。コンマで区切ることで、複数のデータファイル、
 データブロック、関数などを 1 つの plot コマンドで描画できます。以下参
 照: `data`, `inline data`, `functions`。

 関数、変数の定義の描画要素は、画像出力を生成しません。下の 3 つ目の例
 を参照してください。

 例:
       plot sin(x)
       plot sin(x), cos(x)
       plot f(x) = sin(x*a), a = .2, f(x), a = .4, f(x)
       plot "datafile.1" with lines, "datafile.2" with points
       plot [t=1:10] [-pi:pi*2] tan(t), \
            "data.1" using (tan($2)):($3/$4) smooth csplines \
                     axes x1y2 notitle with lines 5
       plot for [datafile in "spinach.dat broccoli.dat"] datafile

 以下参照: `show plot`。
?commands plot axes
?plot axes
?axes
 軸 (axes) は、4 種類の組が利用できます; キーワード <axes> は、特定の直
 線をどの軸に尺度を合わせるか、ということを選択するのに使われます。
 `x1y1` は下の軸と左の軸を指定; `x2y2` は上と右の軸の指定; `x1y2` は下
 と右の軸の指定; `x2y1` は上と左の軸の指定です。`plot` コマンドで指定さ
 れた範囲は、この最初の軸の組 (下と左) にのみ適用されます。
?binary
?data binary
?datafile binary
?plot data binary
 バイナリデータファイル:

 ファイル名の後ろに `binary` のキーワードを与えなければいけません。ファ
 イル形式に関する十分詳細な情報は、ユーザがコマンドラインから与えるか、
 またはサポートしている `filetype` のバイナリ形式のファイルそれ自身から
 抜き出されるかする必要があります。バイナリファイルには、大きく 2 つの
 形式、binary matrix 形式と binary general 形式があります。

 `binary matrix` 形式は、32 ビット IEEE 規格の浮動小数値 (float) が 2
 次元配列の形で並び、それらの座標値を表す行と列が追加されています。plot
 コマンドの `using` 指定において、1 番目 (column(1)) は行列の行の座標を
 参照し、2 番目 (column(2)) は列の座標を参照し、3 番目 (column(3)) は、
 配列のそれらの座標の場所に保存されている値を参照します。

 `binary general` 形式は、任意個の列のデータを含み、それらの情報はコマ
 ンドラインで指定する必要があります。例えば `array`, `record`, `format`,
 `using` などでサイズや形式、データの次元を指定できます。他にも、ファイ
 ルヘッダ読み飛ばしたり、エンディアン (endian) を変更するための有用なコ
 マンドがありますし、配置、データの変換を行なうコマンドの組があります。
 それは、一様に標本化されたデータの場合、その座標がファイルには含まれな
 いことが良くあるからです。matrix バイナリファイルやテキストデータから
 の入力と違うところですが、general バイナリは 1,2,3 といった `using` リ
 ストで生成される列番号を使わず、代わりに 1 列目はファイルの 1 列目、あ
 るいは `format` リストで指定されたもの、になります。

 さまざまな binary オプションに対する大域的なデフォルトの設定も可能で、
 それは `(s)plot <filename> binary ...` コマンドに与えるオプションと全
 く同じ書式で指定できます。その書式は `set datafile binary ...` です。
 一般的な規則として、デフォルトのパラメータはファイルから抜き出されたパ
 ラメータで上書きされ、それはコマンドラインで指定された共通なパラメータ
 で上書きされます。

 例えば `array`, `record`, `format`, `filetype` の `binary general` 形
 式を特定するようなキーワードが何もついていなければ、デフォルトのバイナ
 リ形式は `binary matrix` です。

 general バイナリデータは、特別なファイル名 '-' を使ってコマンドライン
 から入力することもできます。しかし、これはキーボードからの入力を意図し
 たものではなく、パイプを使ってプログラムにバイナリ形式を変換させるため
 のものです。バイナリデータには最後を表す記号がありませんので、gnuplot
 はパイプからデータを読み込む場合、`array` 指定子で指定した数の点数にな
 るまでデータを読み込み続けます。詳細に関しては、以下参照:
 `binary matrix`, `binary general`。

 `index` キーワードは、ファイルフォーマットが 1 つのファイルにつき 1 つ
 の曲面しか許さないため、サポートされません。`every` や `using` フィルタ
 はサポートされます。`using` は、データがあたかも上の 3 つ組の形で読まれ
 たかのように働きます。
 バイナリファイルの splot のデモ。
?commands plot binary general
?commands splot binary general
?plot binary general
?splot binary general
?datafile binary general
?data binary general
?binary general
 キーワード `binary` を単独で指定した場合は、非一様な格子を形成する座標
 情報と、各格子点での値の両方を持つバイナリデータであることを意味し (以
 下参照: `binary matrix`)、他の形式のバイナリデータの場合は、そのデータ
 の形式を意味する追加キーワードを指定する必要があります。残念ながら、こ
 れらの追加キーワードの書式は単純ではありませんが、それでも general バ
 イナリモードは、特に多量のデータを gnuplot に送るようなアプリケーショ
 ンに取っては有用です。

 書式:
       plot '<file_name>' {binary <binary list>} ...
       splot '<file_name>' {binary <binary list>} ...

 general バイナリ形式は、ファイル構造に関する情報に関連するキーワード、
 すなわち `array`, `record`, `format`, `filetype` などを <binary list>
 内に与えることで有効になります。それ以外の場合は、非一様な matrix バイ
 ナリ形式と見なします。(詳細に関しては、以下参照: `binary matrix`。)

 注意: 以前の版の gnuplot では、バイナリデータ用のキーワードの解釈に、
 `plot` と `splot` では少し違いがありました。その意味の違う箇所は、今後
 の版の gnuplot では、その一方あるいは両方が変更される可能性があります。

 gnuplot は、例えば PNG 画像のように完全に自己記述される標準的なバイナ
 リファイル形式の読み込み方法をいくつか知っています。その一覧は、対話画
 面で `show datafile binary` と入力することで参照できます。それら以外の
 ものについては、概念上はバイナリデータはテキストデータと同様に考えるこ
 とができます。各点には、`using` 指定で選択される情報の列があります。
 `format` 文字列を指定しなかった場合、gnuplot はバイナリ数値の数を
 `<using list>` で与えられる最大の列番号に等しく取ります。例えば、
 `using 1:3` とすると 3 列ずつデータが読み取られ、2 番目のものは無視し
 ます。各描画スタイルにはデフォルトの using 指定があります。例えば
 `with image` はデフォルトで `using 1` を、`with rgbimage` はデフォルト
 で `using 1:2:3` を使います。
?binary array
 バイナリファイルの標本の配列の大きさを設定します。座標は gnuplot が生
 成してくれます。各方向の次元を表す数を指定しなければいけません。例えば
 `array=(10,20)` は、2 次元で最初の次元方向 (x) には 10 点、2 番目の次
 元方向 (y) には 20 点の標本化データがあることを意味します。ファイルの
 終了までデータが続くことを示すのに負の値を使えます。データ次元が 1 の
 場合は、カッコは省略できます。複数のデータのサイズ指定を分離するのに、
 コロンを使うことができます。例えば `array=25:35` は 2 つの 1 次元デー
 タがファイルの中にあることを意味します。
       注意:  gnuplot バージョン 4.2 では array=(128,128) という書式で
              はなく、array=128x128 という書式を使用していました。古い
              書式は推奨されていません。
?binary record
 このキーワードは `array` と同じ書式で、同じ機能を提供します。しかし
 `record` は gnuplot に座標情報を自動生成させません。これは、そのような
 座標情報が、バイナリデータファイルのある列に含まれている場合のためのも
 のです。
?binary skip
 このキーワードは、バイナリファイルのある区画のスキップを可能にします。
 例えば、そのファイルがデータ領域の開始位置の前に 1024 バイトのヘッダを
 持つような場合には、以下のようにしたいと思うでしょう:
       plot '<file_name>' binary skip=1024 ...
 ファイルに複数のレコードがある場合、そのそれぞれに対する先頭のずらし位
 置を指定することができます。例えば、最初のレコードの前の 512 バイトを
 スキップし、2 番目、3 番目のレコードの前の 256 バイトをスキップするに
 は以下のようにします:
       plot '<file_name> binary record=356:356:356 skip=512:256:256 ...
?binary format
 デフォルトのバイナリ形式は、単精度浮動小数 (float) が一つ、です。それ
 をより柔軟に設定するために、この format で変数のサイズに関する詳細な情
 報を指定できます。例えば `format="%uchar%int%float"` は、最初の using
 列として符号なし文字型変数 (unsigned char) を、2 番目の列は符号つき整
 数 (int) を、3 番目の列は単精度浮動小数 (float) を指定しています。もし
 サイズ指定子の数が最大列数より小さい場合は、残りの列の変数サイズは暗黙
 のうちに最後に与えた変数サイズに等しく取られます。

 さらに `using` 指定同様、`*` 文字がついた読み捨てる列を書式に指定する
 こともできますし、繰り返しフィールドへの回数指定によって暗黙の繰り返し
 を指定することもできます。例えば、`format="%*2int%3float"` は、3 つの
 実数データを読む前に、2 つの整数データを読み捨てます。使用できる変数サ
 イズの一覧は、`show datafile binary datasizes` で見ることができます。
 それらは、それぞれのコンパイルによってそのバイトサイズとともにマシンに
 依存する変数名のグループと、マシンに依存しない変数名のグループに分かれ
 ています。
?binary endian
 ファイルのバイナリデータのエンディアンは、gnuplot が動作するプラットホ
 ームのエンディアンとは異なる場合も良くあります。いくつかの指定で
 gnuplot がバイトをどのように扱うかを制御できます。例えば
 `endian=little` は、バイナリファイルを、そのバイトの並びが小さい桁から
 大きい桁へ並んでいると見なされます。オプションは以下のものが使えます。

               little:  小さい桁から大きな桁へ並ぶ
                  big:  大きな桁から小さな桁へ並ぶ
              default:  compiler と同じエンディアンと見なす
          swap (swab):  エンディアンを変更する (おかしいようならこれを
                        使ってみてください)

 gnuplot は、コンパイル時にオプションが指定されていれば、"middle" (や
 "pdp") エンディアンもサポートできます。
?binary filetype
?filetype
 gnuplot は、いくつか標準的なバイナリファイル形式については必要な情報を
 そのファイルから抜き出すことができます。例えば "format=edf" は ESRF ヘ
 ッダーファイル形式のファイルとして読み込みます。現在サポートしているフ
 ァイル形式については、`show datafile binary filetypes` で見てください。

 特別なファイル形式として `auto` があり、この場合 gnuplot はバイナリフ
 ァイルの拡張子が、サポートされている形式の標準的な拡張子であるかをチェ
 ックします。

 コマンドラインキーワードはファイルから読み取る設定を上書きするのに使わ
 れ、ファイルから読み取る設定はデフォルトの設定を上書きします。以下参照:
 `set datafile binary`。
?binary filetype avs
?filetype avs
?avs
 `avs` は、自動的に認識される画像イメージに対するバイナリファイルの型の
 一つです。AVS は非常単純なフォーマットで、アプリケーション間でやりとり
 するのに最も適しています。これは、2 つの long (xwidth と ywidth) と、
 その後続くピクセルの列から成り、その各ピクセルは alpha/red/green/blue
 の 4 バイトから成ります。
?binary filetype edf
?filetype edf
?edf
?filetype ehf
?ehf
 `edf` は、自動的に認識される画像イメージに対するバイナリファイルの型の
 一つです。EDF は ESRF データフォーマット (ESRF Data Format) を意味して
 いて、それは edf と ehf の両方の形式をサポートしています (後者は ESRF
 Header Format)。画像の使用に関する詳しい情報は以下で見つかるでしょう:

   http://www.edfplus.info/specs
?binary filetype png
?binary filetype gif
?binary filetype jpeg
?filetype png
?filetype gif
?filetype jpeg
 gnuplot が png/gif/jpeg 出力用に libgd ライブラリを使うようにインスト
 ールされている場合、それらの画像形式をバイナリファイルとして読み込むこ
 ともできます。以下のような明示的なコマンド
       plot 'file.png' binary filetype=png
 を使うこともできますし、あらかじめ以下のように設定して、拡張子から自動
 的に画像形式を自動的に認識させることもできます。
       set datafile binary filetype=auto
?binary keywords
 以下のキーワード (keyword) は、バイナリファイルから座標を生成するとき
 にのみ適用されます。つまり、binary array, matrix, image の個々の要素を
 特定の x,y,z の位置への配置の制御のためのものです。
?binary keywords scan
?scan
 gnuplot がバイナリファイルをどのように走査するか、ということと実際の描
 画で見られる軸の方向との間の関係については多くの混乱が起こり得ます。そ
 の混乱を減らすには、gnuplot はバイナリファイルを "常に" 点/線/面、また
 は速い/普通/遅い、と走査すると考えるといいでしょう。このキーワードは
 gnuplot に、その走査の方向を描画内のどの座標方向 (x/y/z) に割り当てる
 かを指定します。指定は 2 つ、または 3 つの文字の並びで表現し、最初の文
 字が点に、次の文字が線に、3 つ目の文字が面に対応します。例えば、
 `scan=yx` は、最も速い走査 (点の選択) は y 方向に対応し、普通の速さの
 走査 (線の選択) が x 方向に対応することを意味します。

 描画モードが `plot` の場合、指定には x と y の 2 つの文字を使うことが
 でき、`splot` に対しては x, y, z の 3 つの文字を使うことができます。

 割り当てに関しては、点/線/面から直交座標方向へのみに制限する内部事情は
 別にありません。この理由で、円柱座標への割り当てのための指定子も用意さ
 れていて、それらは直交座標の x, y, z に類似した形で t (角度), r, z と
 なっています。
?binary keywords transpose
?transpose
 `scan=yx`、または `scan=yxz` と同じです。すなわち、これは入力時の走査
 行のピクセルへの割り当てに影響を与えます。表示する際に画像を転置するに
 は、以下のようにしてみてください:
      plot 'imagefile' binary filetype=auto flipx rotate=90deg with rgbimage
?binary keywords dx
?binary keywords dy
?dx
?dy
 gnuplot が座標を生成する場合、その間隔はこれらのキーワードで指定された
 ものが使用されます。例えば `dx=10 dy=20` は x 方向に 10、y 方向に 20
 の間隔で標本化されたことを意味します。`dy` は `dx` がなければ使えませ
 ん。同様に `dz` は `dy` がなければ使えません。もしデータの次元が指定し
 たキーワードの次元よりも大きい場合、残りの次元方向の間隔は、指定された
 最も高い次元のものと同じ値が使用されます。例えば画像がファイルから読み
 込まれ、`dx=3.5` のみ指定された場合、gnuplot は x 方向の間隔も y 方向
 の間隔も 3.5 を使用します。

 以下のキーワードも座標の生成時にのみ適用されます。しかし、以下のものは
 matrix バイナリファイルにも使われます。
?binary keywords flipx
?flipx
?flipy
?flipz
 バイナリデータファイルの走査方向が gnuplot の走査方向と一致しないこと
 がたまにあります。これらのキーワードは、それぞれ x, y, z 方向のデータ
 の走査方向を逆向きにします。
?binary keywords origin
?binary origin
 gnuplot は転置 (transpose) や反転 (flip) において座標を生成する場合、
 常に配列の左下の点が原点になるようにします。すなわち、データが、転置や
 反転の行なわれた後の直交座標系の第 1 象限に来るようにします。

 配列をグラフのその他の場所に配置したい場合、`origin` キーワードで指定
 した場所に gnuplot は配列の左下の点を合わせます。その指定は、`plot` で
 は 2 つの座標の組、`splot` では 3 つの座標の組を指定してください。例え
 ば `origin=(100,100):(100,200)` は、一つのファイルに含まれる 2 つのデ
 ータに対する指定で、2 次元の描画に対する指定です。2 つ目の例として
 `origin=(0,0,3.5)` をあげると、これは 3 次元描画用の指定です。
?binary keywords center
?keywords center
?center
 `origin` と似ていますが、このキーワードは、配列の中心がこのキーワード
 で指定した点になるように配置します。例えば `center=(0,0)` のようにしま
 す。配列のサイズが `Inf` のときは center は適用されません。
?binary keywords rotate
?keywords rotate
?rotate
 転置 (transpose) と反転 (flip) コマンドは座標の生成と座標軸の方向にあ
 る種の柔軟性を与えてくれます。しかし、角度に関する完全な制御は、2 次元
 の回転角を記述した回転角ベクトルを与えることにより行なうことが可能にな
 ります。

 キーワード `rotate` は, `plot`, `splot` の両方で、2 次元面に対して適用
 されます。回転は座標平面の正の角度に関して行なわれます。

 角度は、ラジアン単位ですが、pi や degrees の倍数としてのラジアンでも表
 現できます。例えば、`rotate=1.5708`, `rotate=0.5pi`, `rotate=90deg` は
 すべて同じ意味です。

 `origin` が指定された場合、回転は平行移動の前に左下の点を中心にして行
 なわれます。それ以外では回転は配列の中心 (`center`) に関して行なわれま
 す。
?binary keywords perpendicular
?perpendicular
 `splot` に関して回転ベクトルの設定が、ベクトルを表現する 3 つの数字の
 組を指定することで実装されていて、このベクトルは 2 次元の xy 平面に対
 して向き付けられた法線ベクトル (perpendicular) を表しています。もちろ
 んそのデフォルトは (0,0,1) です。rotate と perpendicular の両方を指定
 することにより、3 次元空間内で無数の方向へデータを向き付けられることに
 なります。

 まず最初に 2 次元の回転が行なわれ、その次に 3 次元の回転が行なわれます。
 つまり、R' をある角による 2 x 2 の回転行列とし、P を (0,0,1) を
 (xp,yp,zp) へ子午線方向に回転させる 3 x 3 の行列とし、R' を左上の部分
 行列として持ち 3,3 成分が 1 でその他の成分が 0 であるような行列 (つま
 り z 軸周りの回転行列) とすれば、この変換を表す行列による関係式は
 v' = P R v となります。ここで、v はデータファイルから読み込まれた
 3 x 1 の位置ベクトルです。ファイルのデータが 3 次元的なものでない場合
 は、論理的なルールが適用されて 3 次元空間内のデータと見なされます (例
 えば、通常は z 座標は 0 とされ、xy 平面内の 2 次元データと見なされます)。
?commands plot datafile
?plot datafile
?data-file
?datafile
?data
?file
 ファイルに納められた離散的なデータは、`plot` コマンドライン上で、その
 データファイル名 (<datafile>) を単一引用符または二重引用符で囲んで指定
 することによって表示できます。

 書式:
       plot '<file_name>' {binary <binary list>}
                          {{nonuniform} matrix}
                          {index <index list> | index "<name>"}
                          {every <every list>}
                          {skip <number-of-lines>}
                          {using <using list>}
                          {smooth <option>}
                          {bins <options>}
                          {volatile} {noautoscale}

 修正子の `binary`, `index`, `every`, `skip`, `using`, `bins`, `smooth`
 は、それぞれに分けて説明します。簡単に言うと、`binary` はデータ列をバ
 イナリファイルから取得できるようにし、`index` はマルチデータ集合ファイ
 ルからどのデータ集合を表示するのかを選び、`every` が、一つのデータ集合
 からどの点を表示するのかを選び、`using` は一行からどの列を解釈するのか
 を決定し、そして `smooth` が、単純な補間と近似を行います。`bins` は個
 々の入力点を x に沿う等幅の区間に仕分け、各区間に一つだけの累積値を描
 画します。

 `splot` もよく似た書式を使いますが、`smooth` オプションはサポートして
 いません。

 キーワード `noautoscale` は、自動的に軸の範囲が決定される機能が有効で
 ある場合に、この描画を構成するデータ点については、それを無視させる (自
 動縮尺機能の計算対象から外す) ようにします。

 テキストデータファイル:

 データファイルは、一行につき少なくとも一つのデータ点を含む必要がありま
 す (`using` は一行から一つのデータポイントを選ぶことができます)。`#`
 (VMS では `!`) で始まる行は、コメントとして扱われ、無視されます。各デ
 ータ点は、(x,y) の組を表します。エラーバー、または折れ線表示付エラーバ
 ーの `plot` では (以下参照: `errorbars`, `errorlines`)、各データ点は、
 (x,y,ydelta), (x,y,ylow,yhigh), (x,y,xdelta), (x,y,xlow,xhigh),
 (x,y,xlow,xhigh,ylow,yhigh) のいずれかを意味します。

 どんな場合でも、書式の指定子が `using` オプションによって与えられてい
 なければ、データファイルの各行の数字は、ホワイトスペース (一つまたは複
 数の空白かタブ) によって区切られている必要があります。このホワイトスペ
 ースは、各行を列の項目に区切ります。ただし、二重引用符で囲まれたホワイ
 トスペースは列の勘定では無視され、よって次のようなデータ行は 3 列、と
 見なされます:
       1.0 "second column" 3.0

 データは、指数部に e, E の文字をつけた指数表記で書かれていても構いませ
 ん。コマンド `set datafile fortran` が有効な場合は、fortran の指数指定
 子 d, D, q, Q も使えます。

 必要であるのはただ一つの列 (y の値) のみです。もし x の値が省略された
 ら、`gnuplot` はそれを 0 で始まる整数値として用意します。

 データファイルにおいて、ブランク行 (空白と改行、復帰以外に文字を含まな
 い行) は重要です。

 1 行のブランク行は、`plot` に不連続を指示します; ブランク行によって区
 切られた点は線で結ばれることはありません (line style で書かれている場
 合には)。

 2 行のブランク行は、別々のデータ集合間の区切りを示します。以下参照:
 `index`。

 もし autoscale の状態であれば (以下参照: `set autoscale`)、軸は全ての
 データポイントを含むように自動的に引き伸ばされて、目盛りが書かれる状態
 ならば全ての目盛りがマークされます。これは、2 つの結果を引き起こします:
 i) `splot` では、曲面の角は底面の角に一致していないことがあります。こ
 の場合、縦の線は書かれることはありません。ii) 2 種類の軸での、同じ x
 の範囲のデータの表示の際、もし x2 の軸に対する目盛りが書かれていない場
 合は、x 座標があっていないことがあります。これは x 軸 (x1) は全ての目
 盛りにまで自動的に引き延ばされるのに対し、x2 軸はそうではないからです。
 次の例でその問題を見ることができます:

       reset; plot '-', '-' axes x2y1
       1 1
       19 19
       e
       1 1
       19 19
       e

 これを避けるには、`set autoscale` コマンドの `fixmin`/`fixmax` オプシ
 ョンを使うことができます。これは、次の目盛りの刻みに合うように軸の範囲
 を自動的に拡張する機能を無効にします。

 ラベルの座標と文字列もデータファイルから読み込むことができます (以下参
 照: `labels`)。
?commands plot datafile bins
?plot datafile bins
?plot bins
?data-file bins
?datafile bins
?bins
 試験段階の機能 (仕様の細かい部分は、今後の版で変更する可能性あり)。
 書式:
      plot 'DATA' using <XCOL> {:<YCOL>} bins{=<NBINS>}
           {binrange [<LOW>:<HIGH>]} {binwidth=<width>}

 `plot` コマンドに対するオプション `bins` は、最初に元のデータを、x 軸
 上で等しい幅を持ついくつかの箱 (ビン) に割り当て、そして箱毎に一つの値
 のみを描画します。箱の数のデフォルト値は、`set samples` で決定しますが
 これは plot コマンドでビンの数を明示的に指定することで変更できます。

 binrange を指定しないと、範囲は 'DATA' 内の値の両端を取ります。

 箱の幅は、指定した範囲と箱の数から自動的に計算し、各点を 0 から
 NBINS-1 までの箱に割り当てます:
      BINWIDTH = (HIGH - LOW) / (NBINS-1)
      xmin = LOW - BINWIDTH/2
      xmax = HIGH + BINWIDTH/2
      first bin holds points with (xmin <= x < xmin + BINWIDTH)
      最初の箱は (xmin <= x < xmin + BINWIDTH) の範囲の点を保持
      最後の箱は (xmax-BINWIDTH <= x < xman) の範囲の点を保持
      各点は i = floor(NBINS * (x-xmin)/(xmax-xmin)) 番の箱に割り当て

 それとは別に、固定幅の箱を指定することも可能です。その場合、箱の数
 (nbins) は、点の範囲全体にわたる最小の箱の数となります。

 箱の出力は、その中点で描画、または表にされます。例えば gnuplot が上の
 ように箱の幅を計算する場合、最初の箱の x 座標の出力は x=LOW であり、
 x=xmin ではありません。

 using 命令で一つの列のみを指定した場合、各データ点は、その x 座標値に
 対する箱の合計値に 1 だけ寄与します。2 列目を指定すると、その箱の合計
 値には 2 列目の値が追加されます。よって、以下の 2 つの plot コマンドは
 同じになります:
      plot 'DATA" using N bins=20
      set samples 20
      plot 'DATA' using (column(N)):(1)

 関連する描画スタイルに関しては、以下参照: `smooth frequency`,
 `smooth kdensity`。
?commands plot datafile every
?plot datafile every
?plot every
?data-file every
?datafile every
?every
 キーワード `every` は、描画するデータをデータ集合から周期的にサンプリ
 ングすることを可能にします。

 ここでは 「ポイント」はファイル中の 1 つの行によって定義されるデータと
 し、データの「ブロック」は、前後のブロックと空行で区切られる連続した行
 の集合を意味することとします。

 書式:
       plot 'file' every {<ポイント増分>}
                           {:{<ブロック増分>}
                             {:{<開始ポイント>}
                               {:{<開始ブロック>}
                                 {:{<終了ポイント>}
                                   {:<終了ブロック>}}}}}

 描画するデータポイントは、<開始ポイント> から <終了ポイント> まで <ポ
 イント増分> の増加で選び、ブロックは <開始ブロック> から <終了ブロック>
 まで <ブロック増分> の増加で選びます。

 各ブロックの最初のデータは、ファイル中の最初のブロックと同じように、
 「0 番」と数えます。

 プロットできない情報を含む行もカウントすることに注意して下さい。

 いくつかの数字は省略できます; 増分のデフォルトは 1 、開始の値は最初の
 ポイントか最初のブロック、そして終了の値は最後のポイントか最後のブロッ
 クに設定します。`every` のオプションが ':' で終わるのは許されていませ
 ん。`every` を指定しなければ、全ての行の全てのポイントをプロットします。

 例:
        every :::3::3   # 4 番目のブロックだけ選びます (0 番が最初)
        every :::::9    # 最初の 10 ブロックを選びます
        every 2:2       # 1 つおきのブロックで 1 つおきのポイントを選び
                        # ます
        every ::5::15   # それぞれのブロックでポイント 5 から 15 までを
                        # 選びます

 参照:
 単純な plot デモ (simple.dem)
 ,
 非媒介変数モードでの splot デモ
 ,
 媒介変数モードでの splot デモ
 。
?commands plot datafile example
?plot datafile example
?plot example
?datafile example
?data-file example
?example
 次の例は、ファイル "population.dat" 中のデータと理論曲線を図にするもの
 です。

       pop(x) = 103*exp((1965-x)/10)
       set xrange [1960:1990]
       plot 'population.dat', pop(x)

 ファイル "population.dat" は次のようなファイルです。

       # Gnu population in Antarctica since 1965
          1965   103
          1970   55
          1975   34
          1980   24
          1985   10

 binary の例:

       # 2 つの float の値を選択し (2 つ目の値は無意味)、一方を読み捨て、
       # 一つおきの float 値を無限に長く続く 1 次元データとして使用
       plot '<file_name>' binary format="%float%*float" using 1:2 with lines

       # データファイルから座標を生成するのに必要な情報をすべてそのヘッ
       # ダに含んでいる EDF ファイルの場合
       plot '<file_name>' binary filetype=edf with image
       plot '<file_name>.edf' binary filetype=auto with image

       # 3 つの符号なし文字型整数値 (unsigned char) を生の RGB 画像の色
       # 成分として選択し、y 方向は反転させ画像の方向を座標平面上で変更
       # する (左上が原点になるように)。ピクセルの間隔も指定し、ファイ
       # ルには 2 つの画像が含まれていて、そのうち一つは origin で平行
       # 移動する。
       plot '<file_name>' binary array=(512,1024):(1024,512) format='%uchar' \
            dx=2:1 dy=1:2 origin=(0,0):(1024,1024) flipy u 1:2:3 w rgbimage

       # 4 つの別のデータからなり、座標情報もデータファイルに含まれてい
       # る。ファイルは gnuplot が実行されているシステムとは異なるエン
       # ディアンで生成されている。
       splot '<file_name>' binary record=30:30:29:26 endian=swap u 1:2:3

       # 同じ入力ファイルで、今回は 1 番目と 3 番目のレコードをスキップ
       splot '<file_name>' binary record=30:26 skip=360:348 endian=swap u 1:2:3


 以下参照: `binary matrix`。
?commands plot datafile index
?plot datafile index
?plot index
?data-file index
?datafile index
?index
 キーワード `index` は、描画用に複数のデータ集合を持つファイルから、特
 定のデータ集合を選択することを可能にします。

 書式:
       plot 'file' index { <m>{:<n>{:<p>}} | "<name>" }

 データ集合は 2 行の空白で分離されています。`index <m>` は <m> 番目の集
 合だけを選択します; `index <m>:<n>` は <m> から <n> までのデータ集合の
 選択; `index <m>:<n>:<p>` は、<m>, <m>+<p>, <m>+2<p>, など、<p> おきの
 集合を選択し、集合 <n> で終了します。C 言語の添字 (index) の付け方に従
 い、index 0 はそのファイルの最初のデータ集合を意味します。大きすぎる
 index の指定にはエラーメッセージが返されます。<p> を指定し、<n> を空欄
 にした場合、<p> 毎のデータをファイルの最後まで読み込みます。`index` を
 指定しない場合は、ファイルのデータ全体を単一のデータ集合として描画しま
 す。

 例:
       plot 'file' index 4:5

 ファイルの各点に対して、それが含まれるデータ集合の index 値は、疑似列
 `column(-2)` で利用できます。これは、以下に見るように、そのファイル内
 の個々のデータ集合を区別する別の方法を提供します。これは、描画用に 1
 つのデータ集合の選択しかしない場合は `index` コマンドよりも不恰好です
 が、個々のデータ集合に異なる属性を割り当てたい場合にはとても便利です。
 以下参照: `pseudocolumns`, `lc variable`。

 例:
       plot 'file' using 1:(column(-2)==4 ? $2 : NaN)        # とても不恰好
       plot 'file' using 1:2:(column(-2)) linecolor variable # とても便利 !

 `index '<name>'` は、データ集合を名前 '<name>' で選択します。名前はコ
 メント行に書いてデータ集合に割り当てます。コメント文字とそれに続く空白
 をそのコメント行から取り除いて、その結果が <name> から始まっていれば、
 それに続くデータ集合に <name> という名前がつけられて、それを指定できま
 す。

 例:
       plot 'file' index 'Population'

 <name> で始まるすべてのコメントがそれに続くデータ集合の名前になること
 に注意してください。問題を避けるために、例えば '== Popolation ==' や
 '[Population]' などの命名法を選択すると便利でしょう。

?plot datafile skip
?data-file skip
?datafile skip
?skip
 キーワード `skip` は、プログラムにテキストデータファイル (バイナリデー
 タは不可) の先頭の数行をスキップさせます。スキップする行は、`every` キ
 ーワード処理での行数にはカウントしません。`every ::N` はそのファイル内
 のデータのすべてのブロックの先頭をスキップしますが、`skip N` はそのフ
 ァイルの先頭部分の行のみをスキップすることに注意してください。バイナリ
 データファイルに適用される同様のオプションについては、以下参照:
 `binary skip`。
?commands plot datafile smooth
?plot datafile smooth
?plot smooth
?data-file smooth
?datafile smooth
?smooth
?splines
 `gnuplot` は、データの補間と近似を行う汎用的なルーチンをいくつか持っ
 ています。これ `smooth` オプションの中にグループ化されています。より
 洗練されたデータ処理をしたければ、外部においてデータの前処理をするか、
 または適切なモデルで fit を使うのがいいでしょう。

 書式:
       smooth {unique | frequency | fnormal | cumulative | cnormal | bins
                      | kdensity {bandwidth}
                      | csplines | acsplines | mcsplines | bezier | sbezier
                      | unwrap}

 `unique`, `frequency`, `fnormal`, `cumulatie`, `cnormal` は、x 座標に
 関してデータをソートし、そしてその x の値に対する分布のある種の様子を
 描画します。

 spline 系、Bezeir 系のオプションは、データの端と端を結ぶ連続曲線の係数
 を決定します。この曲線は関数グラフと同じ方法、すなわちその値を x 座標
 に沿う同じ幅の区間ごとに選び (以下参照: `set samples`)、それらの点を
 線分でつなぐことで描画します。データ集合が空行や未定義値で切られてい
 る場合、切られていないそれぞれの部分を別々の連続曲線としてつなぎます。
 これらの別々につないだ部分同士は、曲線として切れたり、不連続になった
 りするかもしれません。

 `unwrap` は、データがπより大きなジャンプをしないように、2πの整数倍を
 加える操作をします。

 もし `autoscale` の状態であれば、軸の範囲は元のデータからではなく、そ
 こから作られる最終的な曲線に対して計算されます。

 もし `autoscale` の状態でなく、かつスプライン曲線を生成する場合、その
 スプライン曲線の標本化は、入力データを含むような x の範囲と、
 `set xrange` で定義される固定した横座標の範囲の共通部分の上で行なわれ
 ます。

 要求する平滑化オプションを適用するにはデータの点数が少なすぎる場合は、
 エラーメッセージが表示されます。

 `smooth` オプションは、関数の描画のときには無視されます。
?commands plot datafile smooth acsplines
?plot datafile smooth acsplines
?data-file smooth acsplines
?datafile smooth acsplines
?plot smooth acsplines
?plot acsplines
?smooth acsplines
?acsplines
 `smooth acsplines` オプションは「自然な滑らかなスプライン」でデータを
 近似します。データが x に関して単調にされた後 (以下参照:
 `smooth unique`)、1 つの曲線が、いくつかの 3 次多項式の一部分により区
 分的に構成されます。それらの 3 次式の係数は、個々のデータ点に合うよう
 に求められますが、using 指定によって 3 列目の値が与えられた場合は、そ
 の値で個々の点に重みをつけます。デフォルトは、以下と同じです:
       plot 'data-file' using 1:2:(1.0) smooth acsplines

 性質上、重みの絶対的な大きさは、曲線を構成するのに使われる区分の数を決
 定します。もし重みが大きければ、個々のデータの影響は大きくなり、そして
 その曲線は、隣り合う点同志を自然 3 次スプラインでつないで得られるもの
 に近づきます。もし重みが小さければ、その曲線はより少ない区分で構成され、
 それによってより平滑的になります。その最も極端な場合はただ 1 つの区分
 からなる場合であり、それは全てのデータに重みの付き線形最小 2 乗近似に
 よって作られます。誤差の立場から言えば、平滑さの重みは、その曲線に対す
 る「平滑化因子」によって分割された各点への、統計的な重みと見ることがで
 きます。それにより、そのファイル中の (標準的な) 誤差は平滑さの重みとし
 て使うことができます。

 例:
       sw(x,S)=1/(x*x*S)
       plot 'data_file' using 1:2:(sw($3,100)) smooth acsplines
?commands plot datafile smooth bezier
?plot datafile smooth bezier
?plot smooth bezier
?data-file smooth bezier
?datafile smooth bezier
?plot bezier
?smooth bezier
?bezier
 `smooth bezier` オプションは、n 次 (データ点の個数) のベジェ曲線でデー
 タを近似します。この曲線は両端の点をつなぎます。
?data-file smooth bins
?datafile smooth bins
?smooth bins
 `smooth bins` は `bins` と同じです。以下参照: `bins`。
 関連する描画スタイルに関しては、以下参照: `smooth frequency`,
 `smooth kdensity`。
?commands plot datafile smooth csplines
?plot datafile smooth csplines
?plot smooth csplines
?data-file smooth csplines
?datafile smooth csplines
?plot csplines
?smooth csplines
?csplines
 `smooth csplines` オプションはデータを単調に揃えた後で (以下参照:
 `smooth unique`) 自然 3 次スプライン曲線で引き続く点をつなぎます。
?commands plot datafile smooth mcsplines
?plot datafile smooth mcsplines
?plot smooth mcsplines
?data-file smooth mcsplines
?datafile smooth mcsplines
?plot mcsplines
?smooth mcsplines
?mcsplines
 `smooth mcsplines` オプションは、平滑化された関数が元の点の単調性と凸
 性を保存するような 3 次スプライン曲線で引き続く点をつなぎます。これは、
 外れ値の影響を低減します。
 FN Fritsch & RE Carlson (1980) "Monotone Piecewise Cubic Interpolation",
 SIAM Journal on Numerical Analysis 17: 238-246.
?commands plot datafile smooth sbezier
?plot datafile smooth sbezier
?plot smooth sbezier
?data-file smooth sbezier
?datafile smooth sbezier
?plot sbezier
?smooth sbezier
?sbezier
 `smooth sbezier` オプションは、最初にデータを単調に揃え (以下参照:
 `unique`) そして `bezier` アルゴリズムを適用します。
?commands plot datafile smooth unique
?plot datafile smooth unique
?plot smooth unique
?data-file smooth unique
?datafile smooth unique
?plot unique
?smooth unique
?unique
 `smooth unique` オプションは、データを x 方向に単調にします。同じ x を
 持つデータ点は y の値を平均して一つの点で置き換えます。そしてその結果
 として得られる点を線分で結びます。
?commands plot datafile smooth unwrap
?plot datafile smooth unwrap
?plot smooth unwrap
?data-file smooth unwrap
?datafile smooth unwrap
?plot unwrap
?smooth unwrap
?unwrap
 `smooth unwrap` オプションは、2 つの続く点がπを越える違いが出ないよう
 にデータを修正します: y の値がその範囲を越えるような点に対しては、前の
 点との差がπの範囲に収まるように 2πの整数倍を加えます。この操作は、巻
 き戻しを持つ系の値を時間的に連続にさせるのに有用です。
?commands plot datafile smooth frequency
?plot datafile smooth frequency
?plot smooth frequency
?data-file smooth frequency
?datafile smooth frequency
?plot frequency
?smooth frequency
?frequency
 オプション `smooth frequency` は、データを x に関して単調にします。x
 座標が同じ点は、それらの y の値の合計を y の値として持つ一つの点に置き
 換えます。多くの値のデータのヒストグラムを一定の階級幅 (bin) で描くに
 は、それらの y の値を 1.0 にして、それでその和が同じ階級幅内の点の個数
 を表すようにします。これは、データ 1 列だけを指定した場合は、暗黙のう
 ちに行なわれます。
 例:
      binwidth = <適当な値>  # x の値の各階級幅
      bin(val) = binwidth * floor(val/binwidth)
      plot "datafile" using (bin(column(1))):(1.0) smooth frequency
      plot "datafile" using (bin(column(1))) smooth frequency  # 同上

 以下も参照。
 smooth.dem
?commands plot datafile smooth fnormal
?plot datafile smooth fnormal
?plot smooth fnormal
?data-file smooth fnormal
?datafile smooth fnormal
?plot fnormal
?smooth fnormal
?fnormal
 オプション `smooth fnormal` は、オプション `frequency` と同様の動作を
 しますが、正規化したヒストグラムを生成します。すなわち、データを x に
 関して単調にして、y の値はそのすべての和が 1 になるように正規化します。
 x 座標が同じ点は、それらの y の値の合計を y の値として持つ一つの点に置
 き換えます。多くの値のデータのヒストグラムを一定の階級幅 (bin) で描く
 には、それらの y の値を 1.0 にして、それでその和が同じ階級幅内の点の個
 数を表すようにします。これは、データ 1 列だけを指定した場合は、暗黙の
 うちに行なわれます。以下も参照。
 smooth.dem
?commands plot datafile smooth cumulative
?plot datafile smooth cumulative
?plot smooth cumulative
?data-file smooth cumulative
?datafile smooth cumulative
?plot cumulative
?smooth cumulative
?cumulative
 オプション `smooth cumulative` は、データを x に関して単調にします。x
 座標が同じ点は、それ以下の x の値を持つすべての点 (すなわち現在のデー
 タ点の左側の点) に対する y の値の累積的な合計を y の値として持つ一つの
 点に置き換えられます。これは、データから累積分布関数を得るのに利用でき
 ます。以下も参照。
 smooth.dem
?commands plot datafile smooth cnormal
?plot datafile smooth cnormal
?plot smooth cnormal
?data-file smooth cnormal
?datafile smooth cnormal
?plot cnormal
?smooth cnormal
?cnormal
 オプション `smooth cnormal` は、x に関して単調で、y の値は [0:1] に正
 規化されたデータを生成します。同じ x の値を持つ点が複数ある場合は、そ
 れより小さい x の値を持つすべてのデータ点 (すなわち現在のデータ点より
 も左にある点) の累積和を、すべての y の値の和で割った値を y の値として
 持つような一点のデータに置き変えられます。これは、データから正規化され
 た累積分布関数を得るのに使えます (特に標本点数の異なるデータ集合を比較
 するのに有用です)。
 以下も参照。
 smooth.dem

?commands plot datafile smooth kdensity
?plot datafile smooth kdensity
?plot smooth kdensity
?data-file smooth kdensity
?datafile smooth kdensity
?plot kdensity
?smooth kdensity
?kdensity
 オプション `smooth kdensity` は、ガウス核を用いた、ランダム選択点の核
 密度評価 (滑らかなヒストグラム) を描画する方法の一つです。ガウス核が第
 1 列の各点の位置に置かれ、これらのガウス核すべての和が関数として描画さ
 れます。2 列目の値は、ガウス核の重みとして使用されます。正規化されたヒ
 ストグラムを得るには、これを 1/(点の個数) とすべきです。デフォルトでは、
 gnuplot は正規分布のデータに対して最適となるようなバンド幅を計算し使用
 します。
      default_bandwidth = sigma * (4/3N) ** (0.2)
 これは通常はとても保守的で、すなわち幅広いバンド幅です。バンド幅は、明
 示的に指定することもできます。
      plot $DATA smooth kdensity bandwidth <value> with boxes
 前の描画で使用されたバンド幅は、変数 GPVAL_KDENSITY_BANDWIDTH に保存さ
 れます。
?special-filenames
?commands plot datafile special-filenames
?plot datafile special-filenames
?plot special-filenames
?datafile special-filenames
?special-filenames ++
?special-filenames +
?+
?++
 特別な意味を持つファイル名として、次のものがあります: '', '-', '+',
 '++'

 空のファイル名 '' は、同じ plot コマンド上で、直前の入力ファイルを再び
 使用することを gnuplot に指示します。よって、同じ入力ファイルの 2 つの
 データ列を描画するには以下のようにします:

       plot 'filename' using 1:2, '' using 1:3

 この filename は、この後の plot コマンドでも '' で再利用できますが、
 その場合に `save` すると、コメントとしてその名前を記録するのみです。

 '+' と '++' という特別なファイル名は、`using` 指定の全体と描画スタイル
 にインライン関数を使えるようにするための仕組みです。通常、関数描画はサ
 ンプル点毎に単一の y (または z) の値しか持てません。しかし疑似ファイル
 '+' はそれがあたかも実際の入力ファイルであるように、`using` 指定による
 1 列目の値を標本点として扱い、さらに追加の列の値を指定することも可能で
 す。標本点は、デフォルトでは `set xrange` で設定した範囲全体に渡り、
 `set samples` で制御する標本化に従って取られます。

       plot '+' using ($1):(sin($1)):(sin($1)**2) with filledcurves

 '+' の直前に、独立な標本範囲を指定することもできます。通常の関数描画の
 と同様、独立変数に名前を割り当てることもできます。plot の最初の要素に
 与える場合、標本範囲にはそれを明示するキーワード `sample` を前置する必
 要があります (以下も参照: `plot sampling`)。

       plot sample [beta=0:2*pi] '+' using (sin(beta)):(cos(beta)) with lines

 さらに、`+` の範囲指定には、標本増分を与えることもできます。

       plot $MYDATA, [t=-3:25:1] '+' using (t):(f(t))

 疑似ファイル '++' は、u 方向は `set samples` で制御される点の数、v 方
 向は `set isosamples` で制御される点の数の、標準的な [u,v] 座標の格子
 を生成する 2 列のデータを返します。よって、'++' の描画の前に、urange
 と vrange を設定する必要がありますが、x と y の範囲は自動的に設定され
 るか、または明示的に urange, vrange とは違う値に設定できます。'++' の
 サンプリングでの u, v の使用は、version 5.0 からの変更です。
 例:

       splot '++' using 1:2:(sin($1)*sin($2)) with pm3d
       plot '++' using 1:2:(sin($1)*sin($2)) with image

 `'-'` という特別なファイル名は、データがインラインであることを指示し
 ます。すなわち、データをコマンドの後に続けて指定します。このときはデ
 ータのみがコマンドに続き得ます。よって、`plot` コマンドに対するフィル
 ター、タイトル、ラインスタイルといったオプションは、`plot` のコマンド
 ラインの方に書かないといけません。これは、unix シェルスクリプトにおけ
 る << (ヒアドキュメント)、あるいは VMS DCL における $DECK と同様です。
 そのデータは、それらがファイルから読み込まれたかのように、1 行につき
 1 つずつのデータ点が入力されます。そしてデータの終りは、1 列目の始めに
 文字 "e" を置くことで指示します。

 `'-'` は、データとコマンドを一緒に持つことが有用である場合のためにあり
 ます。例えば、別々のアプリケーションから `gnuplot` にその両方がパイプ
 入力される場合です。例えば、デモファイルの中にはこの機能を使うものがあ
 るでしょう。`index` や `every` のような `plot` のオプションが与えられ
 ていると、それらは使われることのないデータの入力を要求してきます。ごく
 単純な場合を除くすべての場合で、`'-'` からデータを読み込むよりも、最初
 にデータブロックを定義してそれを読み込む方が多分簡単です。以下参照:
 `datablocks`。

 もし、`replot` コマンドで `'-'` を使うなら、あなたは 1 度以上データを
 入力する必要があるでしょう。以下参照: `replot`, `refresh`。繰り返しま
 すが、データブロックを使う方がいいです。

 空のファイル名 ('') は、直前のファイル名が再び使われることを指示しま
 す。これは、

       plot 'ある/とても/長い/ファイル名' using 1:2, '' using 1:3, '' using 1:4

 のようなときに便利です。(もし同じ plot コマンド上で、`'-'` と `''` の
 両方を使用すると、上の例にあるように、インラインデータの 2 つの集合を
 与える必要があります。)

?commands plot datafile piped-data
?plot datafile piped-data
?plot piped-data
?piped-data
?pipes
 popen 関数を持っているシステム上では、データファイルは、'<' で始まるフ
 ァイル名によって、シェルコマンドからパイプ入力することができます。例え
 ば

       pop(x) = 103*exp(-x/10)
       plot "< awk '{print $1-1965, $2}' population.dat", pop(x)

 は、最初の人口の例と同じ情報を描画します。ただし、x 座標は 1965 年か
 らの経過年を表すようになります。この例を実行するときは、上のデータフ
 ァイルのコメント行をすべて削除しなければなりませんが、または上のコマ
 ンドの最初の部分を次のように変えることもできます (コンマに続く部分):

       plot "< awk '$0 !~ /^#/ {print $1-1965, $2}' population.dat"

 このアプローチは最も柔軟性がありますが、`using` キーワードを用いた単純
 なフィルタリングで行うことも可能です。

 fdopen() 関数を持つシステムでは、データを、ファイルかパイプに結びつけ
 られた任意のファイルデスクリプタから読み込むことができます。`n` 番のフ
 ァイルデスクリプタから読み込むには、`'<&n'` としてください。これにより、
 1 回の POSIX shell からの呼び出しの中で、複数のデータファイルからのパ
 イプ入力が容易に行えるようになります:

       $ gnuplot -p -e "plot '<&3', '<&4'" 3<data-3 4<data-4
       $ ./gnuplot 5< <(myprogram -with -options)
       gnuplot> plot '<&5'
?commands plot datafile thru
?plot datafile thru
?plot thru
?data-file thru
?datafile thru
?thru
 キーワード `thru` は非推奨です。

 古い書式:
       plot 'file' thru f(x)

 現在の書式:
       plot 'file' using 1:(f($2))
?commands plot datafile using
?plot datafile using
?plot using
?data-file using
?datafile using
?using
 最もよく使われるデータファイルの修飾子は `using` で、これは入力ファイ
 ルのどの行を描画するのかを指示します。

 書式:
       plot 'file' using <entry> {:<entry> {:<entry> ...}} {'format'}

 format を指定すると、それを C ライブラリ関数 'scanf' に適用してデータ
 ファイルの各行を読みます。そうでなければ、各行はホワイトスペース (スペ
 ースやタブ) で区切られたデータの列 (フィールド) からなるとみなしますが
 以下も参照: `datafile separator`。

 各 <entry> は、入力ファイルの一つのフィールドを選択するための単なる列
 の番号か、一つのデータ集合の最初の行の列のラベルに一致する文字列、カッ
 コで囲まれた数式、xticlabels(2) のようにカッコで囲まない特別な関数、の
 いずれかです。

 そのエントリがカッコで囲まれた数式の場合、N 列目の値を指定するのに関数
 column(N) を使用できます。つまり、column(1) は読み込まれた最初の項目を
 参照し、column(2) は次の項目、といった具合です。column(1), column(2),
 ... の略記として、特別な記号 $1, $2, ... を使用できます。関数
 `valid(N)` で、N 番目の列が有効な数字であるかどうかテストできます。
 入力ファイルの最初の行の各列に、データの値ではなくラベルを持っている場
 合、このラベルを入力列の特定や plot タイトルに使用できます。関数
 column() は、列番号以外にラベルで入力列を選択できます。例えば、データ
 ファイルが以下のような場合:
       Height    Weight    Age
       val1      val1      val1
       ...       ...       ...
 以下の plot コマンドは同じ意味になります:
       plot 'datafile' using 3:1, '' using 3:2
       plot 'datafile' using (column("Age")):(column(1)), \
                    '' using (column("Age")):(column(2))
       plot 'datafile' using "Age":"Height", '' using "Age":"Weight"

 指定文字列が完全に一致する必要がありますし、大文字小文字も区別します。
 列のラベルを plot タイトルに使うには、`set key autotitle columnhead`
 としてください。

 入力データファイルの 1...N という実際の列に加えて、gnuplot は管理情報
 を持ついくつかの "疑似列" を提供します。例えば、$0 または column(0) は、
 データ集合内のそのデータ行の行番号を返します。以下参照:
 `pseudocolumns`。

 <entry> に何も書かなければ、そのエントリのリストの順にデフォルトの値が
 使われます。例えば `using ::4` は、`using 1:2:4` と解釈されます。

 `using` にただ一つのエントリを指定した場合は、その <entry> は y の値と
 して使われ、データ点の番号 (疑似列 $0) が x として使われます。例えば
 "`plot 'file' using 1`" は "`plot 'file' using 0:1`" と同じ意味です。
 `using` に 2 つのエントリを与えた場合、それらは x, y として使われます。
 さらにエントリを追加して、入力からのデータを利用するような描画スタイル
 の詳細については、以下参照: `set style`, `fit`。

 'scanf' 関数では色々なデータ形式の数値入力が使えますが、`gnuplot` は全
 ての入力データを倍精度浮動小数とみなしますから、`gnuplot` では `%lf`
 が本質的に唯一の数値入力指定、ということになります。
 書式文字列には、少なくとも一つ、そして 7 つ以下の、そのような入力指定子
 を入れる必要があります。
 'scanf' は数と数の間にホワイトスペース、すなわち空白、タブ ("\t")、改行
 ("\n")、または改ページ ("\f") があると期待します。それ以外の入力は明示
 的にスキップされるべきです。

 "\t", "\n", "\f" を使うときは単一引用符よりむしろ二重引用符を使うべき
 であることに注意してください。
?commands plot datafile using examples
?plot datafile using examples
?datafile using examples
?using examples
 次の例は、1 番目のデータに対する 2 番目と 3 番目の和の値を plot します。
 書式文字列は、各列データがスペース区切りでなく、コンマ区切りであること
 を指示していますが、同じことが `set datafile separator comma` を指定す
 ることでも可能です。
       plot 'file' using 1:($2+$3) '%lf,%lf,%lf'

 次の例は、より複雑な書式指定でデータをファイル "MyData" から読み込み
 ます。
       plot 'MyData' using "%*lf%lf%*20[^\n]%lf"

 この書式指定の意味は以下の通りです:

       %*lf        数値を無視
       %lf         倍精度浮動小数を読み込む (デフォルトでは x の値)
       %*20[^\n]   20 個の改行以外の文字を無視
       %lf         倍精度浮動小数を読み込む (デフォルトでは y の値)

 3 項演算子 `?:` を使ってデータをフィルタする一つの芸当を紹介します。

       plot 'file' using 1:($3>10 ? $2 : 1/0)

 これは、1 列目のデータに対して、3 列目のデータが 10 以上であるような
 2 列目のデータを plot します。`1/0` は未定義値であり、`gnuplot` は未定
 義の点を無視するので、よって適切でない点は隠されることになります。
 または、あらかじめ定義されている値 NaN を使っても同じことになります。

 カッコで始まっていない限りは定数式を列番号として使うことができます。
 例えば `using 0+(複雑な式)` の様なことができます。そして、その数式は、
 カッコでスタートしていなければ数式の値が一度評価され、カッコでスタート
 していれば個々のデータ点を読み込むためにその値が一度評価される、という
 点が重要です。

 時系列フォーマットデータを使っている場合、その時間のデータは複数の列に
 渡らせることができます。その場合、他のデータの開始位置を計算するとき、
 時間のデータに空白が含まれていることに注意してください。例えば、データ
 行の最初の要素がスペースが埋め込まれた時間データであるならば、y の値は
 3 列目の値として指定されるべきです。

 (a) `plot 'file'` と、(b) `plot 'file' using 1:2`、そして
 (c) `plot 'file' using ($1):($2)` には微妙な違いがあることに注意してく
 ださい。細かい挙動は、バージョン 5 で変更されています。以下参照:
 `missing`。

 最初に単に

       plot 'file' using 1:2

 と指定することで、大抵の場合どんなにゴミのデータを含む行を持つファイル
 をも plot することが可能になります。しかし、どうしてもデータファイルに
 文字列を残しておきたいならば、そのテキスト行の第一列にコメント文字 (#)
 を置く方がより安全でしょう。
?pseudocolumns
?commands plot datafile using pseudocolumns
?plot datafile using pseudocolumns
?datafile using pseudocolumns
?using pseudocolumns
 plot 文の `using` 項目内の式では、入力ファイルに含まれる実際のデータ値
 に加えて管理情報も参照でき、これらは "疑似列" (pseudocolumns) に含まれ
 ています。
       column(0)   データ集合内での各点の順番。順番は 0 から始まり、2
                   行のブランク行でリセットされます。略記 $0 も使用可。
       column(-1)  この番号は 0 から始まり、1 行のブランク行でリセット
                   されます。これは、行列、または格子状データ内のデータ
                   行に対応します。
       column(-2)  複数のデータ集合を持つファイル内の、現在のデータ集合
                   の index 番号。以下参照: `index`。
?xticlabels
?using xticlabels
?plot using xticlabels
 軸の刻みの見出し (ticlabel) は文字列関数によって作ることもでき、それは
 通常は引数としてデータ列から取得します。最も単純な形式は、データ列自身
 の文字列としての利用で、xticlabels(N) は xticlabels(stringcolumn(N))
 の省略形として使えます。以下の例は 3 列目の要素を x 軸の刻みの見出しと
 して使用します。

       plot 'datafile' using <xcol>:<ycol>:xticlabels(3) with <plotstyle>

 軸の目盛りの見出しは、任意の描画軸 x,x2,y,y2,z 用に生成できます。
 `ticlabels(<labelcol>)` 指定は、`using` 指定の中で、そのデータの座標指
 定が全て済んだ後に行う必要があります。有効な X,Y[,Z] 座標の組を持つ各
 データ点に対して、xticlabels() に与える文字列値は、それに対応する点の
 x 座標と同じ場所の x 軸の見出しのリストに追加されます。`xticlabels()`
 は `xtic()` と省略することもでき、他の軸に関しても同様です。

 例:

       splot "data" using 2:4:6:xtic(1):ytic(3):ztic(6)

 この例では、x 軸、y 軸の見出しは x,y 座標値とは別の列から取り出されま
 すが、z 軸の見出しは、対応する点の z 座標値から生成されます。

 例:

       plot "data" using 1:2:xtic( $3 > 10. ? "A" : "B" )

 この例は、x 軸の見出しの生成に文字列値関数を使用したもので、データファ
 イルの各点の x 軸の刻みの見出しは、3 列目の値によって "A" か "B" かの
 いずれかとなります。
?using x2ticlabels
?plot using x2ticlabels
 以下参照: `plot using xticlabels`。
?using yticlabels
?plot using yticlabels
 以下参照: `plot using xticlabels`。
?using y2ticlabels
?plot using y2ticlabels
 以下参照: `plot using xticlabels`。
?using zticlabels
?plot using zticlabels
 以下参照: `plot using xticlabels`。
?datafile volatile
?data volatile
?plot datafile volatile
?plot volatile
?volatile
 plot コマンドのキーワード `volatile` は、入力ストリームかファイルから
 以前に読み込んだデータが、再読み込み時には有効ではないことを意味します。
 これは、`replot` コマンドの代わりに、可能な限り `refresh` コマンド
 を使うよう gnuplot に指示します。以下参照: `refresh`。
?commands plot errorbars
?commands splot errorbars
?plot errorbars
?splot errorbars
 エラーバーは、1 から 4 個の追加されたデータを読む (またはエントリを
 `using` で追加選択する) ことにより、2 次元データの描画において実現され
 ています。これら追加される値は、それぞれのエラーバースタイルで異なった
 形で使われます。

 デフォルトでは、`gnuplot` はデータファイルの各行に以下のような 3 つ、
 4 つ、あるいは 6 つの列があることを期待しています:

       (x, y, ydelta),
       (x, y, ylow, yhigh),
       (x, y, xdelta),
       (x, y, xlow, xhigh),
       (x, y, xdelta, ydelta),
       (x, y, xlow, xhigh, ylow, yhigh)

 x 座標は必ず指定しなければいけません。各数値を書く順序も上で挙げた通りで
 なくてはなりません。ただ、`using` 修飾子を使えばその順序を操作できますし、
 欠けている列の値も補うことは可能ですが。例えば、

       plot 'file' with errorbars
       plot 'file' using 1:2:(sqrt($1)) with xerrorbars
       plot 'file' using 1:2:($1-$3):($1+$3):4:5 with xyerrorbars

 最後の例は、相対的な x の誤差と絶対的な y の誤差、という、サポートされて
 いない組のファイルに対するものです。`using` エントリが相対的な x の誤差
 から絶対的な x の最小値と最大値を生成しています。

 y のエラーバーは、(x, ylow) から (x, yhigh) への鉛直な線として描かれます。
 ylow と yhigh の代わりに ydelta が指定されたときは、ylow = y - ydelta,
 yhigh = y + ydelta となります。ある行にデータが 2 つしかなければ、ylow と
 yhight はともに y となります。x エラーバーは同様に計算された水平線です。
 データの各点を結ぶ折れ線を引きたい場合は、with errorbars と with lines を
 指定して、同じデータファイルを 2 回 `plot` して下さい (ただし、キーの中に
 2 つのエントリを作らないように、その一方には `notitle` オプションを使う
 ことを忘れないで下さい)。他の選択肢として、errorlines コマンドもあります
 (以下参照: `errorlines`)。

 エラーバーの端の刻みの印の見た目は、`set errorbars` で制御できます。

 自動範囲指定が有効であれば、その描画範囲はエラーバーも含むように調整
 されます。

 以下も参照
 エラーバーのデモ

 更なる情報に関しては、以下参照: `plot using`, `plot with`, `set style`。
?commands plot errorlines
?commands splot errorlines
?plot errorlines
?splot errorlines
?errorlines
 誤差線 (errorbar) を伴う線描画は、2 次元データファイルの描画でサポート
 されていて、それは 1 個から 4 個の追加の (または `using` で指定する)
 列データを与えることで行なわれます。これらの追加される値は、様々な
 errorline スタイルのそれぞれで異なった形で使われます。

 デフォルトの状態では、`gnuplot` は、データファイルの各行に 3 個、4 個、
 6 個のいずれかの個数のデータがあることを期待し、それぞれ以下のいずれか
 に対応します。

       (x, y, ydelta),
       (x, y, ylow, yhigh),
       (x, y, xdelta),
       (x, y, xlow, xhigh),
       (x, y, xdelta, ydelta),
       (x, y, xlow, xhigh, ylow, yhigh)

 x 座標は指定する必要がありますし、データの順番も上の形式である必要があ
 りますが、`using` 修飾子でその順番を操作したり、欠けている列に対する値
 を与えたりすることができます。例えば

       plot 'file' with errorlines
       plot 'file' using 1:2:(sqrt($1)) with xerrorlines
       plot 'file' using 1:2:($1-$3):($1+$3):4:5 with xyerrorlines

 最後の例は、相対的な x の誤差と絶対的な y の誤差、というサポートされて
 いない組合せのデータのファイルに対するもので、`using` で相対的な誤差か
 ら絶対的な x の最小値と最大値を生成しています。

 y 誤差線は (x, ylow) から (x, yhigh) へ描画される縦線です。ylow, yhigh
 代わりに ydelta が指定された場合は、ylow = y - ydelta, yhigh = y + ydelta
 と扱われます。ある行に 2 つのデータしかない場合、yhigh, ylow は両方と
 も y になります。x 誤差線は同様の方法で計算される水平線です。

 エラーバーの端の刻みの印の見た目は、`set errorbars` で制御できます。

 自動縮尺 (autoscaling) が ON の場合、描画範囲は誤差線が入るように調整
 されます。

 更なる情報については、以下参照: `plot using`, `plot with`, `set style`。
?commands plot functions
?plot functions
?functions
 コマンド `plot`, `splot` では、ファイルから読み込んだデータの描画だけ
 でなく、組み込み関数やユーザ定義関数を描画することもできます。関数の値
 は、独立な軸の通常の範囲に渡ってデータサンプルを取ることで評価します。
 以下参照: `set samples`, `set isosamples`。

 例:
       approx(ang) = ang - ang**3 / (3*2)
       plot sin(x) title "sin(x)", approx(x) title "approximation"

 関数のデフォルトの描画スタイルを設定する方法については、以下参照:
 `set style function`。組み込み関数の情報については、以下参照:
 `expressions functions`。自前で関数を定義する方法については、以下参照:
 `user-defined`。
?commands plot parametric
?commands splot parametric
?plot parametric
?splot parametric
 媒介変数モード (`set parametric`) では、`plot` では 2 つの数式の組を、
 `splot` では 3 つの数式の組を与える必要があります。

 例:
       plot sin(t),t**2
       splot cos(u)*cos(v),cos(u)*sin(v),sin(u)

 データファイルは前と同じように描画されます。ただし、データファイルが
 描画のために与えられる前に、任意の媒介変数関数が先に完全に指定された
 場合を除いてです。言い換えると、x の媒介変数関数 (上の例では `sin(t)`)
 と y の媒介変数関数 (上の例では `t**2`) との間に、他の修飾子やデータ
 関数をはさみこんではいけません。そのようなことをすると、構文エラーにな
 り、媒介変数関数が完全には指定されていない、と表示されます。

 `with` や `title` のような他の修飾子は、媒介変数関数の指定が完了した
 後に指定しなければいけません。

       plot sin(t),t**2 title 'Parametric example' with linespoints

 以下も参照
 媒介変数モードのデモ。
?commands plot ranges
?commands splot ranges
?plot ranges
?splot ranges
?ranges
 このセクションでは、コマンド `plot` の一番最初の項目として書く、軸の範
 囲のオプションについてのみ説明します。これを指定すると、その範囲は、そ
 れ以前のどの `set range` による範囲の制限よりも優先して扱われます。コ
 マンド `plot` の別な場所に指定する、個々の描画要素の範囲の制限ためのオ
 プションについては以下参照: `sampling`。

 書式:
       [{<dummy-var>=}{{<min>}:{<max>}}]
       [{{<min>}:{<max>}}]

 1 つ目の形式の範囲指定は独立変数の範囲 (`xrange`、または媒介変数モード
 での `trange`) 用で、2 つ目の形式は従属変数の範囲用です。オプションの
 <dummy-var> で独立変数の新しい名前を利用できます (デフォルトの変数名は
 `set dummy` で変更できます)。

 媒介変数モード (parametric) でなければ、範囲指定は以下の順に与えなけれ
 ばいけません:
       plot [<xrange>][<yrange>][<x2range>][<y2range>] ...

 媒介変数モード (parametric) では、範囲指定は以下の順に与えなければいけ
 ません:
       plot [<trange>][<xrange>][<yrange>][<x2range>][<y2range>] ...
 以下の `plot` コマンドは、`trange` を [-pi:pi], `xrange` を [-1.3:1.3],
 `yrange` を [-1:1] に設定する例です:

       plot [-pi:pi] [-1.3:1.3] [-1:1] sin(t),t**2

 `*` は、min (最小値) や max (最大値) に自動範囲指定 (autoscale) の機能
 を使うことを可能にします。指定順番のためだけに必要な範囲指定には、空の
 範囲 `[]` を使ってください。

 `plot` や `splot` のコマンド行で指定された範囲はそのグラフ一つにのみ影
 響を及ぼします。よって、その後のグラフのデフォルトの範囲を変更するには
 `set xrange` や `set yrange` を使用してください。

 リンクされた軸に対しては、plot コマンドでの一時的な範囲指定の使用は、
 期待する結果を生まないかもしれません (以下参照: `set link`)。代わりに
 `set xrange` と `set yrange` の文を別々に指定する方がいいでしょう。

 時間データに対しては、範囲は、データファイルから読み込むのに使用するの
 と同じ書式で、引用符で囲んで指定する必要があります。以下参照:
 `set timefmt`。

 例:

 以下は現在の範囲を使用します:
       plot cos(x)

 以下は x の範囲のみの指定です:
       plot [-10:30] sin(pi*x)/(pi*x)

 以下は上と同じですが、仮変数として t を使います:
       plot [t = -10 :30]  sin(pi*t)/(pi*t)

 以下は x と y の両方の範囲の指定です:
       plot [-pi:pi] [-3:3]  tan(x), 1/x

 以下は、y の範囲のみの指定です:
       plot [ ] [-2:sin(5)*-8] sin(x)**besj0(x)

 以下は x の最大値と y の最小値のみの指定です。
       plot [:200] [-pi:]  $mydata using 1:2

 以下は x の範囲を時系列データとして指定しています:
       set timefmt "%d/%m/%y %H:%M"
       plot ["1/6/93 12:00":"5/6/93 12:00"] 'timedata.dat'

?sampling
?commands plot sample
?plot sample
?plot sampling
?sampling 1D
?plot sampling 1D
 デフォルトでは、関数や疑似ファイル "+" で生成されるデータは、描画範囲
 全体にわたって標本 (サンプル) が取られます。この範囲は、事前にコマンド
 `set xrange` で設定するか、plot コマンドか splot コマンドの最初の場所
 で大域範囲を明示的に指定するかしなければ、そのグラフのすべての要素を含
 む範囲内にデータ全体が入るよう x の範囲を自動縮尺 (autoscaling) します。
 しかし、その標本化範囲は個々の描画要素毎にさらに制限して割り当てること
 もできます。

 例:

 以下は、x 全体の範囲を 0 から 1000 としてファイルのデータを描画し、2
 つの関数を全体の範囲の一部分だけそれぞれ描画します:
       plot [0:1000] 'datafile', [0:200] func1(x), [200:500] func2(x)

 以下は、上とほぼ同様ですが、全体の範囲はデータファイルの内容によって決
 定します。この場合、標本化される関数は、全体がグラフ内に収まるかもしれ
 ませんし、収まらないかもしれません:
       set autoscale x
       plot 'datafile', [0:200] func1(x), [200:500] func2(x)

 以下のコマンドにはあいまいさが含まれます。先頭の範囲は、多分最初の関数
 の標本化のみに向けたのだと思いますが、実際はそうではなく、すべての描画
 要素に適用するように解釈されます:
       plot [0:10] f(x), [10:20] g(x), [20:30] h(x)

 以下のコマンドは、上の例のあいまいさを除くためにキーワード `sample` を
 追加したもので、その範囲指定を plot 全体に適用しないようにしています:
       plot sample [0:10] f(x), [10:20] g(x), [20:30] h(x)

 以下の例は、3 次元グラフにらせんの曲線を描く一つの方法を提示します:
       splot [-2:2][-2:2] sample [h=1:10] '+' using (cos(h)):(sin(h)):(h)

?sampling 2D
?plot sampling 2D
 疑似ファイル '++' に対して計算する関数値や生成されたデータは、u, v 軸
 に沿って標本化 (サンプリング) を行います。これは、5.2 より前のバージョ
 ンからの仕様の「変更」で、従来は x, y 軸に沿って標本化していました。以
 下参照: `special-filenames ++`。2 次元のサンプリングは `plot`, `splot`
 コマンドで使用できます。

 以下は、2 次元の `plot` コマンドに対する 2 次元サンプリングの例です。
 これは、描画スタイル `with vectors` で表示されるグラフを生成します。
 以下参照: `vectors`。
      set urange [ -2.0 : 2.0 ]
      set vrange [ -2.0 : 2.0 ]
      plot '++' using ($1):($2):($2*0.4):(-$1*0.4) with vectors

 以下は 3 次元の `splot` コマンドに対する 2 次元サンプリングの例です。
 これは、`sampling.dem` で使用されているものに似たコマンド列です。この
 2 つの曲面は、生成されるグラフの範囲全体よりも狭い u, v の範囲で標本
 化を行うことに注意してください。
      set title "3D sampling range distinct from plot x/y range"
      set xrange [1:100]
      set yrange [1:100]
      splot sample [u=30:70][v=0:50] '++' using 1:2:(u*v) lt 3, \
            [u=40:80][v=30:60] '++' using (u):(v):(u*sqrt(v)) lt 4

 u, v のサンプリングの範囲指定には、サンプリングデータの数とスペースを
 制御する、明示的なサンプリング間隔を入れることもできます:
      splot sample [u=30:70:1][v=0:50:5] '++' using 1:2:(func($1,$2))

?commands plot for
?commands splot for
?plot for
?splot for
?for loops
 多くの同等のファイルや関数を同時に描画する場合は、それぞれの plot コマ
 ンドの繰り返し (iteration) でそれを行うのが便利です。

 書式:
       plot for [<variable> = <start> : <end> {:<increment>}]
       plot for [<variable> in "string of words"]

 繰り返しの適用範囲 (scope) は、次のコンマ (,) かコマンドの終わり、のい
 ずれか先に現れたところまでです。ただし、描画する項目の前に定義式 (複数
 も可) が並んでいる場合は、コンマが間に入っていてもその例外となります。
  繰り返しは媒介変数モード (parametric) では機能しないことに注意してく
 ださい。

 例:
       plot for [j=1:3] sin(j*x)

 例:
       plot for [dataset in "apples bananas"] dataset."dat" title dataset

 この例では、繰り返しはファイル名と対応するタイトルの生成の両方で使われ
 ています。

 例:
       file(n) = sprintf("dataset_%d.dat",n)
       splot for [i=1:10] file(i) title sprintf("dataset %d",i)

 この例は、ファイル名で生成される文字列値関数を定義し、そのような 10 個
 のファイルを同時に描画します。繰り返しの変数 (この例では 'i') は一つの
 整数として扱われ、それを 2 度以上使用できます。

 例:
       set key left
       plot for [n=1:4] x**n sprintf("%d",n)

 この例は、関数の組を描画します。

 例:
       list = "apple banana cabbage daikon eggplant"
       item(n) = word(list,n)
       plot for [i=1:words(list)] item(i).".dat" title item(i)
       list = "new stuff"
       replot

 この例では、リストに従って各ステップが進行し、その各項目に対して一つの
 描画が行われます。この各項目は動的に取得されますので、そのリストを変更
 し、そのまま replot することができます。

 例:
       list = "apple banana cabbage daikon eggplant"
       plot for [i in list] i.".dat" title i
       list = "new stuff"
       replot

 この例は、整数の繰り返し変数ではなく、文字列の繰り返し変数形式を用いて
 いること以外は前の例と全く同じです。

 <end> の整数の代わりに記号 * を使用すれば、繰り返しはすべての有効なデ
 ータがなくなるまでの繰り返しとなります。これは、各行に含まれるすべての
 列の処理、あるいはファイル内のすべてのデータセット (2 行の空行で区切ら
 れる) の処理、指定に当てはまるすべてのファイルなどを一度に処理するのに
 便利です。

 例:
       plot for [i=2:*] 'datafile' using 1:i with histogram
       splot for [i=0:*] 'datafile' index i using 1:2:3 with lines
       plot for [i=1:*] file=sprintf("File_%03d.dat",i) file using 2 title file

?commands plot title
?commands splot title
?plot title
?splot title
?columnheader
 デフォルトでは各曲線は、対応する関数やファイル名でキーの中に一覧表示さ
 れますが、plot のオプション `title` を使うことで、明示的なタイトルを与
 えることもできます。

 書式:
       title <text> | notitle [<ignored text>]
       title columnheader | title columnheader(N)
             {at {beginning|end}} {{no}enhanced}

 ここで <text> は、引用符で囲まれた文字列か、文字列と評価される式のいず
 れかです。引用符はキーには表示されません。

 入力データの列の最初の項目 (すなわち列の先頭) を文字列フィールドと解釈
 し、それをキータイトルとして利用するオプションもあります。以下参照:
 `datastrings`。これは、`set key autotitle columnhead` を指定すればデフ
 ォルトの挙動となります。

 曲線タイトルとサンプルは予約語 `notitle` を使うことでキーから削除でき
 ます。何もないタイトル (`title ''`) は `notitle` と同じ意味を持ちます。
 サンプルだけが欲しいときは、一つ以上の空白をタイトルの後ろに入れてく
 ださい (`tilte ' '`)。`notilte` の後ろに文字列をつけた場合、その文字列
 は無視されます。

 `key autotitles` が設定されて (デフォルト)、かつ `title` も `notitle`
 も指定されなかった場合、曲線のタイトルは `plot` コマンド上にある関数名
 かデータファイル名になります。ファイル名の場合は、指定される任意のデー
 タファイル修飾子もそのデフォルトタイトルに含まれます。

 位置やタイトルの位置揃えなどの凡例のレイアウトは、`set key` で制御でき
 ます。詳細は、以下参照: `set key`。

 キーワード `at` により、曲線のタイトルを、自動的に作られる key の箱の
 外にでも置くことができるようになります。`at {beginning|end}` を使用し
 た場合は、曲線のタイトルをグラフの曲線自身の直前、あるいは直後に置きま
 す。このオプションは、`with lines` で描画する場合は有用ですが、他の描
 画スタイルでは無意味です。

 `at <x-position>,<y-position>` の形式を使用すれば、曲線のタイトルをペ
 ージ内の任意の位置に置くことができます。デフォルトでは、その位置指定は
 スクリーン座標と解釈します。例えば `at 0.5, 0.5` は、グラフの軸に縮尺
 や境界には関係なく、常にスクリーンのど真ん中を意味します。この方法で配
 置するタイトルの書式は、key のオプション指定の影響を受けます。以下参照:
 `set key`。

 例:

 以下は y=x をタイトル 'x' で表示します:
       plot x

 以下は、x の 2 乗をタイトル "x^2" で、ファイル "data.1" をタイトル
 "measured data" で表示します:
       plot x**2 title "x^2", 'data.1' t "measured data"

 以下は、ファイルの先頭行の各列にタイトルを含む複数列のデータを描画しま
 す。各タイトルは、独立した凡例ではなく、対応する曲線の後ろに置きます:
       unset key
       set offset 0, graph 0.1
       plot for [i=1:4] 'data' using i with lines title columnhead at end

 以下は、2 つの別々のグラフの key の場所を 1 箇所にします:
       set key Left reverse
       set multiplot layout 2,2
       plot sin(x) with points pt 6 title "Left plot is sin(x)" at 0.5, 0.30
       plot cos(x) with points pt 7 title "Right plot is cos(x)" at 0.5, 0.27
       unset multiplot

?commands plot with
?commands splot with
?commands plot style
?commands splot style
?plot with
?plot style
?splot with
?splot style
?style
?with
 関数やデータの表示にはたくさんのスタイルのうちの一つを使うことができます。
 キーワード `with` がその選択のために用意されています。

 書式:
       with <style> { {linestyle | ls <line_style>}
                      | {{linetype  | lt <line_type>}
                         {linewidth | lw <line_width>}
                         {linecolor | lc <colorspec>}
                         {pointtype | pt <point_type>}
                         {pointsize | ps <point_size>}
                         {fill | fs <fillstyle>} {fillcolor | fc <colorspec>}
                         {nohidden3d} {nocontours} {nosurface}
                         {palette}}
                    }


 ここで、<style> は以下のいずれか:

      lines        dots       steps     errorbars     xerrorbar    xyerrorlines
      points       impulses   fsteps    errorlines    xerrorlines  yerrorbars
      linespoints  labels     histeps   financebars   xyerrorbars  yerrorlines
      surface      vectors    parallelaxes
 または、
      boxes         boxplot        ellipses       histograms  rgbalpha
      boxerrorbars  candlesticks   filledcurves   image       rgbimage
      boxxyerror    circles        fillsteps      pm3d        zerrorfill
 または
      table

 最初のグループのスタイルは、線、点、文字の属性を持ち、第 2 のグループ
 のスタイルは、さらに塗り潰し属性も持っています。以下参照: `fillstyle`。
 さらにサブスタイルを持つスタイルもあります。個々のスタイルの詳細につい
 ては、以下参照: `plotting styles`。
 スタイル `table` は、グラフの代わりに表形式の出力を生成します。以下参
 照: `set table`。

 デフォルトのスタイルは、`set style function` と `set style data` で選
 択できます。

 デフォルトでは、それぞれの関数やデータファイルは、使うことができる型の
 最大数に達するまで異なる線種、点種を使います。すべての端末用ドライバは
 最低 6 つの異なる点種をサポートしていて、もしたくさん要求された場合、
 それらを順に再利用していきます。使用中の出力形式での線種、点種の集合全
 体を見たければ、`test` としてください。

 一つの描画で線種や点種を選びたいならば、<line_type> や <point_type> を
 指定してください。これらの値は、その描画で使われる線種や点種を指定する
 正の整定数 (または数式) です。使用する端末で使える線種、点種を表示する
 には `test` コマンドを使ってください。

 描画の線の幅や点の大きさは <line_width> や <point_size> で変更できます。
 これらはその各々の端末のデフォルトの値に対する相対的な値として指定しま
 す。点の大きさは全体に通用するように変更できます。詳細は、以下参照:
 `set pointsize`。しかし、ここでセットされる <point_size> と、
 `set pointsize` でセットされる大きさは、いずれもデフォルトのポイントサ
 イズに掛けられることに注意してください。すなわち、それらの効果は累積は
 しません。例えば、`set pointsize 2; plot x w p ps 3` は、デフォルトの
 サイズの 3 倍であって、6 倍ではありません。

 ラインスタイルの一部分、あるいは各 plot において `pointsize variable`
 という指定も可能です。この場合、入力には追加の 1 列が要求されます。例
 えば 2D 描画では 3 列、3D 描画では 4 列のデータが必要になります。個々
 の点のサイズは、全体を通しての pointsize に、データファイルからの入力
 による値をかけたものとして決定されます。

 `set style line` を使って線種/線幅、点種/点幅の組を定義すれば、そのス
 タイルの番号を <line_style> にセットすることでそれらを使うことができま
 す。

 gnuplot が `pm3d` をサポートするようにインストールされているならば、
 `splot` において lines, points, dots の色を滑らかに変化させるための特
 別なキーワード `palette` が使えます。その色は、コマンド `set palette`
 であらかじめ設定された滑らかに変化するカラーパレットから選択します。色
 の値は、点の z 座標の値か、または `using` で 4 番目のパラメータとして
 指定される色座標に対応します。2 次元、3 次元の描画 (`plot` と `splot`
 コマンド) の両方で、パレット色を小数値かまたはカラーボックスの範囲へ対
 応づけられた値のいずれかで指定することができます。パレット色の値は、
 `using` 指定で明示的に指定された入力列から読み込むことも可能です。
 以下参照: `colors`, `set palette`, `linetype`。

 キーワード `nohidden3d` は、`splot` コマンドで生成される描画にのみ適用
 されます。通常、グローバルなオプション `set hidden3d` はグラフ上の全て
 の描画に適用されますが、各々の描画に `nohidden3d` オプションをつけるこ
 とで、それを hidden3d の処理から除外することができます。`nohidden3d`
 がマークされた曲面以外の個々の描画要素 (線分、点、ラベル等) は、通常は
 他の何らかの描画要素で隠されてしまう場合も全て描画されます。

 同様に、キーワード `nocontours` は、グローバルに `set contour` 指定が
 有効な場合でも、個別の plot に対する等高線描画機能をオフにします。

 同様に、キーワード `nosurface` は、グローバルに `set surface` 指定が有
 効な場合でも、個別の plot に対する 3 次元曲面描画をオフにします。

 キーワードは暗示するような形で省略可能です。

 `linewidth`, `pointsize`, `palette` オプションは全ての端末装置でサポー
 トされているわけではないことに注意してください。

 例:

 以下は、sin(x) を鉛直線で描画します:
       plot sin(x) with impulses

 以下は、x を点で描画し、x**2 をデフォルトの方式で描画します:
       plot x w points, x**2

 以下は、tan(x) を関数のデフォルトの方式で、"data.1" を折れ線で描画します:
       plot [ ] [-2:5] tan(x), 'data.1' with l

 以下は、"leastsq.dat" を鉛直線で描画します:
       plot 'leastsq.dat' w i

 以下は、データファイル "population" を矩形で描画します:
       plot 'population' with boxes

 以下は、"exper.dat" をエラーバー付きの折れ線で描画します (エラーバーは
 3 列、あるいは 4 列のデータを必要とします):
       plot 'exper.dat' w lines, 'exper.dat' notitle w errorbars

 もう一つの "exper.dat" のエラーバー付きの折れ線 (errorlines) での描画
 方法 (エラーバーは 3 列、あるいは 4 列のデータが必要):
       plot 'exper.dat' w errorlines

 以下は、sin(x) と cos(x) をマーカー付きの折れ線で描画します。折れ線は
 同じ線種ですが、マーカーは異なったものを使います:
       plot sin(x) with linesp lt 1 pt 3, cos(x) with linesp lt 1 pt 4

 以下は、"data" を点種 3 で、点の大きさを通常の 2 倍で描画します:
       plot 'data' with points pointtype 3 pointsize 2

 以下は、"data" を描画しますが、4 列目から読んだデータを pointsize の値
 として使用します:
       plot 'data' using 1:2:4 with points pt 5 pointsize variable

 以下は、2 つのデータ集合に対して、幅のみ異なる線を用いて描画します:
       plot 'd1' t "good" w l lt 2 lw 3, 'd2' t "bad" w l lt 2 lw 1

 以下は、x*x の曲線の内部の塗りつぶしと色の帯を描画します:
       plot x*x with filledcurve closed, 40 with filledcurve y=10

 以下は、x*x の曲線と色の箱を描画します:
       plot x*x, (x>=-5 && x<=5 ? 40 : 1/0) with filledcurve y=10 lt 8

 以下は、滑らかに変化する色の線で曲面を描画します:
       splot x*x-y*y with line palette

 以下は、2 つの色のついた曲面を、異なる高さで表示します:
       splot x*x-y*y with pm3d, x*x+y*y with pm3d at t

?commands print
?print
 `print` コマンドは <式> の値を画面に表示します。これは `pause 0` と同
 じです。<式> は、数を生成する `gnuplot` の数式か、または文字列です。

 書式:
         print <式> {, <式>, ...}

 以下参照: `expressions`。出力ファイルは `set print` で設定できます。
 以下も参照: `printerr`。
?commands printerr
?printerr
 `printerr` は print コマンドとほぼ同じですが、その前の `set print` コ
 マンドの効果が続いている状態でも出力を常に stderr に送るところだけが違
 います。
?commands pwd
?pwd
 `pwd` コマンドはカレントディレクトリの名前を画面に表示します。

 カレントディレクトリを文字列変数に保存したり、文字式の中で使いたい場合
 は、変数 GPVAL_PWD を使うことができることに注意してください。以下参照:
 `show variables all`。
?commands quit
?quit
 `exit` と `quit` の両コマンドと END-OF-FILE 文字は、`gnuplot` を終了
 させます。これらのコマンドは、出力装置を (`clear` コマンドと同様に)
 クリアしてから終了させます。
?commands raise
?commands lower
?raise
?lower
 書式:
       raise {plot_window_id}
       lower {plot_window_id}

 コマンド `raise` と `lower` は、出力形式のいくつかにしか機能せず、そし
 てあなたが使用するウィンドウマネージャや表示優先機能の設定にも依存する
 可能性があります。
       set term wxt 123     # 最初の描画ウィンドウを生成
       plot $FOO
       lower                # 存在する描画ウィンドウのみを下に
       set term wxt 456     # 2 つ目を生成 (1 つ目の上にかぶる)
       plot $BAZ
       raise 123            # 1 つ目の描画ウィンドウを上に
 これらのコマンドは、あまり当てにならないと思ってください。
?commands refresh
?refresh
 コマンド `refresh` は、`replot` に似ていますが、主に 2 つの点で違いが
 あります。`refresh` は、既に読み込んだデータを用いて、現在の描画を再整
 形し再描画します。これは、`refresh` を (疑似デバイス '-' からの) イン
 ラインデータの描画、および内容が変化しうるデータファイルからの描画に使
 えるということを意味します。ただし、コマンド `refresh` は、既に存在す
 る描画に新しいデータを追加するのには使えません。

 マウス操作、特にズームインとズームアウトでは、適切な場合は `replot` の
 代わりにむしろ `refresh` を使用します。例:

       plot 'datafile' volatile with lines, '-' with labels
       100 200 "Special point"
       e
       # 色んなマウス操作をここで実行
       set title "Zoomed in view"
       set term post
       set output 'zoom.ps'
       refresh

?commands replot
?replot
 `replot` コマンドを引数なしで実行すると、最後に実行した `plot` または
 `splot` コマンドを再実行します。これは、あるプロットを異なる `set` オ
 プションでみたり、同じプロットを異なる装置に出力したりするときに便利
 でしょう。

 `replot` コマンドに対する引数は最後に実行した `plot` または `splot`
 コマンドの引数に (暗黙の ',' と共に) 追加され、それから再実行されます。
 `replot` は、範囲 (range) を除いては、`plot` や `splot` と同じ引数を
 とることができます。よって、直前のコマンドが `splot` ではなく `plot`
 の場合は、関数をもう一つの軸刻みでプロットするのに `replot` を使うこと
 ができます。

 注意:

       plot '-' ; ... ; replot

 という使い方は推奨されません。それは、これがあなたに再び同じデータすべ
 ての入力を要求することになるからです。たいていの場合、代わりにコマンド
 `refresh` を使えます。これは、以前に読み込んだデータを使ってグラフを再
 描画します。

 `multiplot` モードでは、`replot` コマンドはすべての plot ではなく、直
 前の plot 部分だけしか再実行しないことに注意してください。

 最後に実行した `plot` (`splot`) コマンドの内容を修正する方法については
 以下も参照: `command-line-editing`。

 直前の描画コマンドの全体を表示させることや、それを `history` の中に
 コピーする方法については、以下も参照: `show plot`。
?commands reread
?reread
 `reread` コマンドは、`load` コマンドまたはコマンドラインで指定した
 `gnuplot` のコマンドファイルを、その次のコマンドが読まれる前に、開
 始点に再設定します。これは、コマンドファイルの最初から `reread` コマ
 ンドまでのコマンドの無限ループを本質的に実装していることになります。
 (しかし、これは何も悪いことではありません。`reread` は `if` と組み合
 わせることでとても有用なコマンドとなります。)
 標準入力からの入力の場合は、`reread` コマンドは何も影響を与えません。

 例:

 ファイル "looper" が次のようなファイルで
       a=a+1
       plot sin(x*a)
       pause -1
       if(a<5) reread
 そして、`gnuplot` から次のように実行するとします。
       a=0
       load 'looper'
 すると、pause のメッセージで分割された 5 回のプロットが行われることに
 なります。

 ファイル "data" が、各行に、0 から 10 までの範囲 (yrange) の 6 つのデ
 ータ を持ち、最初が x 座標で、その他は 5 つの異なる関数の、その x での
 値であるとします。そして、ファイル "plotter" が
       c_p = c_p+1
       plot "$0" using 1:c_p with lines linetype c_p
       if(c_p <  n_p) reread
 で、`gnuplot` から次のように実行するとします。
       n_p=6
       c_p=1
       unset key
       set yrange [0:10]
       set multiplot
       call 'plotter' 'data'
       unset multiplot
 すると、5 つのプロットを合わせた 1 つのグラフができます。yrange は、
 multiplot モードで最初のものに続けて書かれる 5 つのグラフが、同じ軸を
 持つように、明示的に指定する必要があります。線種も指定しなければなりま
 せん。さもないと、全てのグラフが同じ線種で書かれることになります。
 アニメーションのサンプルとして、demo ディレクトリの animate.dem も参照
 してください。

?commands reset
?reset
?reset errors
?reset bind
?reset session
 コマンド `reset` は、`set` コマンドで定義できる、グラフに関する全ての
 オプションをデフォルトの値に戻します。このコマンドは、load したコマン
 ドファイルを実行した後でデフォルトの設定を復帰したり、設定をたくさん変
 更した後で元の状態に戻したいときなどに便利です。

 以下のものは、`reset` の影響を受けません。
      `set term` `set output` `set loadpath` `set fontpath` `set linetype`
      `set encoding` `set decimalsign` `set locale` `set psdir` `set fit`
      `set multiplot`

 `reset` は、必ずしもプログラム立ち上がった初期状態には戻さないことに注
 意してください。それは、初期設定ファイル gnuplotrc や $HOME/.gnuplot
 内のコマンドでデフォルトの値を変更した場合は、それもリセットされてしま
 うからです。しかし `reset session` とすれば、それらのコマンドも再実行
 します。

 `reset session` は、ユーザ定義変数、ユーザ定義関数すべてを削除し、デフ
 ォルトの設定を復帰し、システム全体の初期設定ファイル gnuplotrc と個人
 用の初期設定ファイル $HOME/.gnuplot を再実行します。以下参照:
 `initialization`。

 `reset errors` は、エラー状態変数 GPVAL_ERRNO と GPVAL_ERRMSG のみをク
 リアします。

 `reset bind` は、キー定義をデフォルトの状態に復帰します。
?commands save
?save set
?save
?save fit
 書式:
       save  {functions | variables | terminal | set | fit} '<filename>'

 どれも指定しなかった場合は、`gnuplot` は、ユーザ定義関数、変数、set で
 設定するオプション、最後に実行した `plot` (または `splot`) コマンドの
 全てを保存します。

 `save` は、テキスト形式で出力します。また、このファイルは `load` コマ
 ンドで読み込むことができます。`set` オプション付き、または何もオプショ
 ンをつけずに `save` を実行した場合、`terminal` の選択と `output` のフ
 ァイル名はコメント記号つきで書き出されます。これはその出力ファイルを
 他の環境にインストールされた gnuplot 上で動かす場合に、修正なしに使え
 るようにする、あるいはうっかりファイルを上書きしてしまったりする危険性
 を避ける、といった意味があります。

 `save terminal` は、`terminal` の状態を、コメント記号をつけずに書き出
 します。これは主に、ちょっとの間だけ `terminal` の設定を入れ替え、その
 後保存しておいた `terminal` の状態を読み込むことで以前の terminal の設
 定に戻す場合などに役立ちます。ただ、単一の gnuplot セッションでは、現
 在の terminal を保存/復元する他の方法であるコマンド `set term push` と
 `set term pop` を使う方がむしろいいかもしれません。以下参照:
 `set term`。

 `save fit` は、直近の `fit` コマンドで使用した変数のみを保存します。そ
 の保存ファイルは、後で `via` キーワードを使うことで fit コマンドの初期
 化用のパラメータファイルとして利用できます。

 ファイル名は引用符に囲われていなければなりません。

 特別なファイル名 "-" により `save` コマンドに標準出力に出力させること
 ができます。popen 関数をサポートするようなシステム (Unix など) では、
 save の出力をパイプ経由で他の外部プログラムに渡すことができます。その
 場合、ファイル名としてコマンド名の先頭に '|' をつけたものを使います。
 これは、`gnuplot` とパイプを通して通信するプログラムに、`gnuplot` の内
 部設定に関する首尾一貫したインターフェースを提供します。詳細は、以下参
 照: `batch/interactive`。

 例:
       save 'work.gnu'
       save functions 'func.dat'
       save var 'var.dat'
       save set 'options.dat'
       save term 'myterm.gnu'
       save '-'
       save '|grep title >t.gp'
?commands set
?commands show
?set
?show
?show all
 `set` コマンドは実に多くのオプションを設定するのに使われます。しかし、
 `plot`, `splot`, `replot` コマンドが与えられるまで何も表示しません。

 `show` コマンドはそれらの設定値を表示します。`show all` でそれら全て
 を表示します。

 `set` コマンドで変更されたオプションは、それに対応する `unset` コマン
 ドを実行することでデフォルトの状態に戻すことができます。以下も参照:
 `reset`。これは全てのパラメータの設定をデフォルトの値に戻します。

 `set` と `unset` コマンドには繰り返し節も利用できます。以下参照:
 `plot for`。

?commands set angles
?commands show angles
?set angles
?show angles
?angles
?commands set angles degrees
?set angles degrees
?angles degrees
?degrees
 デフォルトでは `gnuplot` は極座標グラフの独立変数の単位はラジアンを仮定
 します。`set polar` の前に `set angles degrees` を指定すると、その単位
 は度になり、デフォルトの範囲は [0:360] となります。これはデータファイル
 の描画で特に便利でしょう。角度の設定は、`set mapping` コマンドを設定す
 ることにより 3 次元でも有効です。

 書式:
       set angles {degrees | radians}
       show angles

 `set grid polar` で指定される角度も、`set angles` で指定した単位で読まれ
 表示されます。

 `set angles` は組み込み関数 sin(x), cos(x), tan(x) の引数や asin(x),
 acos(x), atan8x), atan2(x), arg(x) の出力にも影響を与えます。双曲線関
 数や、ベッセル関数の引数には影響を与えません。しかし、複素数を引数とす
 る逆双曲線関数の出力には影響が出ます。それらの関数が使われるときは、
 `set angles radians` は入出力の引数の間に一貫性を持った管理を実現して
 いなければなりません。

       x={1.0,0.1}
       set angles radians
       y=sinh(x)
       print y         #{1.16933, 0.154051} と表示
       print asinh(y)  #{1.0, 0.1} と表示
 しかし、
       set angles degrees
       y=sinh(x)
       print y         #{1.16933, 0.154051} と表示
       print asinh(y)  #{57.29578, 5.729578} と表示
 以下も参照
 poldat.dem: `set angles` を用いた極座標描画のデモ
?commands set arrow
?commands unset arrow
?commands show arrow
?set arrow
?unset arrow
?show arrow
?arrow
?noarrow
 `set arrow` コマンドを使うことにより、グラフ上の任意の位置に矢印を表示
 することができます。

 書式:
       set arrow {<tag>} from <position> to <position>
       set arrow {<tag>} from <position> rto <position>
       set arrow {<tag>} from <position> length <coord> angle <ang>
       set arrow <tag> arrowstyle | as <arrow_style>
       set arrow <tag> {nohead | head | backhead | heads}
                       {size <headlength>,<headangle>{,<backangle>}} {fixed}
                       {filled | empty | nofilled | noborder}
                       {front | back}
                       {linestyle | ls <line_style>}
                       {linetype | lt <line_type>}
                       {linewidth | lw <line_width>}
                       {linecolor | lc <colorspec>}
                       {dashtype | dt <dashtype>}

       unset arrow {<tag>}
       show arrow {<tag>}

 タグ <tag> は各矢印を識別する整数です。タグを指定しない場合は、その時
 点で未使用の最も小さい数が自動的に割り当てられます。タグを使うことで、
 特定の矢印を変更したり、削除したりできます。既に存在する矢印の属性を変
 更する場合は、タグを明示した `set arrow` コマンドで変更箇所を指定して
 ください。

 矢印の最初の端点の位置は、常に "from" で指定しますが、もう一つの端点は
 以下で説明する 3 つの異なる仕組みのいずれかで指定できます。<position>
 は  x,y あるいは x,y,z で指定します。そしてその前に座標系を選択するた
 めに `first`, `second`, `graph`, `screen`, `character` を置くことがで
 きます。座標を指定しなければデフォルトでは 0 と見なされます。詳細は以
 下参照: `coordinates`。最初の端点に対する座標指定子は、2 番目の端点に
 は影響しません。

 1) "to <position>" は、もう一つの端点の絶対座標を指定します。

 2) "rto <position>" は、"from" の位置からのずれを指定します。この場合、
 線形軸 (非対数軸)、および `graph`, `screen` 座標に対しては、始点と終点
 の距離が与えられた相対的な値に対応します。一方、対数軸に対しては、与え
 られた相対的な値は、始点から終点への倍数に対応します。よって、対数軸の
 場合、相対的な値として 0 や負の値を与えることは許されません。

 3) "length <coordinate> angle <angle>" は、グラフ平面内での矢印の方向
 を指定します。length には任意の座標系を適用できます。angle の単位は常
 に度になっています。

 矢印の他の属性も、あらかじめ定義した矢のスタイルで、またはコマンド
 `set arrow` でそれぞれ与えることが可能です。矢印の他の属性の詳細につい
 ては以下参照: `arrowstyle`。

 例:

 原点から (1,2) への矢印をユーザ定義済のラインスタイル 5 で描くには:
       set arrow to 1,2 ls 5

 描画領域の左下角から (-5,5,3) へタグ番号 3 の矢印を描くには:
       set arrow 3 from graph 0,0 to -5,5,3

 矢印の端を 1,1,1 に変更し、矢先を外して幅を 2 にするには:
       set arrow 3 to 1,1,1 nohead lw 2

 x=3 の所へグラフの下から上まで鉛直線を描くには:
       set arrow from 3, graph 0 to 3, graph 1 nohead

 T 字型の矢先を両端に持つ鉛直方向の矢を描くには:
       set arrow 3 from 0,-5 to 0,5 heads size screen 0.1,90

 始点からの相対的な距離をグラフ座標で与えて矢を描くには:
       set arrow from 0,-5 rto graph 0.1,0.1

 x の対数軸に相対的な終点を指定して矢を描く場合:
       set logscale x
       set arrow from 100,-5 rto 10,10
 これは 100,-5 から 1000,5 までの矢を描きます。線形軸 (y) に対しては相
 対的な座標 10 が "差 10" を意味するのに対し、対数軸 (x) に対しては相対
 的な座標 10 は "倍数 10" として働きます。

 2 番の矢印を消すには:
       unset arrow 2

 全ての矢印を消すには:
       unset arrow

 全ての矢印の情報を (タグの順に) 見るには:
       show arrow

 矢印のデモ

?commands set autoscale
?commands unset autoscale
?commands show autoscale
?set autoscale
?unset autoscale
?show autoscale
?autoscale
?noautoscale
 自動縮尺機能 (autoscale) は x, y, z の各軸に対して独立に、または一括し
 て指定できます。デフォルトでは全ての軸に対して自動縮尺設定を行います。
 図の中の一部の描画 (`plot`) の組のみを元に autoscale したい場合は、そ
 の対象でない `plot` にフラグ `noautoscale` をつけることができます。
 以下参照: `datafile`。

 書式:
       set autoscale {<axes>{|min|max|fixmin|fixmax|fix} | fix | keepfix}
       set autoscale noextend
       unset autoscale {<axes>}
       show autoscale

 ここで、<axes> (軸) は `x`, `y`, `z`, `cb`, `x2`, `y2`, `xy` のいずれ
 かです。`min` または `max` を軸に追加指定すると (`xy` では使えませんが)
 それは `gnuplot` にその軸の最小値、または最大値のみを自動縮尺させるこ
 とになります。軸も何も指定されていない場合は全ての軸が対象となります。

 自動縮尺機能を使うときは、描画範囲は自動的に割り出され、従属変数軸
 (`plot` のときは y 軸、`splot` のときは z 軸) は、関数やデータの値域が
 収まるように設定されます。

 従属変数軸 (y または z) の自動縮尺機能が指定されていない場合は、現在の
 y や z の描画範囲がそのまま使われます。

 独立変数軸 (`plot` のときは x 軸、`splot` のときは x,y 軸) の自動縮尺
 機能が指定されている場合は、描画される全てのデータファイルの点が収まる
 ように定義域をとるようになります。データファイルが 1 つも指定されてい
 ない場合は、自動縮尺機能はなんの効果もありません。つまり、関数のみが
 指定されていてデーターファイルを使わない場合は、x 軸の描画範囲
 (z = f(x,y) を描画しているときは y 軸も) は影響をうけません。

 範囲に関するより詳しい情報に関しては、以下参照: `set xrange`。

 媒介変数モード (parametric) でも自動縮尺機能は有効です (以下参照:
 `set parametric`)。この場合、より多くの従属変数があるので、x, y, z 各
 軸に関して、より多くの制御が行われます。媒介変数モードでの独立変数 (仮
 変数) は `plot` では t で `splot` では u, v です。そして媒介変数モード
 では、自動縮尺機能は (t, u, v, x, y, z) の全ての描画範囲を制御し、x,
 y, z の範囲の自動設定を完全に行います。

 目盛りが第 2 の軸に表示され、しかもこれらの軸に対する描画が行われなか
 った場合には、x2range と y2range は xrange と yrange の値を受け継ぎま
 す。これは、範囲のずらしの実行や、範囲を整数個の目盛り幅に自動伸縮する
 「前」に行いますので、場合によって予期しない結果をもたらす可能性があり
 ます。これを避けるのに、第 2 軸の範囲を第 1 軸の範囲に明示的にリンク
 (link) する方法があります。以下参照: `set link`。
?set autoscale noextend
?set autoscale keepfix
?set autoscale fix
?noextend
?keepfix
?fix
      set autoscale noextend

 デフォルトでは、自動縮尺機能は軸の範囲の限界を、描画データ全体を含む、
 最も近い目盛りラベル位置に設定します。キーワード `fixmin`, `fixmax`,
 `fix`, `noextend` は、次の目盛り位置までの範囲の自動拡大を gnuplot に
 行わせないようにします。その場合軸の範囲の限界は、一番端にあるデータ点
 の座標値に完全に一致します。`set autoscale noextend` は、
 `set autscale fix` と同じです。軸の範囲指定コマンドの後ろにキーワード
 `noextend` を追加すれば、一つの軸の範囲の延長機能だけ無効にすることも
 できます。例:
      set yrange [0:*] noextend

 `set autoscale keepfix` は、fix の設定を変更せずに残したまま、すべての
 軸を自動縮尺にします。
?autoscale examples
?set autoscale examples
 例:

 以下は y 軸の自動縮尺機能を指定します (他の軸には影響を与えません):
       set autoscale y

 以下は y 軸の最小値に対してのみ自動縮尺機能を指定します (y 軸の最大値、
 および他の軸には影響を与えません):
       set autoscale ymin

 以下は x2 軸の隣の目盛りへの自動範囲拡大機能を無効にし、よって描画デー
 タ内、または関数に対する丁度の描画範囲を維持します:
       set autoscale x2fixmin
       set autoscale x2fixmax

 以下は x, y 両軸の自動縮尺機能を指定します:
       set autoscale xy

 以下は x, y, z, x2, y2 全軸の自動縮尺機能を指定します:
       set autoscale

 以下は x, y, z, x2, y2 全軸の自動縮尺機能を禁止します:
       unset autoscale

 以下は z 軸のみについて自動縮尺機能を禁止します:
       unset autoscale z
?commands set autoscale polar
?set autoscale polar
 極座標モード (`set polar`) では、xrange と yrange は自動縮尺モードでは
 なくなります。動径軸の範囲制限用に `set rrange` を使用した場合、xrange
 と yrange はそれに合うように自動的に調整されます。しかし、さらにそれを
 調整したければ、その後に明示的に xrange や yrange コマンドを使うことが
 できます。以下参照: `set rrange`。

 以下も参照
 極座標のデモ。
?commands show bind
?show bind
 `show bind` は、現在のホットキーの割り当て (binding) を表示します。以
 下参照: `bind`。
?commands set bmargin
?set bmargin
?bmargin
 コマンド `set bmargin` は、下部の余白のサイズを設定します。詳細は
 以下参照: `set margin`。
?commands set border
?commands unset border
?commands show border
?set border
?set border polar
?unset border
?show border
?border
?noborder
 `set border` と `unset border` は `plot` や `splot` でのグラフの枠の
 表示を制御します。枠は必ずしも軸とは一致しないことに注意してください。
 `plot` では大抵一致しますが、`splot` では大抵一致していません。

 書式:
       set border {<integer>}
                  {front | back | behind}
                  {linestyle | ls <line_style>}
                  {linetype | lt <line_type>} {linewidth | lw <line_width>}
                  {linecolor | lc <colorspec>} {dashtype | dt <dashtype>}
                  {polar}
       unset border
       show border

 `set view 56,103` のように任意の方向で表示されうる `splot` では、 x-y
 平面上の 4 つの角は 手前 (`front`), 後ろ (`back`) , 左 (`left`), 右
 (`right`) のように呼ばれます。もちろんこの同じ 4 つの角は天井の面にも
 あります。よって、例えば x-y 平面上の後ろと右の角をつなぐ境界を
 "底の右後ろ (bottom right back)" と言い、底と天井の手前の角をつなぐ境
 界を "鉛直手前 (front vertical)" と呼ぶことにします (この命名法は、読
 者が下の表を理解するためだけに使われます)。

 枠は、12 ビットの整数に符号化されています: 下位 4 ビットは `plot` に対
 する外枠、`splot` に対しては底面の外枠、次の 4 ビットは `splot` の鉛直
 な外枠、そして上位 4 ビットは `splot` の天井面の外枠を制御します。よっ
 て外枠の設定は、次の表の対応する項目の数字の和になります:

          ビット     plot        splot
               1      下      底の左手前
               2      左      底の左後ろ
               4      上      底の右手前
               8      右      底の右後ろ
              16    効果なし  鉛直左
              32    効果なし  鉛直後ろ
              64    効果なし  鉛直右
             128    効果なし  鉛直手前
             256    効果なし  天井の左後ろ
             512    効果なし  天井の右後ろ
            1024    効果なし  天井の左手前
            2048    効果なし  天井の右手前
            4096    極座標系  効果なし


 デフォルトの設定値は 31 で、これは `plot` では 4 方向の外枠全て、
 `splot` では底面の枠線全部と z 軸を描くことを意味します。

 2 次元描画では境界はすべての描画要素の一番上に描かれます (`front`)。
 もし境界を描画要素の下に描かせたい場合は、`set border back` としてくだ
 さい。

 3 次元隠線処理 (hidden3d) 描画では、通常は境界を構成する線も描画要素と
 同様に隠線処理の対象になります。`set border behind` とするとこのデフォ
 ルトの挙動が変わります。

 <linestyle>, <linetype>, <linewidth>, <linecolor>, <dashtype> を指定し
 て、枠線の描画にそれらを反映させることができます (現在の出力装置がサポ
 ートするものに限定されます)。
 さらに、軸の刻み (tics) を描画する際も、それらを境界線上で描画するか、
 軸上で描画するかに関わらず、このラインスタイルを使用します。

 `plot` では、第 2 軸を有効にすることで、下と左以外の境界に目盛りを描く
 ことができます。詳細は、以下参照: `xtics`。

 "`unset surface; set contour base`" などによって `splot` で底面にのみ
 描画する場合、鉛直線や天井はそれらが指定されていても描画されません。

 `set grid` のオプション 'back', 'front', 'layerdefault' でも、描画出力
 の境界線を書く順番を制御できます。

 キーワード `polar` は、極座標グラフに円形の境界をつけます。

 例:

 以下は、デフォルトの枠線を描きます:
       set border

 以下は、`plot` では左と下、`splot` では底面の左手前と左後ろの枠線を描
 きます:
       set border 3

 以下は、`splot` で周りに完全な箱を描きます:
       set border 4095

 以下は、手前の鉛直面と天井のない箱を描きます:
       set border 127+256+512 # または set border 1023-128

 以下は、`plot` に対して上と右枠線のみを描き、それらを軸として目盛りづ
 けします:
       unset xtics; unset ytics; set x2tics; set y2tics; set border 12

?commands set boxwidth
?commands show boxwidth
?set boxwidth
?show boxwidth
?boxwidth
 コマンド `set boxwidth` は `boxes`, `boxerrorbars`, `boxplot`,
 `candlesticks`, `histograms` スタイルにおける棒のデフォルトの幅を設定
 するために使います。

 書式:
       set boxwidth {<width>} {absolute|relative}
       show boxwidth

 デフォルトでは、隣り合う棒が接するように各々の棒の幅が広げられます。そ
 れとは異なるデフォルトの幅を設定するには `set boxwidth` コマンドを使用
 します。`relative` の場合の幅は、デフォルトの幅に対する比であると解釈
 されます。

 修飾子 `relative` を指定しなかった場合、棒の幅 (boxwidth) として指定さ
 れた明示的な値は、現在の x 軸の単位での数字 (`absolute`) であると解釈
 されます。x 軸が対数軸 (以下参照: `set log`) である場合、boxwidth の値
 は実際には x=1 でのみ "絶対的" となり、その物理的な長さが軸全体を通じ
 て保持されます (すなわち、棒は x 座標の増加にともなって狭くなったりは
 しません)。対数軸の x 軸の範囲が x=1 から離れている場合は、適切な幅を
 見出すには何度か試してみる必要があるかも知れません。

 デフォルトの値は、`boxes` や `boxerrorbars` スタイルの幅指定用の追加の
 データ列の明示的な値があればそれによって置き換えられます。4 列のデータ
 の場合、第 4 列目の値が棒の幅として使われます。ただし、その幅が -2.0
 の場合には棒の幅は自動計算されます。詳細は、以下参照: `style boxes`,
 `style boxerrorbars`。

 棒の幅を自動的にセットするには
       set boxwidth

 とする、あるいは 4 列のデータに対しては以下のようにします。
       set boxwidth -2

 `plot` のキーワード `using` を使っても同じ効果を得ることができます:
       plot 'file' using 1:2:3:4:(-2)

 棒の幅を自動的な値の半分にするには
       set boxwidth 0.5 relative

 棒の幅を絶対的な値 2 にするには
       set boxwidth 2 absolute
?commands set color
?set color
 gnuplot は、2 つの異なる線種群をサポートしています。デフォルトでは、個
 々の線種に異なる色を使用しますが、その色で点線や破線を描くこともできま
 す。もう一つは白黒の線種で、点線/破線パターンや線幅のみで線種を区別し
 ます。コマンド `set color` はカラーの線種を選択します。以下参照:
 `set monochrome`, `set linetype`, `set colorsequence`。
?commands set colorsequence
?set colorsequence
?colorsequence
 書式:
      set colorsequence {default|classic|podo}

 `set colorsequence default` は、出力形式に依存しない 8 色の巡回列を選
 択します。以下参照: `set linetype`, `colors`。

 `set colorsequence classic` は、出力形式別にそのドライバが用意する線色
 の列を選択します。色の種類は、4 色から 100 色超まで幅がありますが、そ
 の多くは、赤、緑、青、紫、水色、黄色、で始まります。これが以前の版の
 gnuplot のデフォルトの挙動です。

 `set colorsequence podo` は、Wong (2011) [Nature Methods 8:441] で推奨
 されている、P 型、D 型 (Protanopia, Deuteranopia) の色弱者が容易に区別
 できる 8 色の組を選択します。

 いずれの場合でも、色列の長さとその色についてはさらにカスタマイズできま
 す。以下参照: `set linetype`, `colors`。
?commands set clabel
?commands unset clabel
?commands show clabel
?set clabel
?unset clabel
?show clabel
?clabel
 このコマンドは非推奨です。代わりに `set cntrlabel` を使用してください。
 `unset clabel` は `set cntrlabel onecolor` に、`set clabel "format"`
 は `set cntrlabel format "format"` に置き換わっています。
?commands set clip
?commands unset clip
?commands show clip
?set clip
?unset clip
?show clip
?clip
 書式:
       set clip {points|one|two}
       unset clip {points|one|two}
       show clip

 デフォルトの状態:
       unset clip points
       set clip one
       unset clip two

 グラフ領域の境界内に中心があるデータ点は、その点を表す記号のサイズがそ
 の記号を境界線の外にはみだしてしまうような場合でも、通常は描画します。
 `set clip points` は、2 次元描画でそのような点の中心がグラフ領域内にあ
 る場合でも、そのような点をクリッピングします (つまり描画しません)。点
 の中心がグラフ領域外にあるようなデータ点は、決して描画しません。

 線分については、その一方の端点が描画範囲 (xrange と yrange) の外にある
 場合は、通常その線分は描画しません。
 `set clip one` は、一方の端点が描画範囲の外にある線分の範囲内の部分を
 描画するように `gnuplot` に指示します。
 `set clip two` は、両方の端点が描画範囲の外にある線分の範囲内の部分を
 描画するように `gnuplot` に指示します。
 線分全体が描画範囲外であるような線分は決して描画しません。

 注意:

 * `set clip` は、描画スタイル `lines`, `linespoints`, `points`,
 `vectors` で生成される点、線分のみに影響します。

 * `pm3d` の 2 次元射影や曲面で使用する色長方形のクリッピングは、
 `set pm3d clip1in` と `set pm3d clip4in` で行います。

 * オブジェクトのクリッピングは、個々のオブジェクト (object) の
 `{clip|noclip}` 属性で制御します。

?commands set cntrlabel
?commands show cntrlabel
?set cntrlabel
?show cntrlabel
?cntrlabel
 書式:
       set cntrlabel {format "format"} {font "font"}
       set cntrlabel {start <int>} {interval <int>}
       set contrlabel onecolor

 `set cntrlabel` は、凡例内 (デフォルト) か、`splot ... with labels` の
 際のグラフ上の等高線のラベルを制御します。後者の場合、ラベルはラベル記
 述属性の `pointinterval` か `pointnumber` に従って各等高線に沿って配置
 されます。デフォルトではラベルは等高線を構成する 5 番目の線分の上に置
 かれ、20 個の線分毎に繰り返されます。このデフォルトは、以下と同じです:
       set cntrlabel start 5 interval 20
 これらの値はコマンド `set cntrlabel` で、あるいは `splot` コマンドに間
 隔を指定することで変更できます:
       set contours; splot $FOO with labels point pointinterval -1
 間隔を負の値に設定すると、ラベルは各等高線に 1 つだけつきます。しかし
 `set samples` か `set isosamples` が大きな値の場合は多くの等高線をラベ
 ル一つだけで描きます。

 凡例 (key) には、等高線ラベルをそれぞれの線種 (linetype) を使用して書
 きます。デフォルトでは、線種自身が各等高線のレベルを与えるので、それぞ
 れに対する別々のラベルが現れます。コマンド `set cntrlabel onecolor` は
 すべての等高線を同じ線種で描画するので、凡例には一つのラベルのみを書き
 ます。このコマンドは、古いコマンド `unset clabel` を置き換えるものです。
?commands set cntrparam
?commands show cntrparam
?set cntrparam
?show cntrparam
?cntrparam
 `set cntrparam` は等高線の生成方法、およびそれを滑らかに描画する方法を
 制御します。`show contour` は現在の `contour` の設定だけでなく `cntrparam`
 の設定をも表示します。

 書式:
       set cntrparam { { linear
                       | cubicspline
                       | bspline
                       | points <n>
                       | order <n>
                       | levels { <n>
                                  | auto {<n>}
                                  | discrete <z1> {,<z2>{,<z3>...}}
                                  | incremental <start>, <incr> {,<end>}
                                }
                         {{un}sorted}
                         {firstlinetype N}
                       }
                     }
       show cntrparam

 このコマンドは 2 つの機能を持っています。一つは等高線上の点を決めるた
 めの z の値の設定です。等高線のレベルの数 <n> は整数型の定数式でなけれ
 ばいけません。<z1>, <z2> ... は実数値の数式です。
 もう一つは、個々の等高線の見た目の制御です。

 等高線の平滑化を制御するキーワード:

 `linear`, `cubicspline`, `bspline` --- 近似 (補間) 方法を指定します。
 `linear` ならば、等高線は曲面から得られた値を区分的に直線で結びます。
 `cubicspline` (3 次スプライン) ならば、区分的な直線はいくぶんなめらか
 な等高線が得られるように補間されますが、多少波打つ可能性があります。
 `bspline` (B-spline) は、より滑らかな曲線を描くことが保証されますが、
 これは z の等しい点の位置を近似しているだけです。

 `points` --- 最終的には、全ての描画は、区分的な直線で行われます。ここ
 で指定する数は、`bspline` または `cubicspline` での近似に使われる線分
 の数を制御します。実際には cubicspline と bspline の区間 (曲線線分) の
 数は `points` と線分の数の積に等しくなります。

 `order` --- bspline 近似の次数です。この次数が大きくなるにつれて、等高
 線はなめらかになります (もちろん、高次の bspline 曲線になるほど、元の
 区分的直線からは離れていきます)。このオプションは `bspline` モードでの
 み有効です。指定できる値は、2 (直線) から 10 までの整数です。

 等高線レベルの選択を制御するキーワード:

 `levels auto` --- これがデフォルトです。<n> は仮のレベルの数であり、実
 際のレベルの数は、簡単なラベルを生成するように調節されます。曲面の z
 座標が zmin から zman の範囲にあるとき、等高線はその間の dz の整数倍に
 なるように生成されます。ここで、dz は 10 のあるべき乗の 1, 2, 5 倍、の
 いずれかです (2 つの目盛りの間を丁度割り切るように)。

 `levels discrete` --- 等高線は指定された z = <z1>, <z2> ... に対して生
 成されます。指定した個数が等高線のレベルの個数となります。`discrete`
 モードでは、`set cntrparams levels <n>` という指定は常に無視されます。

 `levels incremental` --- 等高線は z = <start> から始まり、<increment>
 ずつ増えて行き限界の個数に達するまで書かれます。<end> はその等高線の数
 を決定するのに使われますが、これは後の `set cntrparam levels <n>` によ
 って常に変更されます。z 軸が対数軸の場合、`set ztics` の場合と同様に、
 <increment> は倍数として解釈され、<end> は使用しません。

 等高線の線種の割り当てを制御するキーワード:

 デフォルトでは、等高線は指定の逆順に生成します (`unsorted`)。すわなち、
 `set cntrparam levels increment 0, 10, 100` は、100 から始まって、0 で
 終わる 11 本の等高線を作ります。キーワード `sorted` を追加すると、数値
 の増加方向の順の生成に変更し、例えば今の例では、最初に 0 の等高線を書
 くようになります。

 デフォルトでは、等高線は、対応する曲面に使用した線種の、次からの線種列
 で描きます。すなわち、`splot x*y lt 5` の最初の等高線は線種 6 です。
 `hidden3d` モードが有効な場合、各曲面には 2 つの線種を使うので、デフォ
 ルトの設定では、最初の等高線と曲面の裏面の描画に同じ線種を使ってしまい
 ますが、これは望ましくありません。これを避けるには、以下の 2 つの方法
 があります。
 (1) `set hidden3d offset N` により、曲面の裏面の線種を変更すること。
 `offset -1` とするのがいいですが、これならすべての等高線の線種とぶつか
 りません。
 (2) オプション `set cntrparam firstlinetype N` により、曲面で使用する
 線種とは独立な、等高線で使用する線種群を指定すること。これは、特に等高
 線の線種をカスタマイズしたい場合には有用でしょう。N <= 0 の場合はデフ
 ォルトに戻ります。

 コマンド `set cntrparam` を引数無しで使用すると、指定したすべてのオプ
 ション値をデフォルトにリセットします。
       set cntrparam order 4 points 5
       set cntrparam levels auto 5 unsorted
       set cntrparam firstlinetype 0

?commands set cntrparam examples
?set cntrparam examples
?cntrparam examples
 例:
       set cntrparam bspline
       set cntrparam points 7
       set cntrparam order 10

 以下はレベルの基準が合えば 5 個のレベルがに自動的に選択されます:
       set cntrparam levels auto 5

 以下は .1, .37, .9 にレベルを設定します:
       set cntrparam levels discrete .1,1/exp(1),.9

 以下は 0 から 4 まで、1 ずつ増やすレベルを設定します:
       set cntrparam levels incremental  0,1,4

 以下はレベルの数を 10 に設定します (増加の最後の値 (end) または自動で
 設定されるレベルの数は変更されます):
       set cntrparam levels 10

 以下はレベルの数は保持したままレベルの開始値と増分値を設定します:
       set cntrparam levels incremental 100,50

 以下はカスタマイズした等高線の線種群を定義し、使用します:
       set linetype 100 lc "red" dt '....'
       do for [L=101:199] {
           if (L%10 == 0) {
               set linetype L lc "black" dt solid lw 2
           } else {
               set linetype L lc "gray" dt solid lw 1
           }
       }
       set cntrparam firstlinetype 100
       set cntrparam sorted levels incremental 0, 1, 100

 等高線を描く場所の制御に関しては、以下参照: `set contour`。等高線のラ
 ベルの書式と線種の制御に関しては、以下参照: `set cntrlabel`。

 以下も参照してください。
 等高線のデモ (contours.dem)
 および
 ユーザ定義レベルの等高線のデモ (discrete.dem).
?commands set colorbox
?commands show colorbox
?commands unset colorbox
?set colorbox
?show colorbox
?unset colorbox
?colorbox

 色の一覧表、すなわち `pm3d` の `palette` の min_z から max_z までの滑
 らかな色の勾配は、`unset colorbox` が使われていない限りカラーボックス
 (colorbox) に描かれます。

       set colorbox
       set colorbox {
                  { vertical | horizontal } {{no}invert}
                  { default | user }
                  { origin x, y }
                  { size x, y }
                  { front | back }
                  { noborder | bdefault | border [line style] }
                }
       show colorbox
       unset colorbox

 カラーボックスの位置は、`default` または `user` で指定でき、後者の場合
 その位置や大きさを `origin` や `size` コマンドで設定します。カラーボッ
 クスは、グラフや曲面の後 (`front`) あるいは先 (`back`) に描画させるこ
 ともできます。

 色勾配の方向は、オプション `vertical` と `horizontal` で切替えることが
 可能です。

 `origin x, y` と `size x, y` は `user` オプションとの組でのみ使用され
 ます。x, y の値は、デフォルトではスクリーン座標と解釈されますが、これ
 は 3 次元描画用のかしこまったオプションに過ぎません。`set view map` に
 よる splot を含む 2 次元描画では、任意の座標系での指定が可能です。例え
 ば以下を試してみてください:
     set colorbox horiz user origin .1,.02 size .8,.04
 これは水平方向の色勾配をグラフの下の辺りに描画します。

 `border` は境界描画を ON にします (デフォルト) し、`noborder` は境界描
 画を OFF にします。`border` の後ろに正の整数を与えると、それを境界を描
 画する時の line style のタグとして使います。例えば:
     set style line 2604 linetype -1 linewidth .4
     set colorbox border 2604
 は line style `2604`、すなわち細い線のデフォルトの境界色 (-1) で境界を
 描画します。`bdefault` (デフォルト) は、カラーボックスの境界の描画にデ
 フォルトの境界の line style を使います。

 カラーボックスの軸は `cb` と呼ばれ、通常の軸のコマンドで制御されます。
 すなわち `set/unset/show` で `cbrange`, `[m]cbtics`, `format cb`,
 `grid [m]cb`, `cblabel` などが、そして多分 `cbdata`, `[no]cbdtics`,
 `[no]cbmtics` なども使えるでしょう。

 パラメータ無しの `set colorbox` はデフォルトの位置へ切替えます。
 `unset colorbox` はカラーボックスのパラメータをデフォルト値にリセット
 し、その上でカラーボックスを OFF にします。

 以下も参照: `set pm3d`, `set palette`, `x11 pm3d`, `set style line`。
?colornames
?show colornames
?commands show colornames
?show palette colornames
 gnuplot は限定された個数の色の名前を持っています。これらは、pm3d パレ
 ットでつながれる色の範囲を定義するのに、あるいは個々の線種やラインスタ
 イルの色を出力形式に依存しない形で定義したりするのに使えます。gnuplot
 の持つ色名の一覧を見るには、コマンド `show colornames` を使用してくだ
 さい。例:

       set style line 1 linecolor "sea-green"
?commands set contour
?commands unset contour
?commands show contour
?set contour
?unset contour
?show contour
?contour
?contours
?nocontour
 コマンド `set contour` は曲面の等高線を引くことを指示します。このオプ
 ションは `splot` でのみ有効です。これは、格子状データ (grid data) を必
 要とします。詳細は、以下参照: `grid_data`。非格子状データで等高線を描
 きたい場合は、格子を生成するために `set dgrid3d` を使用します。

 書式:
       set contour {base | surface | both}
       unset contour
       show contour

 これらの 3 つのオプションは等高線をどこに引くかを指定します。`base` で
 は等高線を x/y 軸の刻みのある底面に描かれ、`surface` では等高線はその
 曲面自体の上に描かれ、`both` では底面と曲面上の両方に描かれます。オプ
 ションが指定されていない場合は `base` であると仮定されます。

 等高線の描画に影響を与えるパラメータについては、以下参照:
 `set cntrparam`。等高線のラベルの制御に関しては、以下参照:
 `set cntrlabel`。

 等高線のみのグラフを得るために、曲面自身の描画をしないようにすることも
 できます (以下参照: `unset surface`)。`set size` を使って、グラフを画
 面一杯に描画することも可能ですが、そういった出力形式よりも、等高線のデ
 ータをデータブロックに書き出し、それを再び 2 次元データとして読み込ん
 で描画すればよりよい制御が可能になります:

       unset surface
       set contour
       set cntrparam ...
       set table $datablock
       splot ...
       unset table
       # 等高線の情報は今 $datablock の中にある
       set term <whatever>
       plot $datablock

 等高線を描くためには、データは格子状データ ("grid data") である必要が
 あります。そのようなファイルでは、一つの y-孤立線上の全ての点が順に
 並べられていきます。そして隣の y-孤立線上の点が順に並べられ、そして隣、
 と続いていきます。y-孤立線同士を分離するには一行の空行 (空白、復帰、改
 行以外の文字を含まない行) を挟みます。

 `set contour` が有効な場合、`splot with <style>` で points, lines,
 impulses, labels 等の描画要素を等高線に沿って配置できます。`with pm3d`
 は、pm3d 曲面を生成し、さらに等高線も書きます。
 `set contour` が有効な際に生成する等高線に、ファイルから読み込んだラベ
 ルなどのその他の描画要素も混ぜたい場合は、splot コマンド内のその命令の
 後ろにキーワード `nocontours` を追加しないといけません。

 以下参照: `splot datafile`。

 以下も参照してください。
 等高線のデモ (contours.dem)
 および
 ユーザ定義レベルの等高線のデモ (discrete.dem).
?commands set dashtype
?commands show dashtype
?set dashtype
?show dashtype
 コマンド `set dashtype` は、点線/破線パターンを番号で参照できるように
 登録します。これはとても便利で、その点線/破線パターンをその番号で受け
 つけてくれる場所ならば、どこでも明示的な点線/破線パターンも受けつけて
 くれます。
 例:
      set dashtype 5 (2,4,2,6)   # 5 番の dashtype を定義または再定義
      plot f1(x) dt 5            # その dashtype を使って plot
      plot f1(x) dt (2,4,2,6)    # 上と全く同じグラフ
      set linetype 5 dt 5        # このパターンを linetype 5 で常に使う
      set dashtype 66 "..-"      # 文字列で新しい dashtype を定義
 以下参照: `dashtype`。
?set data style
 このコマンドの形式は現在は推奨されていません。以下参照:
 `set style data`。
?set datafile
?show datafile
 コマンド `set datafile` は、`plot`, `splot`, `fit` コマンドで入力デー
 タを読む場合に、その列 (field) の解釈の仕方を制御するオプションを持ち
 ます。現在は、6 つのそのようなオプションが実装されています。
?set datafile fortran
?show datafile fortran
?fortran
 コマンド `set datafile fortran` は、入力ファイルの Fortran D 型、Q 型
 の定数値の特別なチェックを可能にします。この特別なチェックは入力処理を
 遅くしますので、実際にそのデータファイルが Fortran D 型、Q 型の定数を
 持っている場合にのみこれを選択すべきです。このオプションは、その後で
 `unset datafile fortran` を行えば無効にできます。
?set datafile nofpe_trap
?fpe_trap
?nofpe_trap
 コマンド `set datafile nofpe_trap` は、入力ファイルからデータの読み込
 みの際に、すべての数式の評価の前に浮動小数点例外ハンドラの再初期化をし
 ないように gnuplot に命令します。これにより、とても大きなファイルから
 のデータの入力がかなり速くなりますが、浮動小数点例外が起きた場合にプロ
 グラムが異常終了してしまう危険はあります。
?set datafile missing
?show datafile missing
?set missing
?missing
 書式:
       set datafile missing "<string>"
       set datafile missing NaN
       show datafile missing
       unset datafile

 コマンド `set datafile missing` は、入力データファイル中で欠損データを
 記述する特別な文字列があることを `gnuplot` に指示します。`missing` に
 関するデフォルト値 (文字) はありません。gnuplot は「欠損データ」と「無
 効な値」(例えば "NaN" や 1/0) を区別します。例えば、連続するデータ点に
 対するグラフの折れ線描画は、無効な値によってそこで切れますが、欠損デー
 タの場合はそうではありません。

 数値が期待される場面で数値ではない文字が現れた場合は、それが `missing`
 で指定する文字列にマッチする場合を除いて、通常欠損データではなく、無効
 な値として解釈します。

 逆に、`set datafile missing NaN` とすると、数式やデータ中の数値ではな
 い値 (NaN) はすべて欠損データとして扱います。

 `注意`: ある場合の欠損データと無効な値の扱いは、現在のバージョンの
  gnuplot では変更されています。以下の例で、gnuplot バージョン 4 とバー
 ジョン 5 での違いを示します。
 例:
       set style data linespoints
       plot '-' title "(a)"
          1 10
          2 20
          3 ?
          4 40
          5 50
          e
       set datafile missing "?"
       plot '-' title "(b)"
          1 10
          2 20
          3 ?
          4 40
          5 50
          e
       plot '-' using 1:2 title "(c)"
          1 10
          2 20
          3 NaN
          4 40
          5 50
          e
       plot '-' using 1:($2) title "(d)"
          1 10
          2 20
          3 NaN
          4 40
          5 50
          e

 (a) のグラフは、3 行目には有効な値がひとつしかないため、gnuplot 4 と
 gnuplot 5 で違いがあります。バージョン 4 では、そこに 1 行に 1 つしか
 データがなかった場合の規則を適用し、行番号を "x" に、データを "y" と見
 なし、誤ってその点を (2,3) に描画していました。

 文字 '?' が欠損データを意味するものとして指定されている (b) では、古い
 版の gnuplot でも新しい版でも同じデータを正しく処理します。

 (c), (d) のグラフに見られるように、古い gnuplot では NaN を using の指
 定の仕方によって異なった処理をしていました。現在は、gnuplot は入力列と
 して N と指定されていても ($N) と指定されていても NaN に対しては同じ処
 理を行います。以下のデモも参照してください。
 imageNaN デモ。
 同様に、plot コマンドで `using N`、`using ($N)`、`using (func($N))` の
 いずれを使う場合でも、今の gnuplot は列 N に欠損値フラグを通知します。
 しかし、「欠損値」がかなり複雑な数式の評価中に出てきた場合、例えば
 `using (column(strcol(1))` などの場合は、それを NaN と評価し、欠損デー
 タ点ではなく不正データとして取り扱う可能性があります。その場合でもこれ
 を欠損値として扱いたければ、コマンド `set datafile missing NaN` を使用
 してください。
?set datafile separator
?show datafile separator
?datafile separator
?separator
 コマンド `set datafile separator` は、この後の入力ファイルのデータ列の
 分離文字が、空白 (whitespace) でなくて、ここで指定する文字であると
 `gnuplot` に指示します。このコマンドの最も一般的な使用例は、表計算ソフ
 トやデータベースソフトが作る csv (コンマ区切り) ファイルを読む場合でし
 ょう。デフォルトのデータ列の分離文字は空白 (whitespace) です。

 書式:
       set datafile separator {whitespace | tab | comma | "<chars>"}

 例:
       # タブ区切りのファイルを入力
       set datafile separator "\t"

       # コンマ区切りのファイルを入力
       set datafile separator comma

       # 入力ファイルが * か | のいずれかで区切られた列を持つ場合
       set datafile separator "*|"
?set datafile commentschars
?commentschars
 コマンド `set datafile commentschars` は、データファイル中のコメント行
 の開始文字としてどの文字を使うかを指定します。指定した文字の中の一つが
 データ行の最初の非空白文字として現われた場合、そのデータ行のそれ以降の
 部分を無視します。デフォルト文字列は、VMS では "#!"、それ以外では "#"
 です。

 書式:
       set datafile commentschars {"<string>"}
       show datafile commentschars
       unset commentschars

 よって、データファイルの以下の行は完全に無視されます:
     # 1 2 3 4
 が、以下の行
     1 # 3 4
 は、2 列目にゴミがあり、その後に有効なデータが 3 列目と 4 列目にあると
 認識されます。

 例:
       set datafile commentschars "#!%"
?set datafile binary
 コマンド `set datafile binary` は、データファイルの読み込み時にバイナ
 リファイルをデフォルトと設定するのに使われます。書式は、それが `plot`
 または `splot` コマンドで使われるのと正確に同じです。<binary list> に
 書けるキーワードに関しては、詳しくは、以下参照: `binary matrix`,
 `binary general`。

 書式:
       set datafile binary <binary list>
       show datafile binary
       show datafile
       unset datafile

 例:
       set datafile binary filetype=auto
       set datafile binary array=(512,512) format="%uchar"

?show datafile binary
       show datafile binary   # 現在の設定の一覧表示
?commands set decimalsign
?commands show decimalsign
?commands unset decimalsign
?set decimalsign
?show decimalsign
?unset decimalsign
?decimalsign
 コマンド `set decimalsign` は、目盛りの見出し、あるいは `set label` 文
 字列に書かれる数の小数点記号を選択します。

 書式:
       set decimalsign {<value> | locale {"<locale>"}}
       unset decimalsign
       show decimalsign

 引数 <value> は、通常の小数点記号に置き換えて使う文字列です。典型的な
 ものはピリオド '.' やコンマ ',' ですが他にも有用なものがあるでしょう。
 引数 <value> を省略すると、小数点の区切りはデフォルト (ピリオド) から
 変更されません。unset decimalsign も <value> を省略するのと同じ効果を
 持ちます。

 例:

 多くのヨーロッパ諸国での正しい出力形式を得るには:
       set decimalsign ','

 次のことに注意してください: 明示的な文字列を設定した場合、これは軸の目
 盛りなどの gnuplot の gprintf() 書式関数で出力される数値のみに影響し、
 入力データの書式指定や sprintf() 書式関数で出力される数値には影響しま
 せん。それらの入力や出力の形式の挙動も変更したい場合は、代わりに以下を
 使用してください:

       set decimalsign locale

 これは、gnuplot に、入力と出力の書式を、環境変数 LC_ALL, LC_NUMERIC,
 LANG の現在の設定に従ったものを使わせるようにします。

       set decimalsign locale "foo"

 これは、gnuplot に、入力と出力の書式を、ロケール "foo" に従ったものに
 しますが、そのロケールがインストールされている必要があります。もしロケ
 ール "foo" が見つからなかった場合、エラーメッセージが出力され、小数点
 の設定は変更されません。linux システム上では、そこにインストールされて
 いるロケールの一覧は "locale -a" で見ることができます。linux のロケー
 ル文字列はだいたい "sl_SI.UTF-8" のような形式をしていますが、Windows
 のロケール文字列は "Slovenian_Slovenia.1250"、または "slovenian" のよ
 うな形式です。ロケール文字列の解釈は、C のランタイムライブラリが行うこ
 とに注意してください。古い C ライブラリでは、ロケール設定のサポート
 (例えば数字の 3 桁毎の区切り文字など) を部分的にしか提供していないかも
 しれません。

       set decimalsign locale; set decimalsign "."

 これは、現在のロケールに合ったどんな小数点でも、全ての入出力に対して使
 用するように設定しますが、gnuplot の内部関数 gprintf() を使って書式化
 する数値は明示的に指定された '.' になります (上書き)。
?commands set dgrid3d
?commands unset dgrid3d
?commands show dgrid3d
?set dgrid3d
?unset dgrid3d
?show dgrid3d
?dgrid3d
?nodgrid3d
 コマンド `set dgrid3d` は、非格子状データから格子状データへの写像機能を
 有効にし、そのためのパラメータを設定します。格子状データの構造について
 の詳細は、以下参照: `splot grid_data`。

 書式:
       set dgrid3d {<rows>} {,{<cols>}}
                   { splines |
                     qnorm {<norm>} |
                     (gauss | cauchy | exp | box | hann)
                       {kdensity} {<dx>} {,<dy>} }
       unset dgrid3d
       show dgrid3d

 デフォルトでは `dgrid3d` は無効になっています。有効になると、ファイル
 から読み込まれる 3 次元のデータは「散在した」データ (非格子状データ)
 であると見なされます。格子は、グラフと等高線の描画のために、散在したデ
 ータを囲む矩形から得られる寸法と、row_size/col_size で指定される数の行
 と列を持つように生成されます。格子は x 方向 (行) と y 方向 (列) に等間
 隔です。z の値は散在するデータの z の値の重み付きの平均、またはスプラ
 イン補間として計算されます。言い変えれば、規則的な間隔の格子が生成され、
 全ての格子点で元のデータの滑かな近似値が評価されます。元のデータの代わ
 りにこの近似値が描画されます。

 デフォルトの列の数は行の数に等しく、そのデフォルトの値は 10 です。

 元のデータから近似値を計算するためのいくつかのアルゴリズムが用意されて
 いて、追加のパラメータを指定できるものもあります。これらの補間は、格子
 点に近いデータ点ほど、その格子点に対してより強い影響を与えます。

 `splines` アルゴリズムは、"薄いつぎ板" を元にした補間計算を行います。
 これは追加パラメータを取りません。

 `qnorm` アルゴリズムは各格子点で入力データの重み付き平均を計算します。
 各点は格子点からの距離の norm 乗の逆数で重み付けされます。(実際には、
 dx, dy を各データ点と格子点との差の成分であるとすると、重みは dx^norm
 + dy^norm で与えられます。2 のべきのノルム、特に 4, 8, 16 に関しては、
 その重みの計算はユークリッド距離を使うことで (dx^2+dy^2)^norm/2 のよう
 に最適化されてますが、任意の負でない整数を使うことも可能です。) ノルム
 のべきの値をただ一つの追加パラメータとして指定できます。このアルゴリズ
 ムがデフォルトになっています。

 最後に、重み付き平均の計算用に、いくつかの平滑化重み付け関数 (kernel)
 が用意されています: z = Sum_i w(d_i) * z_i / Sum_i w(d_i), ここで z_i
 は i 番目のデータの値で、d_i は現在の格子点と i 番目のデータ点の位置と
 の距離です。すべての重み付け関数が、現在の格子点に近い方のデータ点には
 大きな重み、遠い方のデータ点には小さい重みを付けます。

 以下の重み付け関数が使用できます:
       gauss :     w(d) = exp(-d*d)
       cauchy :    w(d) = 1/(1 + d*d)
       exp :       w(d) = exp(-d)
       box :       w(d) = 1                     d<1 の場合
                        = 0                     その他
       hann :      w(d) = 0.5*(1-cos(2*pi*d))   d<1 の場合
                   w(d) = 0                     その他

 これら 5 つの平滑化重み付け関数のうち一つを使用する場合、2 つまでの追
 加パラメータ dx と dy を指定できます。これらは、距離の計算時に座標の違
 いをスケール変換するのに使えます:
 d_i = sqrt( ((x-x_i)/dx)**2 + ((y-y_i)/dy)**2 ), ここで、x,y は現在の
 格子点の座標で、x_i,y_i は i 番目のデータ点の座標です。dy のデフォルト
 の値は dx で、そのデフォルトの値は 1 になっています。パラメータ dx と
 dy は、データ点が格子点へ「データそれ自身の単位で」の寄与を行う範囲の
 制御を可能にします。

 オプションキーワード `kdensity` は、重み付け関数名の後ろで (オプション
 の) スケール変換のパラメータの前に置くもので、これはアルゴリズムを変更
 して、格子点用に計算する値を重みの和 ( z = Sum_i w(d_i) * z_i ) では割
 らないようにします。z_i がすべて定数の場合、これは事実上 2 変数の重み
 付け評価を描画します: (上の 5 つのうちの一つの) 重み付け関数が各データ
 点に置かれ、それらの重みの和がすべての格子点で評価され、そして元のデー
 タの代わりにこの滑らかな曲面が描画されます。これは、1 次元のデータ集合
 に対する `smooth kdensity` オプションが行うこととおおまかには同じです
 (使用例は kdensity2d.dem を参照してください)。

 後方互換性のために、わずかに異なる書式もサポートされています。どのアル
 ゴリズムも明示的に選択しなかった場合、`qnorm` アルゴリズムが仮定され、
 3 つ以下の、コンマ (,) 区切りのオプションパラメータを指定した場合は、
 それらをそれぞれ行数、列数、そして norm 値であると解釈します。

 オプション `dgrid3d` は、散在するデータを重み付き平均で規則的な格子に
 置き変える単純な仕組みに過ぎません。この問題に対するより洗練された手法
 が存在しますので、この単純な方法が不十分であれば、`gnuplot` の外でその
 ような方法でデータを前処理するべきでしょう。

 以下も参照
 dgrid3d.dem: dgrid3d のデモ
 および
 scatter.dem: dgrid3d のデモ

?commands set dummy
?commands show dummy
?set dummy
?show dummy
?unset dummy
?dummy
 コマンド `set dummy` はデフォルトの仮変数名を変更します。

 書式:
       set dummy {<dummy-var>} {,<dummy-var>}
       show dummy

 デフォルトでは、`gnuplot` は `plot` では、媒介変数モード、あるいは極座
 標モードでは "t", そうでなければ "x" を独立変数 (仮変数) とし、同様に
 `splot` では、媒介変数モードでは (`splot` は極座標モードでは使えません)
 "u" と "v", そうでなければ "x" と "y" を独立変数とします。

 仮変数は、物理的に意味のある名前、あるいはより便利な名前として使う方が
 便利でしょう。例えば、時間の関数を描画する場合:

       set dummy t
       plot sin(t), cos(t)

 例:
       set dummy u,v
       set dummy ,s

 第二の例は、2 番目の変数を s とします。仮変数名をデフォルトの値に戻す
 には以下のようにしてください。

       unset dummy
?commands set encoding
?commands show encoding
?set encoding
?show encoding
?encoding
?encodings
?utf8
?sjis
 コマンド `set encoding` は文字のエンコード (encoding) を選択します。

 書式:
       set encoding {<value>}
       set encoding locale
       show encoding

 有効な値 (value) は以下の通りです。
    default     - 出力形式にデフォルトのエンコードの使用を命令
    iso_8859_1  - UTF-8 より最も一般的な西ヨーロッパエンコード。このエ
                  ンコードは PostScript の世界での 'ISO-Latin1' です。
    iso_8859_15 - ユーロ記号を含む iso_8859_1 の亜種
    iso_8859_2  - 中央/東ヨーロッパで使用されるエンコード
    iso_8859_9  - (Latin5 として知られる) トルコで使用されるエンコード
    koi8r       - 良く使われる Unix のキリル文字エンコード
    koi8u       - Unix のウクライナ地方のキリル文字エンコード
    cp437       - MS-DOS のコードページ
    cp850       - 西ヨーロッパの OS/2 のコードページ
    cp852       - 中央/東ヨーロッパの OS/2 のコードページ
    cp950       - MS 版の Big5 (emf terminal のみ)
    cp1250      - 中央/東ヨーロッパの MS Windows のコードページ
    cp1251      - ロシア、セルビア、ブルガリア、マケドニア語 (8 ビット)
    cp1252      - 西ヨーロッパの MS Windows のコードページ
    cp1254      - トルコの MS Windows のコードページ (Latin5 の拡張)
    sjis        - Shift_JIS 日本語エンコード
    utf8        - 各文字の Unicode エントリポイントの、可変長 (マルチバ
                  イト) 表現

 コマンド `set encoding locale` は、他のオプションとは違い、これは現在
 のロカールを実行時の環境から決定しようとします。たいていのシステムでは
 これは環境変数 LC_ALL, LC_CTYPE, LANG のいずれかによって制御されます。
 この仕組みは、例えば wxt, cairopdf 出力形式で、UTF-8 や EUC-JP のよう
 なマルチバイト文字エンコードを通すために必要です。このコマンドは日付や
 数字などのロカール特有の表現には影響を与えません。
 以下も参照: `set locale`, `set decimalsign`。

 一般にエンコードの設定は、それが適切なフォントの選択に影響を与えるよう
 に、出力形式の設定の前に行なう必要があります。
?commands set errorbars
?commands show errorbars
?set errorbars
?show errorbars
?errorbars
?commands set bars
?commands show bars
?set bars
?show bars
?bars
 コマンド `set errorbars` は、誤差グラフ (errorbar) の両端、および
 boxplot につく箱ひげの両端のマークを制御します。以下参照: `boxplot`。

 書式:
       set errorbars {small | large | fullwidth | <size>} {front | back}
                     {line-properties}
       unset errorbars
       show errorbars

 `small` は 0.0 (交差線なし)、`large` は 1.0 と同じです。サイズを指定し
 なければデフォルトの値は 1.0 です。

 キーワード `fullwidth` は、errorbar を伴う boxplot と histograms にの
 み関連します。これは errorbar の両端の幅を、対応する箱の幅と同じに設定
 しますが、箱の幅自体を変更することはありません。

 キーワード `front`, `back` は、塗り潰し長方形のついた errorbar のみに
 関連します (boxes, candlesticks, histograms)。

 誤差線 (errorbar) は、デフォルトでは関連する箱の境界線と同じ線属性で描
 画しますが、これを誤差線用に用意した線属性に変更できます。

      set errorbars linecolor black linewidth 0.5 dashtype '.'
?commands set fit
?commands show fit
?set fit
?show fit
?set fit quiet
?set fit verbose
?set fit brief
?set fit results
?set fit prescale
?set fit limit
?set fit maxiter
?set fit errorscaling
?set fit errorvariables
?set fit logfile
?set fit script
?set fit v4
?set fit v5
 コマンド `set fit` は、`fit` コマンド用のオプションを制御します。

 書式:
       set fit {nolog | logfile {"<filename>"|default}}
               {{no}quiet|results|brief|verbose}
               {{no}errorvariables}
               {{no}covariancevariables}
               {{no}errorscaling}
               {{no}prescale}
               {maxiter <value>|default}
               {limit <epsilon>|default}
               {limit_abs <epsilon_abs>}
               {start-lambda <value>|default}
               {lambda-factor <value>|default}
               {script {"<command>"|default}}
               {v4 | v5}
       unset fit
       show fit

 オプション `logfile` は、`fit` コマンドがその出力を書き出す場所を定義
 します。 引数 <filename> は、単一引用符か二重引用符で囲む必要がありま
 す。ファイル名を指定しなかった場合、または `unset fit` を使用した場合
 は、ログファイルはデフォルトの値である "fit.log"、または環境変数
 `FIT_LOG` の値にリセットされます。与えられたログファイル名が / か \ で
 終っている場合、それはディレクトリ名と解釈され、ログファイルはそのディ
 レクトリの "fit.log" となります。

 デフォルトでは、そのログファイルに書かれる情報は、対話型出力にも出力し
 ます。`set fit quiet` はその対話型出力をオフにし、`results` は最終結果
 のみを出力します。`brief` は、追加で fit のすべての繰り返しに関して 1
 行の要約を提供します。`verbose` は、バージョン 5 以前でデフォルトだっ
 た、詳細な繰り返しの報告を行います。

 オプション `errorvariables` を ON にすると、`fit` コマンドで計算された
 個々の当てはめパラメータの誤差が、そのパラメータの名前に "_err" をつけ
 た名前のユーザ定義変数にコピーされます。これは主に、当てはめ関数とデー
 タの描画グラフの上にパラメータとその誤差を参照用に出力するのに使われま
 す。例:

        set fit errorvariables
        fit f(x) 'datafile' using 1:2 via a, b
        print "error of a is:", a_err
        set label 1 sprintf("a=%6.2f +/- %6.2f", a, a_err)
        plot 'datafile' using 1:2, f(x)

 オプション `errorscaling` を指定すると (デフォルト)、パラメータの計算
 誤差を補正χ自乗 (reduced χ-square) で伸縮します。これは、結果として
 補正χ自乗値になる、当てはめ計算の標準偏差 (FIT_STDFIT) に等しいデータ
 誤差を提供することと同等になります。オプション `noerrorscaling` では、
 評価誤差は、伸縮されない当てはめパラメータの標準偏差になります。
 データの重みを指定しなければ、パラメータの誤差は常に伸縮されます。

 オプション `prescale` をオンにすると、Marquardt-Levenberg ルーチンに渡
 す前に、各パラメータの値をそれらの初期値に従って事前にスケール変換しま
 す。これは、各パラメータの大きさにかなり大きな違いがある場合に、大変有
 効です。ただし、初期値が完全に 0 の当てはめパラメータには、決してこの
 スケール変換は行いません。

 反復数の限界値は、オプション `maxiter` で制限できます。それを 0 か
 `default` とすると、それは限界がないことを意味します。

 オプション `limit` は、収束を検出するためのもっとも小さい数字の限界
 (1e-5) のデフォルトの値を変更するのに使えます。自乗残差の和がこの数値
 未満の比率の変化しかしない場合は、当てはめは「収束した」と判断されます。

 オプション `limit_abs` は、自乗残差の和の変化の限界 (絶対値) を追加し
 ます。デフォルトは 0 です。

 アルゴリズムに関する別の制御をしたい場合、そして Marquardt-Levenberg
 アルゴリズムを良く知っている場合、それに影響を与える以下のオプションが
 利用できます: `lambda` の初期値は、通常自動的に ML-行列から計算されま
 すが、必要ならばオプション `start_lambda` を使ってそれを与えることがで
 きます。それを `default` とすると、再び自動設定が有効になります。オプ
 ション `lambda_factor` は、対象とする関数のχ自乗値が意味ありげに増加
 する/減少するときは常に `lambda` を増加させる/減少させる因子を設定しま
 す。それを `default` とすると、デフォルトの因子である 10.0 にします。

 オプション `script` は、fit を中断したときに実行する `gnuplot` コマン
 ドを指定するものです。以下参照: `fit`。この設定はデフォルトの `replot`
 や環境変数 `FIT_SCRIPT` よりも優先順位は上です。

 オプション `covariancevariables` をオンにすると、最終的なパラメータ間
 の共分散をユーザ定義変数に保存します。各パラメータの組に対してその共分
 散を保存する変数名は、"FIT_COV_" に最初のパラメータ名と "_" と 2 つ目
 のパラメータをつなげた名前になります。例えばパラメータ "a" と "b" に対
 しては、その共分散変数名は "FIT_COV_a_b" となります。

 バージョン 5 では、コマンド fit の書式は変更され、キーワード `error`
 が指定されていない場合は単位重み (`unitweights`) がデフォルトになりま
 した。オプション `v4` で gnuplot バージョン 4 のデフォルトの挙動に戻り
 ます。以下も参照: `fit`。
?commands set fontpath
?commands show fontpath
?set fontpath
?show fontpath
?fontpath
 `fontpath` の設定は、フォントファイルを読み込む場合のファイルの検索パ
 スを追加定義します。今のところ、postscript 出力形式のみが `fontpath`
 をサポートしています。ファイルが現在のディレクトリに見つからなかった場
 合、`fontpath` のディレクトリが検索されます。サポートしているフォント
 ファイルの形式に関するより詳しい説明は `terminal postscript` セクショ
 ンの文書中にあります。

 書式:
       set fontpath {"pathlist1" {"pathlist2"...}}
       show fontpath

 パス名は単一のディレクトリ名、または複数のパス名のリストとして入力しま
 す。複数のパスからなるパスリストは OS 固有のパス区切り、例えば Unix で
 はコロン (':'), MS-DOS, Windows, OS/2 ではセミコロン (';') 等で区切り
 ます。`show fontpath`, `save`, `save set` コマンドは、可搬性のために
 OS 固有のパス区切りをスペース (' ') で置き換えます。ディレクトリ名がエ
 クスクラメーションマーク ('!') で終っている場合、そのディレクトリのサ
 ブディレクトリも検索されます。

 環境変数 GNUPLOT_FONTPATH が設定されている場合、その内容は `fontpath`
 に追加されますが、それが設定されていない場合システムに依存したデフォル
 トの値が使用されます。最初にフォントパスを使ったときに、その幾つかのデ
 ィレクトリが存在するかテストされ、セットされます。よって、一番最初の
 `set fontpath`, `show fontpath`, `save fontpath` や、埋め込みフォント
 を使用した場合の `plot`, `splot` は、少し時間がかかります。それを少し
 でも短くしたければ、環境変数 GNUPLOT_FONTPATH を設定してください。そう
 すればディレクトリのチェックは OFF になります。デフォルトのフォントパ
 スが何であるかは、`show fontpath` で見ることができます。

 `show fontpath` は、ユーザ定義の fontpath とシステムの fontpath を別々
 に表示しますが、`save`, `save set` コマンドは、ユーザ定義の `fontpath`
 のみを保存します。

 gd ライブラリを通じてファイル名でフォントにアクセスする出力ドライバに
 関しては、フォント検索パスは環境変数 GDFONTPATH で制御されます。
?commands set format
?commands show format
?set format
?show format
?format
?format cb
 座標軸の刻みの見出しは、コマンド `set format` または `set tics format`
 または個別にコマンド `set {軸}tics format` で書式を設定できます。

 書式:
       set format {<axes>} {"<format-string>"} {numeric|timedate|geographic}
       show format

 ここで、<axes> (軸) は `x`, `y`, `xy`, `x2`, `y2`, `z`, `cb`、または何
 も指定しないか (その場合その書式はすべての軸に適用されます) のいずれか
 です。以下の 2 つのコマンドは全く同等です:
       set format y "%.2f"
       set ytics format "%.2f"

 書式文字列の長さは 100 文字まで、と制限されています。デフォルトの書式
 文字列は "% h" で、LaTeX 系の出力形式では "$%h$" です。他に "%.2f" や
 "%3.0em" のような書式が好まれることも多いでしょう。"set format" の後ろ
 に何もつけずに実行すると、デフォルトに戻します。

 空文字列 "" を指定した場合、刻み自身は表示しますが見出しはつけません。
 刻み自身を消すには、 `unset xtics` または `set tics scale 0` を使用し
 てください。

 書式文字列では、改行文字 (\n) や拡張文字列処理 (enhanced text) 用のマ
 ークアップも使えます。 この場合は、単一引用符 (') でなく (") を使って
 ください。以下も参照: `syntax`。
 "%" が頭につかない文字はそのまま表示されます。よって、書式文字列内に
 スペースや文字列などを入れることができます。例えば "%g m" とすれば、
 数値の後に " m" が表示されます。"%" 自身を表示する場合には "%g %%" の
 ように 2 つ重ねます。

 刻みに関するより詳しい情報については、以下も参照: `set xtics`。また、
 この方法で出力される数字にデフォルト以外の小数分離文字を使うやり方につ
 いては、以下参照: `set decimalsign`。
 以下も参照。
 エレクトロン (電子) デモ (electron.dem).
?gprintf
 文字列関数 gprintf("format",x) は、gnuplot コマンドの `set format`,
 `set timestamp` などと同様の、gnuplot 独自の書式指定子を使います。これ
 らの書式指定子は、標準的な C 言語の関数である sprintf() のものと全く同
 じではありません。gprintf() は、整形化される引数は一つしか受けつけませ
 ん。そのために、gnuplot には sprintf("format",x1,x2,...) 関数も用意さ
 れています。gnuplot の書式オプションの一覧については、以下参照:
 `format specifiers`。
?commands set format specifiers
?set format specifiers
?format specifiers
?format_specifiers
 使用可能な書式 (時間/日付モードでない場合) は以下の通りです:

       書式       説明
       %f         固定小数点表記
       %e, %E     指数表記; 指数の前に "e", "E" をつける
       %g, %G     %e (または %E) と %f の略記
       %h, %H     %g に "e%S" でなく "x10^{%S}" か "*10^{%S}" をつける
       %x, %X     16 進表記
       %o, %O     8 進表記
       %t         10 進の仮数部
       %l         現在の対数尺の底を基数とする仮数部
       %s         現在の対数尺の底を基数とする仮数部; 補助単位 (scientific power)
       %T         10 進の指数部
       %L         現在の対数尺の底を基数とする指数部
       %S         補助単位の指数部 (scientific power)
       %c         補助単位文字
       %b         ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の仮数部
       %B         ISO/IEC 80000 記法 (ki, Mi, Gi, Ti, Pi, Ei, Zi, Yi) の接頭辞
       %P         πの倍数


 補助単位 ('scientific' power) は、指数が 3 の倍数であるようなものです。
 補助単位指数 (`"%c"`) の文字への変換は -18 から +18 までの指数に対して
 サポートされています。この範囲外の指数の場合、書式は通常の指数形式に
 戻ります。

 ほかに使うことのできる修飾詞 ("%" と書式指定子の間に書くもの) には、
 次のいくつかがあります: "-" は数字を左詰めにし、"+" は正の数にも符号を
 つけ、" " (空白一つ) は負の数に "-" をつけるべき場所に正の数の場合に空
 白を一つつけ、"#" は小数点以下の数字が 0 だけであっても小数点をつけ、
 正の整数は出力幅を定め、出力幅指定の直前の "0" (文字でなく数字) は先頭
 に空いた部分を空白で埋める代わりに 0 で埋め、小数点の後に非負の整数を
 書いたものは精度を意味します (整数の場合は最小桁、小数の場合は小数点以
 下の桁数)。

 これらの全ての修飾詞をサポートしていない OS もあるでしょうし、逆にこれ
 以外のものをもサポートする OS もあるでしょう。疑わしい場合は、適切な資
 料を調べ、そして実験してみてください。

 例:
       set format y "%t"; set ytics (5,10)          # "5.0" と "1.0"
       set format y "%s"; set ytics (500,1000)      # "500" と "1.0"
       set format y "%+-12.3f"; set ytics(12345)    # "+12345.000  "
       set format y "%.2t*10^%+03T"; set ytic(12345)# "1.23*10^+04"
       set format y "%s*10^{%S}"; set ytic(12345)   # "12.345*10^{3}"
       set format y "%s %cg"; set ytic(12345)       # "12.345 kg"
       set format y "%.0P pi"; set ytic(6.283185)   # "2 pi"
       set format y "%.0f%%"; set ytic(50)          # "50%"

       set log y 2; set format y '%l'; set ytics (1,2,3)
       #"1.0", "1.0", "1.5" と表示される (3 は 1.5 * 2^1 なので)

 丸めと指数が必要となるような書式で 9.999 の様な数字が書かれる場合は
 問題が起こることがあります。

 軸のデータ型が日時データ (time/date) の場合、書式文字列は 'strftime'
 関数 ('gnuplot' 外。"man strftime" としてみてください) に関する有効な
 指定を行う必要があります。使える入力書式指定の一覧に関しては、以下参照:
 `set timefmt`。
?commands set format date_specifiers
?commands set format time_specifiers
?set format date_specifiers
?set format time_specifiers
?set date_specifiers
?set time_specifiers
?date_specifiers
?time_specifiers
 日時データモード (time/date mode) では、次の書式が使用できます:

       書式         説明
       %a           曜日名の省略形 (Sun,Mon,...) (入力は無視)
       %A           曜日名 (Sunday,Monday,...) (入力は無視)
       %b, %h       月名の省略形 (Jan,Feb,...)
       %B           月名 (January,February,...)
       %d           日 (01--31)
       %D           "%m/%d/%y" の簡略形 (出力のみ)
       %F           "%Y-%m-%d" の簡略形 (出力のみ)
       %k           時 (0--23; 1 桁または 2 桁)
       %H           時 (00--23; 常に 2 桁)
       %l           時 (1--12; 1 桁または 2 桁)
       %I           時 (01--12; 常に 2 桁)
       %j           その年の通算日 (001--366)
       %m           月 (01--12)
       %M           分 (00--60)
       %p           "am" または "pm"
       %r           "%I:%M:%S %p" の簡略形 (出力のみ)
       %R           "%H:%M" の簡略形 (出力のみ)
       %S           秒 (出力では 00--60 の整数、入力では実数)
       %s           1970 年最初からの秒数
       %T           "%H:%M:%S" の簡略形 (出力のみ)
       %U           その年の通算週 (週は日曜日開始)
       %w           曜日番号 (0--6, 日曜 = 0) (入力は無視)
       %W           その年の通算週 (週は月曜日開始) (入力は無視)
       %y           西暦 (2000-2068 年は 0-68、1969-1999 年は 69-99)
       %Y           西暦 (4 桁)



 数字を表す書式には、先頭に 0 を埋めるために "0" (ゼロ) を前につけるこ
 とができ、また最小の出力幅を指定するために正の整数を前につけることもで
 きます。書式 %S と %t は精度指定も受けつけるので、小数の時/分/秒を書く
 こともできます。

       書式         説明
       %tH          エポック時への相対的な正負の時 (24 での巻戻しなし)
       %tM          エポック時への相対的な正負の分
       %tS          直前の tH, tM 項目に対応する正負の秒数



?commands set format date_specifiers examples
?commands set format time_specifiers examples
?set format date_specifiers examples
?set format time_specifiers examples
?set date_specifiers examples
?set time_specifiers examples
?date_specifiers examples
?time_specifiers examples

 日付書式の例:

 x の値が、1976 年 12 月 25 日の深夜少し前の時刻に対応する秒数であると
 仮定します。この位置の軸の刻みラベル文字列は、以下のようになります:

       set format x                 # デフォルトでは "12/25/76 \n 23:11"
       set format x "%A, %d %b %Y"  # "Saturday, 25 Dec 1976"
       set format x "%r %D"         # "11:11:11 pm 12/25/76"

 時刻書式の例:

 日付書式指定は、秒数での時間の値を、ある特定の日の時計の時刻にエンコー
 ドします。よって、時は 0 から 23 まで、分は 0 から 59 までのみを動きま
 すが、それらの負の値は、エポック (1970 年 1 月 1 日) より前の日付に対
 応します。秒数での時間の値を、時間 0 に対する相対的な時/分/秒の数値と
 して出力させるには、時間書式 %tH %tM %tS を使用します。-3672.50 秒の値
 は以下のように出力されます。

       set format x                 # デフォルトでは "12/31/69 \n 22:58"
       set format x "%tH:%tM:%tS"   # "-01:01:12"
       set format x "%.2tH hours"   # "-1.02 hours"
       set format x "%tM:%.2tS"     # "-61:12.50"

?set function style
 このコマンドの形式は現在は推奨されていません。以下参照:
 `set style function`。
?commands show functions
?show functions
 `show functions` コマンドはユーザーが定義した関数とその定義内容を表示
 します。

 書式:
         show functions

 gnuplot における関数の定義とその使い方については、以下参照:
 `expressions`。
 以下も参照
 ユーザ定義関数でのスプライン (spline.dem)
 および
 関数と複素変数を翼に使用 (airfoil.dem)。
?commands set grid
?commands unset grid
?commands show grid
?set grid
?unset grid
?show grid
?grid
?nogrid
 コマンド `set grid` は格子線を描きます。

 書式:
       set grid {{no}{m}xtics} {{no}{m}ytics} {{no}{m}ztics}
                {{no}{m}x2tics} {{no}{m}y2tics} {{no}{m}rtics}
                {{no}{m}cbtics}
                {polar {<angle>}}
                {layerdefault | front | back}
                {{no}vertical}
                {<line-properties-major> {, <line-properties-minor>}}
       unset grid
       show grid

 格子線は任意の軸の任意の大目盛り/小目盛りに対して有効/無効にでき、その
 大目盛りと小目盛りに対する線種、線幅も指定でき、現在の出力装置がサポー
 トする範囲で、あらかじめ定義したラインスタイルを使用することもできます
 (以下参照: `set style line`)。

 2 次元描画では極座標格子も選択できます。これは、gnuplot が極座標モード
 (polar) のときの `set grid` のデフォルトの挙動ですが、明示的に
 `set grid polar <angle> rtics` とすれば、極座標モードであるなしに関わ
 らず実行できます。同心円は r 軸の主目盛/副目盛で交差するように描き、動
 径は <angle> の角を空けて描きます。同心円の周囲の目盛りの刻みは、
 `set ttics` で制御しますが、これは動径の格子線を新たには生成しません。

 `set grid` が描く前に、必要な目盛りは有効になっていなければなりません。
 `gnuplot` は、存在しない目盛りに対する格子の描画の命令は単に無視します。
 しかし、後でその目盛りが有効になればそれに対する格子も描きます。

 小格子線に対する線種を何も指定しなければ、大格子線と同じ線種が使われま
 す。デフォルトの極座標の角度は 30 度です。

 `front` を指定すると、格子線はグラフのデータの上に描かれます。`back`
 が指定された場合は格子線はグラフのデータの下に描かれます。`front` を使
 えば、密集したデータで格子線が見えなくなることを防ぐことができます。デ
 フォルトでは `layerdefault` で、これは 2D 描画では `back` と同じです。
 3D 描画のデフォルトは、格子とグラフの枠を 2 つの描画単位に分離し、格子
 は後ろに、枠は描画データまたは関数の前に書きます。ただし、`hidden3d`
 モードでは、それがそれ自身の並び換えをしていますので、格子線の順番のオ
 プションは全て無視され、格子線も隠線処理にかけられます。これらのオプシ
 ョンは、実際には格子線だけでなく、`set border` による境界線とその目盛
 りの刻み (以下参照: `set xtics`) にも影響を及ぼします。

 3 次元描画では、x 軸と y 軸の刻み位置に対する格子線は、デフォルトでは
 z=0 に平行な底面上にしか描きませんが、キーワード `vertical` は、格子線
 を xz 面と yz 面にも zmin から zmax まで描くようにします。

 z の格子線は描画の底面に描かれます。これは描画の周りに部分的な箱が描画
 されている場合にはいいでしょう。以下参照: `set border`。
?commands set hidden3d
?commands unset hidden3d
?commands show hidden3d
?set hidden3d
?unset hidden3d
?show hidden3d
?hidden3d
?nohidden3d
 `set hidden3d` コマンドは曲面描画 (以下参照: `splot`) で隠線処理を行な
 うように指示します。その処理の内部アルゴリズムに関する追加機能もこのコ
 マンドで制御できます。

 書式:
       set hidden3d {defaults} |
                    { {front|back}
                      {{offset <offset>} | {nooffset}}
                      {trianglepattern <bitpattern>}
                      {{undefined <level>} | {noundefined}}
                      {{no}altdiagonal}
                      {{no}bentover} }
       unset hidden3d
       show hidden3d

 gnuplot の通常の表示とは異なり、隠線処理では与えられた関数、またはデー
 タの格子線を、実際の曲面がその曲面の背後にあって隠されている描画要素は
 見せないのと同じように処理します。これが機能するためには、その曲面が
 '格子状' (以下参照: `splot datafile`) である必要があり、またそれらは
 `with lines` か `with linespoints` で描かれていなければいけません。

 `hidden3d` が有効なときは、格子線だけでなく、面部分や土台の上の等高線
 (以下参照: `set contour`) も隠されます。複数の面を描画している場合は、
 各曲面は自分自身と他の曲面で隠される部分も持ちます。曲面上への等高線の
 表示 (`set contour surface`) は機能しません。

 gnuplot バージョン 4.6 では、グラフ上に曲面が一つもない状態でも、
 hidden3d は `points`, `labels`, `vectors`, `impulses` の 3 次元の描画
 スタイルに影響を与えます。`vectors` は、隠されない部分は線分 (矢先なし)
 として表示されます。グラフ内の各々の描画をこの処理から明示的に除外した
 いときは、`with` 指定に特別のオプション `nohidden3d` を追加してくださ
 い。

 hidden3d は、pm3d モードで描画された、塗り潰された曲面には影響を与えま
 せん。pm3d の曲面に対して同様の効果を純粋に得たいならば、これの代わり
 に `set pm3d depthorder` を使ってください。複数の pm3d 曲面に通常の
 `hidden3d` 処理を組み合わせるには、オプション `set hidden3d front` を
 使用してください。これは、hidden3d 処理の全ての要素を、pm3d 曲面を含む
 残りの他の描画要素の後に強制的に描画するものです。

 関数値は格子孤立線の交点で評価されます。見ることの出来る線分を求めると
 きは個々の関数値、あるいはデータ点の間はそのアルゴリズムによって線形補
 間されます。これは、`hidden3d` で描画する場合と `nohidden3d` で描画す
 る場合で関数の見かけが異なることを意味します。なぜならば、後者の場合関
 数値は各標本点で評価されるからです。この違いに関する議論については、
 以下参照: `set samples`, `set isosamples`。

 曲面の隠される部分を消去するのに使われるアルゴリズムは、このコマンドで
 制御されるいくつかの追加オプションを持っています。`defaults` を指定す
 ればそれらはすべて、以下で述べるようなデフォルトの値に設定されます。
 `defaults` が指定されなかった場合には、明示的に指定されたオプションの
 みが影響を受け、それ以外のものは以前の値が引き継がれます。よって、それ
 らのオプションの値をいちいち修正することなく、単に `set {no}hidden3d`
 のみで隠線処理をオン/オフできることになります。

 最初のオプション `offset` は '裏側' の線を描画する線の線種に影響を与え
 ます。通常は曲面の表裏を区別するために、裏側の線種は、表側の線種より一
 つ大きい番号の線種が使われます。`offset <offset>` によって、その追加す
 る値を、デフォルトの 1 とは異なる増分値に変更できます。`nooffset` オプ
 ションは `offset 0` を意味し、これは表裏で同じ線種を使うことになります。

 次のオプションは `trianglepattern <bitpattern>` です。<bitpattern> は
 0 から 7 までの数字で、ビットパターンと解釈されます。各曲面は三角形に
 分割されますが、このビットパターンの各ビットはそれらの三角形の各辺の表
 示を決定します。ビット 0 は格子の水平辺、ビット 1 は格子の垂直辺、ビッ
 ト 2 は、元々の格子が 2 つの三角形に分割されるときの対角辺です。デフォ
 ルトのビットパターンは 3 で、これは全ての水平辺と垂直辺を表示し、対角
 辺は表示しないことを意味します。対角辺も表示する場合は 7 を指定します。

 オプション `undefined <level>` は、定義されていない (欠けているデータ
 または未定義の関数値) か、または与えられた x,y,z の範囲を超えているデ
 ータ点に適用させるアルゴリズムを指示します。そのような点は、それでも
 表示されてしまうか、または入力データから取り除かれます。取り除かれて
 しまう点に接する全ての曲面要素は同様に取り除かれ、よって曲面に穴が生
 じます。<level> = 3 の場合、これは `noundefined` と同じで、どんな点も
 捨てられません。これは他の場所であらゆる種類の問題を引き起こし得るので
 使わないべきです。<level> = 2 では未定義の点は捨てられますが、範囲を超
 えた点は捨てられません。<level> = 1 では、これがデフォルトですが、範囲
 を超えた点も捨てられます。

 `noaltdiagonal` を指定すると、`undefined` が有効のとき (すなわち <level>
 が 3 でない場合) に起こる以下の場合のデフォルトでの取扱いを変更できま
 す。入力曲面の各格子状の部分は一方の対角線によって 2 つの三角形に分割
 されます。通常はそれらの対角線の全てが格子に対して同じ方向を向いていま
 す。もし、ある格子の 4 つの角のうち一つが `undefined` 処理によりとり除
 かれていて、その角が通常の方向の対角線に乗っている場合は、その両方の三
 角形が取り除かれてしまいます。しかし、もしデフォルトの設定である
 `altdiagonal` が有効になっている場合、その格子については他方向の対角線
 が代わりに選択され、曲面の穴の大きさが最小になるようにします。

 `bentover` オプションは今度は `trianglepattern` とともに起こる別のこと
 を制御します。かなりしわくちゃの曲面では、下の ASCII 文字絵に書いたよ
 うに、曲面の 1 つの格子が 2 つに分けられた三角形の表と裏の反対側が見え
 てしまう場合 (すなわち、元の四角形が折り曲げられている ('bent over')
 場合) があります:

                                                               C----B
          元の 4 角形:     A--B      表示される 4 角形:        |\   |
       ("set view 0,0")    | /|    ("set view 75,75" perhaps)  | \  |
                           |/ |                                |  \ |
                           C--D                                |   \|
                                                               A    D

 曲面の格子の対角辺が <bitpattern> の 2 bit によって見えるようにはなっ
 てはいない場合、上の対角辺 CB はどこにも書かれないことになり、それが結
 果の表示を理解しにくいものにします。デフォルトで定義される `bentover`
 オプションは、このような場合それを表示するようにします。もしそうしたく
 ないなら、`nobentover` を選択してください。
 以下も参照
 隠線処理のデモ (hidden.dem)
 および
 複雑な隠線のデモ (singulr.dem).
?commands set historysize
?set historysize
?unset historysize
?historysize
 (非推奨)
 `set historysize N` は、`set history size N` と同じです。
 `unset historysize` は、`set history size -1` と同じです。
?commands set history
?set history
 書式:
    set history {size <N>} {quiet|numbers} {full|trim} {default}

 gnuplot の終了時にヒストリファイルに保存する行数を、history size の値
 に制限します。`set history size -1` とすると、ヒストリファイルに書き出
 す行数の制限がなくなります。

 デフォルトでは、コマンド `history` は各コマンドの前に行番号を出力しま
 す。`history quiet` は、今回の実行に対してのみ番号を省略しますが、
 `set history quiet` は、今後のすべての `history` の番号を省略します。

 オプション `trim` は、現在のコマンドに対する前の同じものを削除すること
 で、コマンド履歴内の重複する行の数を減らします。gnuplot のバージョン 5
 以前では、これがデフォルトの挙動でした。

 デフォルトの設定: `set history size 500 numbers trim`
?commands set isosamples
?commands show isosamples
?set isosamples
?show isosamples
?isosamples
 関数を面として描画する場合の孤立線 (格子) の密度はコマンド `set isosamples`
 で変更できます。

 書式:
       set isosamples <iso_1> {,<iso_2>}
       show isosamples

 各曲面グラフは <iso_1> 個の u-孤立線と <iso_2> 個の v-孤立線を持ちます。
 <iso_1> のみ指定すれば、<iso_2> は <iso_1> と同じ値に設定されます。
 デフォルトでは、u, v それぞれ 10 本の標本化が行われます。標本数をもっと
 多くすればより正確なグラフが作られますが、時間がかかります。これらの
 パラメータは、データファイルの描画には何も影響を与えません。

 孤立線とは、曲面の一つの媒介変数を固定して、もう一つの媒介変数によって
 描かれる曲線のことです。孤立線は、曲面を表示する単純な方法を与えます。
 曲面 s(u,v) の媒介変数 u を固定することで u-孤立線 c(v) = s(u0,v) が
 作られ、媒介変数 v を固定することで v-孤立線 c(u) = s(u,v0) ができます。

 関数の曲面グラフが隠線処理なしで描かれている場合、`set samples` は
 各孤立線上で標本化される点の数を制御します。以下参照: `set samples`,
 `set hidden3d`。等高線描画ルーチンは、関数の点の標本化は各孤立線の交点
 で行われると仮定しているので、関数の曲面と等高線の解像度を変更するとき
 は、`isosamples` と同じように `samples` を変更するのが望ましいでしょう。
?commands set jitter
?set jitter
?jitter
 書式:
       set jitter {overlap <yposition>} {spread <factor>} {wrap <limit>}
                  {swarm|square|vertical}
 例:
       set jitter                    # 1 文字幅内の点の jitter
       set jitter overlap 1.5        # 1.5 文字幅内の点の jitter
       set jitter over 1.5 spread 0.5  # 同上、しかし x の移動は半分幅

 データの 1 つ、または両方の座標が離散値に制限されている場合、多くの点
 が完全に互いの真上に乗っかる場合があります。jitter (揺らぎ) は、これら
 重なる点を、それらの座標にずらし値を与えることでその点を房状に広げます。
 点が重なっていると見なすための閾値は、文字幅単位、あるいは任意の座標オ
 プションを使って指定できます。以下参照: `coordinates`。jitter は、2 次
 元グラフの `with points` と `with impulses` にのみ影響を与えます。

 デフォルトの jitter 動作は、点を x 方向のみ移動します。これは、「ビー
 スォームグラフ」(bee swarm plot) と呼ばれる独特のパターンを作ります。
 オプションのキーワード `square` は、移動する点の x 座標に加えて、
 `overlap` で指定した距離だけは少なくとも離れた別々の階層にいるように y
 座標も揃えます。

 jitter を x ではなく y (のみ) に沿わせるには、キーワード `vertical` を
 使用してください。

 文字単位での最大の移動距離は、キーワード `wrap` で制限をかけられます。

 重なりの判定基準と、揺らぎの大きさは、いずれもデフォルトでは 1 文字単
 位であることに注意してください。よってグラフの見た目は、出力形式のフォ
 ントサイズ、キャンバスサイズ、拡大率によって変更してしまいます。これを
 避けるには、重なりの判定基準を y 座標系の単位 (キーワード `first`) で
 指定し、点のサイズと拡大係数を適切な値に調整してください。以下参照:
 `coordinates`, `pointsize`, `jitter`。
?commands set key
?commands unset key
?commands show key
?set key
?unset key
?show key
?key
?nokey
?legend
 コマンド `set key` は、描画領域内の各グラフに対するタイトルとサンプル
 (線分、点、箱) を持つ凡例 (または表題) を有効にします。凡例の機能は、
 `set key off` か `unset key` とすることで無効にできます。凡例の個々の
 項目については、対応する plot コマンドでキーワード `notitle` を使用す
 ることで無効にできます。凡例のタイトル文字列は、オプション
 `set key autotitle` や、個々の `plot` や `splot` コマンド上の `title`
 キーワードで制御できます。詳細は以下参照: `plot title`。

 書式:
       set key {on|off} {default}
             {{inside | outside | fixed}
               | {lmargin | rmargin | tmargin | bmargin}
               | {at <position>}}
             {left | right | center} {top | bottom | center}
             {vertical | horizontal} {Left | Right}
             {{no}enhanced}
             {{no}opaque}
             {{no}reverse} {{no}invert}
             {samplen <sample_length>} {spacing <line_spacing>}
             {width <width_increment>} {height <height_increment>}
             {{no}autotitle {columnheader}}
             {title {"<text>"} {{no}enhanced} {center | left | right}}
             {font "<face>,<size>"} {textcolor <colorspec>}
             {{no}box {linestyle <style> | linetype <type> | linewidth <width>}}
             {maxcols {<max no. of columns> | auto}}
             {maxrows {<max no. of rows> | auto}}
       unset key
       show key

 凡例 (key) は各要素を `vertical` (縦) か `horizontal` (横) の指定に従
 って重ねます。`vertical` の場合、凡例は可能ならば 2,3 個の縦の列を使い
 ます。すなわち、垂直方向の場所がある間は各要素を 1 つの列に並べますが、
 その次は新しい列に並べ始めます。垂直方向の行数は、`maxrows` を使って制
 限できます。`horizontal` の場合は、凡例は横の行数をなるべく少なくしよ
 うとします。水平方向の列数は `maxcols` で制限できます。

 デフォルトでは、凡例はグラフ領域の内側の右上の角に置かれます。キーワー
 ド `left`, `right`, `top`, `bottom`, `center`, `inside`, `outside`,
 `lmargin`, `rmargin`, `tmargin`, `bmargin` (, `above`, `over`, `below`,
 `under`) は、グラフ領域の他の場所への自動的な配置のために使用します。
 凡例の描画をどこに置くかをより詳しく指示するための `at <position>` も
 あります。この場合、キーワード `left`, `right`, `top`, `bottom`,
 `center` が同様の基準点合わせの設定の目的で使われます。
 より詳しくは、以下参照: `key placement`。

 グラフのタイトルの行揃えは `Left`, `Right` (デフォルト) で指示します。
 ラベル文字列と曲線のサンプルは左右入れ替えることができます (`reverse`)
 し、 全体を枠で囲むこともできます (`box {...}`)。その枠の線は、線種
 (`linetype`), 線幅 (`linewidth`)、あるいは定義済のラインスタイル
 (`linestyle`) を指定することもできます。

 凡例の文字列は、デフォルトで拡張文字列モード (`enhanced`) に設定されて
 いますが、これはオプション `{no}enhanced` で変更でき、キーのタイトルだ
 けや、個々のグラフ毎に変更することも可能です。

 デフォルトでは、凡例は一つのグラフと同時に作られます。すなわち、凡例の
 記号とタイトルは、それに対応するグラフと同時に描かれます。それは、新し
 いグラフが時には凡例の上に要素をかぶせて配置しうることを意味します。
 `set key opaque` は、凡例をすべてのグラフの描画が終った後に生成させま
 す。この場合、凡例の領域は背景色で塗りつぶされて凡例の記号とタイトルが
 描かれます。よって、凡例自身はいくつかの描画要素を覆い隠してしまい得る
 ことになります。`set key noopaque` でデフォルトに復帰できます。

 デフォルトでは、最初の描画のラベルが凡例の一番上に現われ、それに続くラ
 ベルがその下に並んで行きます。オプション `invert` は、最初のラベルを凡
 例の一番下に置き、それに続くラベルをその上に並べて行きます。このオプシ
 ョンは、凡例のラベルの縦の並びの順番を、積み上げ形式のヒストグラム
 (`histograms`) の箱の順番に合わせるときに便利でしょう。

 <height_increment> は、凡例の箱の高さに加えたり減らしたりする高さ (何
 文字分か) を表す数値です。これは主に、凡例の回りに箱を描く場合で、凡例
 の並びの回りの境界線をより大きくしたい場合のものです。

 全体に渡るタイトルを凡例の上につけることもできます (`title "<text>"`)。
 単一引用符 (') と二重引用符 (") の違いについては、以下も参照: `syntax`。
 タイトルの行揃えはデフォルトでは中央合わせで、それはキーワード `right`
 や `left` で変更することもできます。

 `set key` のデフォルトは、`on`,  `right`, `top`, `vertical`, `Right`,
 `noreverse`, `noinvert`, `samplen 4`, `spacing 1`, `notitle`, `nobox`
 です。凡例の枠の線種はデフォルトではグラフ描画の外枠と同じものが使われ
 ます。`set key default` とするとデフォルトの設定に戻ります。

 凡例内には、各グラフに対して、その描画スタイルを示す線分か記号か形、お
 よびそのタイトルが 1 行で表現されます。plot コマンドでキーワード
 `notitle` を使うと、凡例行の生成を抑制します。等高線描画では、各等高線
 に対応した行が凡例内に追加されます (以下参照: `cntrlabel`)。ファイル名
 や関数名の代わりにキーワード `keyentry` を与えたダミーの plot コマンド
 を使うことで、凡例内に追加の行を入れることができます。以下参照:
 `keyentry`。

 TeX, LaTeX 系の出力形式や、整形情報が文字列に埋め込まれる出力形式を使
 う場合は、`gnuplot` は凡例の位置決めのための文字列の幅を評価することし
 かできません。よって凡例を左に置く場合は、`set key left Left reverse`
 という組合せを使うのがいいでしょう。

?set key 3D
?set key splot
?key 3D
?key splot
?set key fixed
?key fixed
 3 次元グラフ (`splot`) の凡例の配置は、デフォルトでは `fixed` オプショ
 ンを使用します。これは、以前の版の gnuplot とは異なる挙動であるこに注
 意してください。`fixed` による配置は、`inside` による配置に似ています
 が、重要な違いが一つあります。3 次元グラフの視点が回転したりスケールす
 ると、それに伴なって描画の境界も変化します。凡例の配置が `inside` の場
 合は、視点が変更するときにこれらの境界が移動するため、凡例も移動します。
 `fixed` の場合は、視角やスケールの変更を無視して凡例を配置するので、グ
 ラフが回転しても、凡例の位置はキャンバスの一つの場所に固定されたままに
 なります。

 なお、2 次元グラフでは、`fixed` オプションは完全に `inside` と同じです。

 `splot` で等高線を書く場合、デフォルトでは異なる線種の個々の等高線レベ
 ルに対して、別々の凡例の項目を生成します。これを変更するには、以下参照:
 `set cntrlabel`。
?set key examples
?key examples
 以下はデフォルトの位置に凡例を表示します:
       set key default

 以下は凡例を表示しなくします:
       unset key

 以下はデフォルトの (第一の) 座標系での (2,3.5,2) の位置に凡例を表示
 します:
       set key at 2,3.5,2

 以下は凡例をグラフの下に表示します:
       set key below

 以下は凡例を左下角に表示し、テキストは左に行揃えで、タイトルをつけ、
 線種 3 の外枠を書きます:
       set key left bottom Left title 'Legend' box 3

?key entries
?keyentry
 通常、各グラフに対して凡例内に 1 行のエントリが自動生成されます。凡例
 内に見た目をより細かく制御したい場合は、コマンド `plot`, `splot` にキ
 ーワード `keyentry` をつけることで、余分に凡例行を追加できます。plot
 にファイル名や関数名を与える代わりに、`keyentry` をその場所に指定し、
 スタイル情報 (凡例の記号を生成するのに使用される) とタイトルをその後ろ
 に指定します。
 例:
      plot $HEATMAP matrix with image notitle, \
           keyentry with boxes fc palette cb 0 title "no effect", \
           keyentry with boxes fc palette cb 1 title "threshold", \
           keyentry with boxes fc palette cb 3 title "typical range", \
           keyentry with labels nopoint title "as reported in [12]", \
           keyentry with boxes fc palette cb 5 title "strong effect"
?commands set key autotitle
?set key autotitle
?key autotitle
?autotitle
 `set key autotitle` は、凡例の各グラフを、plot コマンドで使用したデー
 タファイルや関数の名前によって特定するようにしますが、これがデフォルト
 の挙動です。`set key noautotitle` は、その自動的なグラフのタイトル付け
 を無効にします。
 コマンド `set key autotitle columnheader` は、各入力データの先頭行の各
 列のエントリをテキスト文字列と解釈し、対応する描画グラフのタイトルとし
 て使用します。描画される量が、複数の列データの関数である場合は、
 gnuplot はどの列をタイトルの描画に使えばいいのかわかりませんので、その
 場合、plot コマンド上で、例えば以下のように明示的にタイトルの列を指定
 する必要があります。

       plot "datafile" using (($2+$3)/$4) title columnhead(3) with lines

 注意: `set key autotitle columnheader` とすると、たとえ凡例 (key) が
 `unset key` で無効になっている場合でも、1 列目をデータとしてではなく、
 列のヘッダとして処理します。これは、`stats` や `fit` のように凡例を作
 らないコマンドに対しても同様です。

 また、いずれの場合でも、plot コマンドに明示的な `title` や `notitle`
 キーワードを指定すれば、それは `set key autotitle` による設定より優先
 されます。
?commands set key placement
?set key placement
?key placement
 この節では、自動的に生成される通常の凡例の配置の説明をします。二次的な
 凡例の構成や、他の場所への描画タイトルの配置については、以下参照:
 `multiple keys`。

 配置の仕組みを理解ための最も重要な概念は、グラフ領域、すなわち内か外か
 ということと、グラフ領域の境界との間の余白 (margin) を考えることです。
 グラフ領域に沿って、キーワード `left/center/right` (l/c/r) と
 `top/center/bottom` (t/c/b) は、凡例 (key) をその領域の内側のどこに置
 くかを制御します。

 モード `inside` では、凡例はキーワード `left` (l), `right` (r), `top`
 (t), `bottom` (b), `center` (c) によって以下の図のように描画領域の境界
 に向かって出力されます:

      t/l   t/c   t/r

      c/l    c    c/r

      b/l   b/c   b/r


 モード `outside` でも上と同様に自動的に配置されますが、グラフ領域の境
 界に対して、というよりもむしろ見た目に対して、というべきでしょう。すな
 わち、グラフの境界は、グラフ領域の外の凡例の場所を作るために、内側に移
 動することになります。しかし、これは他のラベルの邪魔をしますし、もしか
 したら出力デバイスによってはエラーを引き起こすかもしれません。凡例の出
 力に合わせてどの描画境界が移動するかは、上に述べた凡例の位置、および重
 ね上げの方向に依存します。4 方向の中心揃えのオプション (`center`) に関
 しては、どの境界が動くのかに関するあいまいさはありませんが、角への出力
 のオプションについては、重ね上げ方向が `vertical` の場合は左または右の
 境界が、`horizontal` の場合は上または下の境界が、それぞれ内側に適切に
 移動します。

 余白 (margin) の書き方は、重ね上げの方向にかかわない自動的な配置を可能
 にしています。`lmargin` (lm), `rmargin` (rm), `tmargin` (tm),
 `bmargin` (bm) のうちの一つを、矛盾しない 1 方向のキーワードと組み合わ
 せて使用した場合、以下の図に示した場所に凡例が配置されます:

           l/tm  c/tm  r/tm

      t/lm                  t/rm

      c/lm                  c/rm

      b/lm                  b/rm

           l/bm  c/bm  r/bm


 キーワード `above` と `over` は `tmargin` と同じ意味です。以前のバージ
 ョンとの互換性のために、`above` と `over` は l/c/r や重ね上げ方向のキ
 ーワードなしで使用すると、`center` で `horizontal` を使います。キーワ
 ード `below` と `under` は `bmargin` と同じ意味です。互換性のために、
 `below` と `under` は l/c/r や重ね上げ方向のキーワードなしで使用すると
 `center` で `horizontal` を使います。さらに、`outside` も互換性のため
 に t/b/c や重ね上げ方向のキーワードがなければ、`top`, `right`,
 `vertical` (つまり上の t/rm と同じ) を使用します。

 凡例の位置 (<position>) は、以前のバージョンと同様単に x,y,z を指定し
 てもいいですが、その最初のサンプル行の座標の座表系を選択するための 5
 つのキーワード (`first`, `second`, `graph`, `screen`, `character`) を
 頭につけることもできます。詳細は、以下参照: `coordinates`。<position>
 が与えられた場合の `left`, `right`, `top`, `bottom`, `center` の効果は、
 label コマンドで配置される文字列の場合と同じように基準位置の位置揃えに
 使用されます。すなわち、`left` は凡例が <position> の右に置かれて左合
 わせで出力されます。他の場合も同様です。
?commands set key samples
?set key samples
?key samples
 デフォルトでは、グラフ上の各描画は凡例 (key) 内にそれぞれに対応するエ
 ントリを生成します。このエントリには、描画タイトルと、その描画で使われ
 るのと同じ色、同じ塗りつぶし属性による線/点/箱 のサンプルが入ります。
 font と textcolor 属性は、凡例内に現われる個々の描画タイトルの見た目を
 制御します。textcolor を "variable" にセットすると、凡例の各エントリの
 文字列は、描画グラフの線や塗りつぶし色と同じ色になります。これは、以前
 のある時期の gnuplot のデフォルトの挙動でした。

 グラフ曲線のサンプルの線分の長さは `samplen` で指定できます。その長さ
 は目盛りの長さと、<sample_length>*(文字幅) の和として計算されます。
 `sapmlen` は、グラフ上の点のサンプルの位置にも (もしサンプル線分自身が
 書かれなくても) 影響を与えています。それは、点の記号はサンプル線分の中
 央に書かれるためです。

 凡例のベースライン間隔は、現在のフォントサイズに対する「1 行空き」
 (single space) になっています。これは `set key spacing <line-spacing>`
 で変更できます。

 <width_increment> は、文字列の長さに加えたり減らしたりする幅 (何文字分
 か) を表す数値です。これは、凡例に外枠を書き、文字列に制御文字を使う場
 合にだけ有用でしょう。`gnuplot` は外枠の幅を計算するときは、ラベル文字
 列の文字数を単純に数えるだけなので、それを修正するのに使えます。
?multiple keys
?set key multiple keys
?key multiple keys
 各グラフのタイトルを、すべて自動的に生成される凡例 (key) 内に表示させ
 る代わりに、表題や凡例を手動で配置することができます。これにより、例え
 ば多重描画モード (multiplot) での各グラフ要素に対する表題を 1 箇所に集
 約して作ることができるようになります。
 以下はその一例:
        set multiplot layout 3,2 columnsfirst
        set style data boxes
        plot $D using 0:6  lt 1 title at 0.75, 0.20
        plot $D using 0:12 lt 2 title at 0.75, 0.17
        plot $D using 0:13 lt 3 title at 0.75, 0.14
        plot $D using 0:14 lt 4 title at 0.75, 0.11
        set label 1 at screen 0.75, screen 0.22 "Custom combined key area"
        plot $D using 0:($6+$12+$13+$14) with linespoints title "total"
        unset multiplot
?commands set label
?commands unset label
?commands show label
?set label
?unset label
?show label
?label
?nolabel
 `set label` コマンドを使うことによって任意の見出し (label) をグラフ中
 に表示することができます。

 書式:
       set label {<tag>} {"<label text>"} {at <position>}
                 {left | center | right}
                 {norotate | rotate {by <degrees>}}
                 {font "<name>{,<size>}"}
                 {noenhanced}
                 {front | back}
                 {textcolor <colorspec>}
                 {point <pointstyle> | nopoint}
                 {offset <offset>}
                 {boxed}
                 {hypertext}
       unset label {<tag>}
       show label

 位置 (<position>) は x,y か x,y,z のどちらかで指定し、座標系を指定する
 にはその座標の前に `first`, `second`, `polar`, `graph`, `screen`,
 `character` をつけます。詳細は、以下参照: `coordinates`。

 タグ (<tag>) は見出しを識別するための整数値です。タグを指定しなかった
 場合未使用のもので最も小さい値が自動的に割り当てられます。現在の見出し
 を変更するときはそのタグと変更したい項目を指定して `set label` コマン
 ドを使います。

 <label text> は文字列定数でも構いませんし、文字列変数、または文字列の
 値を持つ式でも構いません。以下参照: `strings`, `sprintf`, `gprintf`。

 デフォルトでは、指定した点 x,y,z に見出しの文章の左端が来るように配置
 されます。x,y,z を見出しのどこに揃えるかを変更するには変数
 <justification> を指定します。これには、`left`, `right`, `center` の
 いずれかが指定でき、それぞれ文章の左、右、真中が指定した点に来るよう
 に配置さるようになります。描画範囲の外にはみ出るような指定も許されま
 すが、座標軸の見出しや他の文字列と重なる場合があります。

 箱枠付きのラベルをサポートする出力形式もあります。以下参照:
 `set style textbox`。回転させた文字列の箱付けは、すべての出力形式が可
 能なわけではありません。

 `rotate` を指定するとラベルは縦書きになります。`rotate by <degrees>`
 を指定すると、文字列のベースラインを指定した角に設定します。ただし、文
 字列の回転をサポートしていない出力形式もあります。

 フォントとそのサイズは、出力形式がフォントの設定をサポートしていれば
 `font "<name>{,<size>}"` で明示的に選択できます。そうでない出力形式で
 は、デフォルトのフォントが使われます。

 通常は、現在の出力形式がサポートしていれば、ラベル文字列の全ての文字列
 に拡張文字列処理モード (enhanced text mode) が使用されます。
 `noenhanced` を使用することで、特定のラベルを拡張文字列処理から外すこ
 とができます。これは、ラベルが例えばアンダースコア (_) を含んでいる場
 合などに有用です。以下参照: `enhanced text`。

 `front` が与えられると、見出しはデータのグラフの上に書かれます。`back`
 が与えられると (デフォルト)、見出しはグラフの下に書かれます。`front`
 を使うことで、密なデータによって見出しが隠されてしまうことを避けること
 が出来ます。

 `textcolor <colorspec>` は見出し文字列の色を変更します。<colorspec> は
 線種、rgb 色、またはパレットへの割当のいずれかが指定できます。
 以下参照: `colorspec`, `palette`。`textcolor` は、`tc` と省略可能です。
    `tc default` は、文字色をデフォルトにします。
    `tc lt <n>` は、文字色を線種 <n> (line type)と同じものにします。
    `tc ls <n>` は、文字色を line style <n> と同じものにします。
    `tc palette z` は、見出しの z の位置に対応したパレット色になります。
    `tc palette cb <val>` は、色見本 (colorbar) の <val> の色になります。
    `tc palette fraction <val>` (0<=val<=1) は、[0:1] から `palette` の
        灰色階調/カラーへの写像に対応した色になります。
    `tc rgb "#RRGGBB"`, `tc rgb "0xRRGGBB"` は、任意の 24-bit RGB 色を
        設定します。
    `tc rgb 0xRRGGBB` も同じです (16 進定数値には引用符は不要)。

 <pointstyle> がキーワード `lt`, `pt`, `ps` とともに与えられると (以下
 参照: `style`)、与えられたスタイルと、与えられた線種の色で見出し位置に
 点 (point) が描画され、見出し文字列は少し移動されます。このオプション
 は `mouse` 拡張された出力形式でのラベルの配置に、デフォルトで使用され
 ています。見出し文字列近くの点の描画機能を off (これがデフォルト) にす
 るには、`nopoint` を使用してください。

 その移動は、デフォルトでは、<pointstyle> が与えられれば `pointsize` の
 単位で 1,1 で、<pointstyle> が与えられていなければ 0,0 です。移動は、
 追加の `offset <offset>` でも制御できます。ここで、<offset> は x,y か
 または x,y,z の形式ですが、それに座標系を選択して、その前に `first`,
 `second`, `graph`, `screen`, `character` のいずれかをつけることもでき
 ます。詳細は、以下参照: `coordinates`。

 もし一つ (あるいはそれ以上の) 軸が時間軸である場合、座標は `timefmt`
 の書式にしたがって引用符で囲まれた文字列で与える必要があります。以下参
 照: `set xdata`, `set timefmt`。

 `set label` に関して有効なオプションは、描画スタイル `labels` でも有効
 です。以下参照: `labels`。この場合、`textcolor`, `rotate`, `pointsize`
 の属性の後ろにキーワード `variable` をつけて、それらを固定値でないよう
 にすることが可能です。その場合個々のラベルの対応する属性値は、`using`
 指定の追加列により決定します。

?label examples
?set label examples
 例:

 (1,2) の位置に "y=x" と書く場合:
       set label "y=x" at 1,2

 Symbol フォントのサイズ 24 の "シグマ" (Σ) をグラフの真中に書く場合:
       set label "S" at graph 0.5,0.5 center font "Symbol,24"

 見出し "y=x^2" の右端が (2,3,4) に来るようにし、タグ番号として 3 を使う
 場合:
       set label 3 "y=x^2" at 2,3,4 right

 その見出しを中央揃えにする場合:
       set label 3 center

 タグ番号 2 の見出しを削除する場合:
       unset label 2

 全ての見出しを削除する場合:
       unset label

 全ての見出しをタグ番号順に表示する場合:
       show label

 x 軸が時間軸であるグラフに見出しを設定する例:
       set timefmt "%d/%m/%y,%H:%M"
       set label "Harvest" at "25/8/93",1

 データと、新たに当てはめられたパラメータによる当てはめ関数を描画したい
 場合、`fit` の後でかつ `plot` の前に以下を実行します:
       set label sprintf("a = %3.5g",par_a) at 30,15
       bfit = gprintf("b = %s*10^%S",par_b)
       set label bfit at 30,20

 当てはめられるパラメータのついた関数の定義式を表示したい場合:
       f(x)=a+b*x
       fit f(x) 'datafile' via a,b
       set label GPFUN_f at graph .05,.95
       set label sprintf("a = %g", a) at graph .05,.90
       set label sprintf("b = %g", b) at graph .05,.85

 見出し文字列を小さい点から少しだけ移動する場合:
       set label 'origin' at 0,0 point lt 1 pt 2 ps 3 offset 1,-1

 pm3d を使った 3 次元のカラー曲面上のある点の位置に、その z の値 (この
 場合 5.5) に対応した色を見出し文字列につける場合:
       set label 'text' at 0,0,5.5 tc palette z
?hypertext
?label hypertext
?set label hypertext
 出力形式の中には (wxt, qt, svg, canvas, win) グラフ上の特定の位置やキ
 ャンバス内のその他の部分にハイパーテキストを貼り付けることができるもの
 があります。マウスをその場所に持っていくと、文字列を含む箱がポップアッ
 プされますが、ハイパーテキストをサポートしない出力形式では、それは何も
 表示しません。ハイパーテキストを貼り付けるには、そのラベルの `point`
 属性を有効にする必要があります。
 例:
       set label at 0,0 "Plot origin" hypertext point pt 1
       plot 'data' using 1:2:0 with labels hypertext point pt 7 \
            title 'mouse over point to see its order in data set'

 試験段階の機能 (仕様の細かい部分は変更の可能性あり):
 "image{<xsize>,<ysize>}:<filename>{\n<caption text>}" の形式の文字列は
 ポップアップボックス内で画像ファイルを表示させるようにします。サイズ指
 定によりデフォルトのサイズ 300x200 を変更できます。認識する画像ファイ
 ルの型は出力形式によって違いますが、*.png は常に OK です。画像ファイル
 名の後ろに書いた文字列は、通常のハイパーテキストと同様に表示します。
?commands set linetype
?commands show linetype
?set linetype
?show linetype
?linetype
 コマンド `set linetype` は各種描画に使用される基本的な線種 (linetype)
 を再定義することを可能にします。このコマンドのオプションは、
 "set style line" のものと全く同じです。ラインスタイルと違うところは、
 `set linetype` による再定義は永続的なことで、これは `reset` の影響を受
 けません。

 例えば、線種 1 と 2 を以下のように再定義してみます:

       set linetype 1 lw 2 lc rgb "blue" pointtype 6
       set linetype 2 lw 2 lc rgb "forest-green" pointtype 8

 すると、それらの線種の最初の見た目がどうであったかに関わらず、lt 1 を
 使用しているすべてのものが、その後は太い青線になります。この性質は、lt
 1 によって作られた一時的なラインスタイルの定義のようなものにも適用され
 ます。同様に、線種 2 は、その後は太い緑線になります。

 この仕組みは、gnuplot で使用する線種列に対する個人的な好みを設定するの
 にも使えます。それを行うには、実行時初期化ファイル ~/.gnuplot に、例え
 ば以下のようなそれ用のコマンド列を追加することをお勧めします:

       set linetype 1 lc rgb "dark-violet" lw 2 pt 1
       set linetype 2 lc rgb "sea-green"   lw 2 pt 7
       set linetype 3 lc rgb "cyan"        lw 2 pt 6 pi -1
       set linetype 4 lc rgb "dark-red"    lw 2 pt 5 pi -1
       set linetype 5 lc rgb "blue"        lw 2 pt 8
       set linetype 6 lc rgb "dark-orange" lw 2 pt 3
       set linetype 7 lc rgb "black"       lw 2 pt 11
       set linetype 8 lc rgb "goldenrod"   lw 2
       set linetype cycle 8

 こうすると、あなたが gnuplot を実行する度に線種はこれらの値に初期化さ
 れます。線種はあなたが好む数だけ初期化できます。再定義しない場合は、そ
 れはデフォルトの属性を持ち続けます。例えば線種 3 を再定義から外せば、
 それは青で pt 3, lw 1 となります。なお、サンプルスクリプトの最初の 2,3
 の行は、古いバージョンの gnuplot ではスキップさせるための保険です。

 同様のスクリプトファイルで、テーマベースの色選択の定義を行ったり、特定
 の描画タイプ、あるいは特定の出力形式用に色をカスタマイズしたりすること
 も可能です。

 コマンド `set linetype cycle 8` は、大きな番号の線種に対しては色や線幅
 に関するこれらの定義を再利用することを gnuplot に伝えます。すなわち、
 線種 (linetype) 9-16, 17-24 等に対しては、これと同じ色、幅の列を使用し
 ます。ただし、点の属性 (pointtype, pointsize, pointinterval) は、この
 コマンドの影響は受けません。`unset linetype cycle` はこの機能を無効に
 します。大きな線種番号の線の属性を明示的に定義した場合は、それは小さい
 番号の線種の属性の再利用よりも優先されます。
?commands set link
?set link
?link
 書式:
       set link {x2 | y2} {via <expression1> inverse <expression2>}
       unset link

 コマンド `set link` は、x 軸と x2 軸、または y 軸と y2 軸の間の対応を
 設定します。<expression1> は、第 1 軸の座標を第 2 軸に写像する数式です
 が、<expression2> は第 2 軸の座標を第 1 軸に写像する数式です。

 例:

       set link x2

 これは、このコマンドの最も単純な形式で、x2 軸を範囲 (range) も伸縮
 (scale) も方向も x 軸と全く同じにします。`set xrange`, `set x2range`
 や `set auto x` などのコマンドは、この場合 x 軸にも x2 軸にも作用しま
 す。

       set link x2 via x**2 inverse sqrt(x)
       plot "sqrt_data" using 1:2 axes x2y1, "linear_data" using 1:2 axes x1y1

 このコマンドは、x 軸と x2 軸の、順方向と逆方向の対応を設定しています。
 順方向の対応は、x2 軸の刻みラベルと、マウスの x2 座標を生成するのに使
 い、逆方向の対応は、x2 軸系で指定された座標を描画するのに使います。こ
 の対応は、非負の x 座標にのみ有効であることに注意してください。y2 軸に
 対応させた場合、<expression1> と <expression2> には仮変数として y を使
 う必要があります。
?commands set lmargin
?set lmargin
?lmargin
 コマンド `set lmargin` は左の余白のサイズをセットします。詳細は、以下
 参照: `set margin`。
?commands set loadpath
?commands show loadpath
?set loadpath
?show loadpath
?loadpath
 `loadpath` の設定は、`call`, `load`, `plot`, `splot` コマンドのデータ
 ファイル、コマンドファイルの検索パスを追加定義します。ファイルが現在の
 ディレクトリに見つからなかった場合、`loadpath` のディレクトリが検索さ
 れます。

 書式:
       set loadpath {"pathlist1" {"pathlist2"...}}
       show loadpath

 パス名は単一のディレクトリ名、または複数のパス名のリストとして入力しま
 す。複数のパスからなるパスリストは OS 固有のパス区切り、例えば Unix で
 はコロン (':'), MS-DOS, Windows, OS/2 ではセミコロン (';') 等で区切り
 ます。`show loadpath`, `save`, `save set` コマンドは、OS 固有のパス区
 切りをスペース (' ') で置き換えます。

 環境変数 GNUPLOT_LIB が設定されている場合、その内容は `loadpath` に追
 加されますが、`show loadpath` は、`set loadpath` と GNUPLOT_LIB の値を
 別々に表示しますし、`save`, `save set` コマンドは、GNUPLOT_LIB の値の
 方は無視します。
?commands set locale
?set locale
?locale
 `locale` の設定は `{x,y,z}{d,m}tics` が書く日付の言語を決定します。

 書式:
       set locale {"<locale>"}

 <locale> にはインストールされたシステムで使うことの出来る任意の言語を
 指定できます。可能なオプションについてはシステムのドキュメントを参照し
 てください。コマンド `set locale ""` は、環境変数 LC_TIME, LC_ALL, ま
 たは LANG からロカールの値を決定しようとします。

 小数点に関する locale を変更したい場合は、以下参照: `set decimalsign`。
 文字エンコードを現在のロカールのものに変更したい場合は、以下参照:
 `set encoding`。
?commands set logscale
?commands unset logscale
?commands show logscale
?set logscale
?unset logscale
?show logscale
?set log
?logscale
?nologscale
 書式:
       set logscale <axes> {<base>}
       unset logscale <axes>
       show logscale

 ここで、<axes> (軸) は、`x`, `x2`, `y`, `y2`, `z`, `cb`, `r` の任意の
 順序の組み合せが可能です。<base> は、対数目盛りの底です (デフォルトの
 底は 10)。軸を指定しなかった場合は、`r` 以外のすべての軸が対象となりま
 す。コマンド `unset logscale` は、すべての軸の対数目盛りを解除します。
 対数軸に対してつけられる目盛りの刻みは、等間隔ではないことに注意してく
 ださい。以下参照: `set xtics`。

 例:

 x, z 両軸について対数目盛りを設定する:
        set logscale xz

 y 軸について底 2 とする対数目盛りを設定する:
        set logscale y 2

 pm3d plot 用に z と色の軸に対数目盛りを設定する:
        set logscale zcb

 z 軸の対数目盛りを解除する:
        unset logscale z
?commands set macros
?set macros
 現在のバージョンの gnuplot では、マクロ置換は常に有効です。コマンドラ
 イン内の @<stringvariablename> の形式の部分文字列は、文字列変数
 <stringvariablename> に含まれるテキスト文字列に置き換えられます。以下
 参照: `substitution`。
?commands set mapping
?commands show mapping
?set mapping
?show mapping
?mapping
 データが `splot` に球面座標や円柱座標で与えられた場合、`set mapping`
 コマンドは `gnuplot` にそれをどのように扱うかを指定するのに使われます。

 書式:
       set mapping {cartesian | spherical | cylindrical}

 デフォルトではカーテシアン座標 (通常の x,y,z 座標) が使われます。

 球面座標では、データは 2 つか 3 つの列 (またはその個数の `using` エン
 トリ) として与えられます。最初の 2 つは、`set angles` で設定された単位
 での方位角 (theta) と仰角 (phi) (すなわち "経度" と "緯度") とみなされ
 ます。半径 r は、もし 3 列目のデータがあればそれが使われ、もしなければ
 1 に設定されます。各変数の x,y,z との対応は以下の通りです:

       x = r * cos(theta) * cos(phi)
       y = r * sin(theta) * cos(phi)
       z = r * sin(phi)

 これは、"極座標系" というより、むしろ "地学上の座標系" (緯度、経度) に
 相当することに注意してください (すなわち、phi は z 軸となす角、という
 より赤道から計った仰角、になります)。

 円柱座標では、データはやはり 2 つか 3 つの列で与えられ、最初の 2 つは
 theta (`set angle` で指定された単位の) と z と見なされます。半径 r は
 球面座標の場合と同様、3 列目のデータがあればそれが、なければ 1 と設定
 されます。各変数の x,y,z との対応は以下の通りです:

       x = r * cos(theta)
       y = r * sin(theta)
       z = z

 `mapping` の効果は、`splot` コマンド上の `using` によるフィルタで実現
 することも可能ですが、多くのデータファイルが処理される場合は `mapping`
 の方が便利でしょう。しかし、`mapping` を使っていても、もしファイルのデ
 ータの順番が適切でなかったら結局 `using` が必要になってしまいます。

 `mapping` は `plot` では何もしません。
 world.dem: mapping のデモ。
?commands set margins
?commands show margins
?set margin
?set margins
?show margins
?margins
 `margin` (周囲の余白) とは、描画領域の境界からキャンバスの一番外側まで
 の間隔のことです。この余白の大きさは自動的にとられますが、コマンド
 `set margin` で変更することもできます。`show margin` は現在の設定を表
 示します。描画領域の境界から内側の描画要素までの間隔を変更したい場合は
 以下参照: `set offsets`。

 書式:
       set lmargin {{at screen} <margin>}
       set rmargin {{at screen} <margin>}
       set tmargin {{at screen} <margin>}
       set bmargin {{at screen} <margin>}
       set margins <left>, <right>, <bottom>, <top>
       show margin

 <margin> のデフォルトの単位には、適切と思われる、文字の高さと幅が使わ
 れます。正の値は余白の絶対的な大きさを定義し、負の値 (または無指定) は
 `gnuplot` によって自動計算される値を使うことになります。3 次元描画では
 左の余白 (lmargin) のみが文字の大きさを単位として設定できます。

 キーワード `at screen` は、その余白の指定が全体の描画領域に対する割合
 であることを意味します。これは、多重描画 (multiplot) モードでの 2D, 3D
 グラフの角を正確に揃えるのに使えます。この配置は現在の `set origin` や
 や `set size` の値を無視するようになっていて、それは多重描画内のグラフ
 の配置の別の方法として使われることを意図しています。

 描画の余白は通常目盛り、目盛りの見出し、軸の見出し、描画のタイトル、
 日付、そして境界の外にある場合の凡例 (key) のサイズ等を元に計算されま
 す。しかし、目盛りの刻みが境界でなく軸の方についている場合 (例えば
 `set xtics axis` によって)、目盛りの刻み自身とその見出しは余白の計算に
 は含まれませんし、余白に書かれる他の文字列の位置の計算にも含まれません。
 これは、軸と境界が非常に近い場合、軸の見出しが他の文字列を上書きする可
 能性を示唆します。
?commands set micro
?commands show micro
?commands unset micro
?set micro
?show micro
?unset micro
?micro
 デフォルトでは、軸の刻みラベルの生成に使用する科学系出力のための書式指
 定子 "%c" は、「マイクロ」(10^-6) を示す接頭辞として小文字の u を使い
 ます。コマンド `set micro` は、それとは異なる印字用文字 (unicode
 U+00B5) を使用するよう gnuplot に指示します。その文字を表現するのに使
 用されるバイト列は、現在の encoding に依存します。以下参照:
 `format specifiers`, `encoding`。

 このコマンドは試験段階のもので、制限がありますし、仕様の細かい部分は変
 更する可能性があります。

?commands set minussign
?commands show minussign
?commands unset minussign
?set minussign
?show minussign
?unset minussign
?minussign
 gnuplot はほとんどの書式付き入力は C 言語のライブラリルーチンである
 sprintf() で処理します。しかし、gnuplot には独自の書式化ルーチン
 `gprintf()` もあり、それは軸の刻み文字列の生成に使われています。C のラ
 イブラリルーチンは、-7 のような負の数の表示には常にハイフン文字 (ASCII
 \055) を使用しますが、むしろその目的では、それとは異なる印字用のマイナ
 ス符号文字 (Unicode U+2212) を使い －7 のように表示したいと多くの人々
 は思うでしょう (訳注: 原文では '7' の前は Unicode の「マイナス記号」が
 使われているが、ここでは JIS の全角マイナス記号 245D を用いた)。コマン
 ド

      set minussign

 は、gprintf() の数字の出力に、ハイフンの代わりにマイナス符号文字を使用
 するよう指示します。UTF-8 ロケールではそれは Unicode U+2212 に対応する
 マルチバイト文字列になり、Window コードページ 1252 ロケールでは、これ
 は 8 ビット文字の ALT+150 ("en dash") になります。コマンド
 `set minussign` は、軸の刻みのラベルと、gprintf を明示的に呼び出して生
 成された文字列に影響を与えますが、その他の場合のハイフンを含む文字列に
 は何ら影響を与えません。以下参照: `gprintf`。

 LaTeX は、それ自身が負の符号を自前で処理する仕組みを持っているため、こ
 のコマンドは、LaTeX 系の出力形式を使用している場合は無視されることに注
 意してください。postscript 出力形式を使用する場合も、gnuplot の
 postscript 用前処理ルーチンが ascii のハイフンコード \055 を `minus`
 という名前の異なる文字に変換するので、このコマンドは必要はありません。

 このコマンドは試験段階のもので、制限がありますし、仕様の細かい部分は変
 更する可能性があります。

 例 (utf8 ロケールを仮定):

      set minus
      A = -5
      print "A = ",A                 # ハイフンを含む文字列を出力
      print gprintf("A = %g",A)      # U+2212 文字を含む文字列を出力
      set label "V = -5"             # ハイフンを含むラベル
      set label sprintf("V = %g",-5) # ハイフンを含むラベル
      set label gprintf("V = %g",-5) # U+2212 を含むラベル
?commands set monochrome
?set monochrome
?monochrome
 書式:
      set monochrome {linetype N <linetype properties>}

 コマンド `set monochrome` は、線種群の別の設定法を選択しますが、それは
 色の違いではなく、点線/破線パターンや線幅の違いによるものです。このコ
 マンドは、gnuplot の以前のバージョンのある出力形式で monochrome オプシ
 ョンとして提供していたものに置き換わるもので、後方互換性のため、それら
 の出力形式で "mono" オプションを指定すると、暗黙で `set monochrome` を
 呼び出します。
 例えば、
      set terminal pdf mono
 は、以下と同等です。
      set terminal pdf
      set mono

 白黒モード (monochrome) の選択は、明示的な RGB 色、パレット色を使用し
 てのカラーの線の描画を妨げるものではありませんが、以下も参照:
 `set palette gray`。
 デフォルトでは 6 つの白黒線種が定義されていますが、それらの属性を変更
 したり、白黒線種を追加することは、フル形式でそのコマンドを使用すること
 でできます。白黒線種にほどこされた変更は、カラーの線種には影響を与えま
 せんし、その逆も同様です。カラー線種に復帰するには、`unset monochrome`
 か、`set color` としてください。
?commands set mouse
?commands unset mouse
?set mouse
?unset mouse
?mousing
?mouse
?nomouse
 コマンド `set mouse` は、現在の対話型出力形式に対してマウス機能を有効
 にします。対話型モードでは通常デフォルトでこれは有効になっていますが、
 コマンドがファイルから読み込まれる場合はデフォルトでは無効になっていま
 す。

 マウスモードは 2 種類用意されています。2 次元モードは、`plot` コマンド
 と `splot` の 2 次元射影 (すなわち、z の回転角が 0, 90, 180, 270, 360
 度の `set view`、および `set view map`) で動作します。このモードでは、
 マウス位置が追跡され、マウスボタンや矢印キーを使って拡大したり視点移動
 したりできます。グラフに対応する凡例のタイトルや別なウィジェットアイコ
 ンなどをクリックすることで、個々のグラフの描画をオン/オフに切り替える
 ことをサポートする出力形式もあります。

 `splot` による 3 次元グラフに対しては、グラフの視方向 (view) と縮尺の
 変更が、それぞれマウスボタン 1 と 2 (によるドラッグ) で行えます。ボタ
 ン 2 の垂直方向のドラッグを shift キーと同時に行うと、z 軸の一番下の位
 置 (`xyplane`) を上下します。これらのボタンにさらに <ctrl> キーを押す
 と、座標軸は表示されますが、データの表示は消えます。これは大きなデータ
 に対して有用でしょう。マウスボタン 3 は、z 軸の向き (azimuth) を制御し
 ます (以下参照: `set view azimuth`)。

 マウスは多重描画 (multiplot) モード内では無効ですが、`unset multiplot`
 で多重描画が完結すれば、マウス機能は ON になります。ただし、その作用は
 multiplot 内の最後の描画 (replot で描画されるようなもの) に対してのみ
 です。

 書式:
       set mouse {doubleclick <ms>} {nodoubleclick}
                 {{no}zoomcoordinates}
                 {zoomfactors <xmultiplier>, <ymultiplier>}
                 {noruler | ruler {at x,y}}
                 {polardistance{deg|tan} | nopolardistance}
                 {format <string>}
                 {mouseformat <int>/<string>}
                 {{no}labels {"labeloptions"}}
                 {{no}zoomjump} {{no}verbose}
       unset mouse

 オプション `noruler` と `ruler` は、定規 (ruler) 機能を off, on にしま
 す。`ruler` には座標を与えて原点を設定することもできます。`ruler` が
 on の間、ruler の原点からマウスまでのユーザ単位での距離が連続的に表示
 されます。デフォルトでは、ruler のトグルスイッチは 'r' にキー割り当て
 されています。

 オプション `polardistance` は、マウスカーソルから定規 (ruler) までの距
 離を極座標でも表示 (距離、および角度または傾き) するかどうかを決定しま
 す。これはデフォルトのキー割り当て '5' に対応します。

 ボタン 2 の gnuplot の永続的なラベルを定義するには、オプション
 `labels` を使用します。デフォルトは `nolabels` で、ボタン 2 は単に一時
 的なラベルをマウス位置に描画します。ラベルは現在の `mouseformat` の設
 定に従って書かれます。`labeloptions` 文字列は、コマンド `set label` コ
 マンドに渡されます。そのデフォルトは "point pointstyle 1" で、これはラ
 ベル位置に小さいプラス (`+`) を描画します。一時的なラベルは、その次の
 `replot`、またはマウスズーム操作では現れません。永続的なラベルは、ラベ
 ルの点の上で Ctrl キーを押してボタン 2 をクリックすることで消すことが
 できます。実際のラベルの位置にどれ位近くでクリックしなければいけないか
 の閾値も `pointsize` で決定されます。

 オプション `verbose` が ON の場合、実行時の報告コマンドが表示されます。
 このオプションはドライバウィンドウ上で `6` を打つことで ON/OFF がスイ
 ッチできます。デフォルトでは `verbose` は OFF になっています。

 ドライバウィンドウ上で 'h' を打つと、マウスとキー割当の短い説明が表示
 されます。これは、ユーザ定義のキー割当、すなわち `bind` コマンドによる
 `hotkeys` (以下参照: `bind`) も表示されます。ユーザ定義の `hotkeys` は
 デフォルトのキー割当を無効にします。
 以下も参照: `bind`, `label`。
?set mouse doubleclick
?mouse doubleclick
 ダブルクリックの解像度はミリ秒 (ms) 単位で与えます。これは、ボタン 1
 用のもので、現在のマウス位置をクリップボード (`clipboard`) にコピーす
 るのに使う出力形式があります。デフォルトの値は 300 ms です。これを 0
 ms に設定するとシングルクリックでそのコピーを行うようになります。
?set mouse format
?set mouse mouseformat
?mouse format
?mouseformat
 コマンド `set mouse format` は、sprintf() に対する書式文字列の指定で、
 マウスカーソルの [x,y] 座標を描画ウィンドウとクリップボードにどのよう
 に表示するかを決定します。デフォルトは "% #g" です。

 `set mouse mouseformat` は、ボタン 1 とボタン 2 の作用時 (座標をクリッ
 プボードへコピーし、マウス位置に一時的に注釈をつける) の文字列の書式用
 に使われます。引数が整数の場合、以下の表にある書式オプションの一つを選
 択します。引数が文字列の場合は、書式オプション 6 の sprintf() の書式文
 字列として使われますので、2 つの実数の指定子を含む必要があります。例:
      `set mouse mouseformat "mouse x,y = %5.2g, %10.3f"`.
 この文字列をまたオフにするには、`set mouse mouseformat ""` とします。

 以下の書式が利用可能です:

  0   デフォルト (1 と同じ)
  1   軸の座標                            1.23, 2.45
  2   グラフ座標 (0 から 1 まで)         /0.00, 1.00/
  3   x = timefmt     y = 軸座標         [(`set timefmt` の設定), 2.45]
  4   x = 日付        y = 軸座標         [31. 12. 1999, 2.45]
  5   x = 時刻        y = 軸座標         [23:59, 2.45]
  6   x = 日付/時刻   y = 軸座標         [31. 12. 1999 23:59, 2.45]
  7   `set mouse mouseformat` による書式、例: "mouse x,y = 1.23,     2.450"
?set mouse scrolling
?mouse scrolling
?mouse wheel
?scrolling
?mousewheel
 2 次元グラフと 3 次元グラフの両方で、X と Y 軸の伸縮はマウスホイールを
 使うことで調整できます。<wheel-up> はスクロールアップし (YMIN と YMAX
 の両方を Y の範囲の 10 パーセントずつ増加させ、Y2MIN と Y2MAX にも同様
 のことを行います)、<wheel-down> はスクロールダウンします。
 <shift-wheel-up> は左スクロールし (XMIN と XMAX の両方、そして X2MIN
 と X2MAX の両方を減少)、<shift-wheel-down> は右スクロールします。
 <control-wheel-up> はグラフの中心方向にズームインし、
 <control-wheel-down> はズームアウトします。<shift-control-wheel-up> は
 X と X2 軸のみに沿ってズームインし、<shift-control-wheel-down> は X と
 X2 軸に沿ってのみズームアウトします。
?mouse x11_mouse
?x11_mouse
?x11 mouse
 x11 の出力形式のオプション `set term x11 <n>` を使って複数の X11 描画
 ウィンドウが開いている場合、マウスコマンドとホットキーの機能をちゃんと
 使えるのは現在の描画ウィンドウのみです。しかし、他のウィンドウも左下に
 マウスの座標を表示位はしてくれるでしょう。
?mouse zoom
?zoom
 拡大 (zoom) は、通常は左マウスボタンを押すことで行われ、拡大範囲の線引
 きはマウスのドラッグで行いますが、これとは異なるマウスボタンを要求する
 実行環境もあるかもしれません。元のグラフは、グラフウィンドウ上でホット
 キー 'u' をタイプすることで復元できます。ホットキー 'p' と 'n' は、拡
 大操作の履歴を後方と前方にたどります。

 オプション `zoomcoordinates` は、拡大の際に、拡大の枠の端にその座標を
 書くかどうかを決定し、デフォルトでは ON になっています。

 オプション `zoomjump` が ON の場合、ボタン 3 による拡大範囲の選択を開
 始すると、マウスポインタは自動的に少しだけずれた位置に移動します。これ
 は、ごく小さい (または空でさえある) 拡大範囲を選択してしまうことを避け
 るのに便利でしょう。デフォルトでは `zoomjump` は OFF です。

?commands set mttics
?commands unset mttics
?commands show mttics
?set mttics
?unset mttics
?show mttics
?mttics
?nomttics
 極座標グラフの周囲の小目盛り刻みの印は `set mttics` で制御されます。以
 下参照: `set mxtics`。
?commands set multiplot
?commands unset multiplot
?set multiplot
?unset multiplot
?multiplot
?nomultiplot
?layout
 コマンド `set multiplot` は `gnuplot` を多重描画モードにします。これ
 は、複数のグラフを同じページや同じスクリーンウィンドウに隣り同士に並
 べて表示します。

 書式:
       set multiplot
           { title <page title> {font <fontspec>} {enhanced|noenhanced} }
           { layout <rows>,<cols>
             {rowsfirst|columnsfirst} {downwards|upwards}
             {scale <xscale>{,<yscale>}} {offset <xoff>{,<yoff>}}
             {margins <left>,<right>,<bottom>,<top>}
             {spacing <xspacing>{,<yspacing>}}
           }
       set multiplot {next|previous}
       unset multiplot

 出力形式 (terminal) によっては、コマンド `unset multiplot` が与えられ
 るまで何の描画も表示されないことがあります。この場合このコマンドにより
 ページ全体の描画が行なわれ、gnuplot は標準の単一描画モードになります。
 それ以外の出力形式では、各 `plot` コマンドがそれぞれ表示を更新します。

 コマンド `clear` は、次の描画に使う長方形領域を消すのに使えます。典型
 的には、大きいグラフの内部に小さなグラフを挿入するような場合に必要です。

 定義済の見出しやベクトルは、各描画において、毎回現在のサイズと原点に従
 って書かれます (それらが `screen` 座表系で定義されていない場合)。それ
 以外の全ての `set` で定義されるものも各描画すべてに適用されます。もし
 1 度の描画にだけ現われて欲しいものを作りたいなら、それが例えば日付
 (timestamp) だとしたら、`set multiplot` と `unset multiplot` で囲まれ
 たブロック内の `plot` (または `splot`, `replot`) 命令の一つを
 `set time` と `unset time` ではさんでください。

 multiplot のタイトルは、個々の描画タイトルがあったとしても、それとは別
 のもので、ページの上部にそのためのキャンバス全体の幅にわたるスペースが
 確保されます。

 layout が指定されていない場合、あるいはより良い位置決めをしたい場合は、
 コマンド `set origin` と `set size` 各描画で正しい位置に設定する必要が
 あります。詳細は、以下参照: `set origin`, `set size`。

 例:
       set multiplot
       set size 0.4,0.4
       set origin 0.1,0.1
       plot sin(x)
       set size 0.2,0.2
       set origin 0.5,0.5
       plot cos(x)
       unset multiplot

 これは、cos(x) のグラフを、sin(x) の上に積み重ねて表示します。

 `set size` と `set origin` は全体の描画領域を参照し、それは各描画で利
 用されます。以下も参照: `set term size`。描画境界を一列に揃えたいなら
 ば、`set margin` コマンドで、境界の外の余白サイズを同じサイズに揃える
 ことが出来ます。その使用に関しては、以下参照: `set margin`。余白サイズ
 は文字サイズ単位の絶対的な数値単位を使用することに注意してください。よ
 って残ったスペースに描かれるグラフは表示するデバイスの表示サイズに依存
 します。例えば、プリンタとディスプレイの表示は多分違ったものになるでし
 ょう。

 オプション `layout` により、各描画の前にそれぞれ与えていた `set size`
 や `set origin` コマンドなしに、単純な複数グラフの描画を作成できます。
 それらの設定は自動的に行なわれ、いつでもその設定を変更できます。
 `layout` では表示は <rows> 行と <cols> 列の格子に分割され、各格子は、
 その後に続く対応する名前のオプションによって行 (rowsfirst)、あるいは列
 (columnsfirst) が先に埋められて行きます。描画グラフの積み上げは下方向
 (`downwards`) に、または上方向 (`upwards`) に伸びるようにできます。デ
 フォルトは `rowsfirst` で `downwards` です。
 コマンド `set multiplot next` と `set multiplot previous` は、レイアウ
 トオプションを使用している場合のみに関係します。`next` は、格子内の次
 の位置をスキップし、空白を残します。`prev` は、直前に描画した位置の直
 前の格子位置に戻ります。

 各描画は `scale` で伸縮を、`offset` で位置の平行移動を行なうことができ
 ます。scale や offset の y の値が省略された場合は、x の値がそれに使用
 されます。`unset multiplot` により自動配置機能はオフになり、そして
 `set size` と `set origin` の値は `set multiplot layout` の前の状態に
 復帰されます。

 例:
       set size 1,1
       set origin 0,0
       set multiplot layout 3,2 columnsfirst scale 1.1,0.9
       [ ここには 6 つまでの描画コマンド ]
       unset multiplot

 上の例では 6 つの描画が 2 列の中に上から下へ、左から右へと埋められて行
 きます。各描画は水平サイズが 1.1/2、垂直サイズが 0.9/3 となります。

 他にも、そのレイアウト内のすべてのグラフに一様なマージンをオプション
 `layout margins` と `spacing` で設定することができますが、これは一緒に
 使う必要があります。`margins` は、格子配置の複数グラフ全体の外側に対す
 るマージンを設定します。

 `spacing` は、隣接する部分グラフ間の隙間を与えますが、`character` か
 `screen` 単位で指定することもできます。単一の値を指定すると、それは x,
 y の両方の方向に使用されますが、2 つの異なる値を指定することもできます。

 一つの値に単位がなければ、直前のマージン設定のものを使用します。

 例:
       set multiplot layout 2,2 margins 0.1, 0.9, 0.1, 0.9 spacing 0.0

 この場合、左にあるグラフの左の境界は、スクリーン座標の 0.1 に置かれ、
 右にあるグラフの右の境界はスクリーン座標 0.9 の場所に置かれる、等とな
 ります。各グラフの隙間は 0 に指定しているので、内側の境界線は重なりま
 す。

 例:
       set multiplot layout 2,2 margins char 5,1,1,2 spacing screen 0, char 2

 これは、左のグラフの境界は、キャンバスの左端から 5 文字幅の場所に、右
 のグラフの右の境界は、キャンバスの端から 1 文字幅の場所にあるようなレ
 イアウトを生成します。下のマージンは 1 文字分の高さ、上のマージンは 2
 文字分の高さになります。グラフ間の水平方向の隙間はありませんが、縦方向
 には 2 文字分の高さに等しい隙間があります。

 例:
       set multiplot layout 2,2 columnsfirst margins 0.1,0.9,0.1,0.9 spacing 0.1
       set ylabel 'ylabel'
       plot sin(x)
       set xlabel 'xlabel'
       plot cos(x)
       unset ylabel
       unset xlabel
       plot sin(2*x)
       set xlabel 'xlabel'
       plot cos(2*x)
       unset multiplot

 以下も参照
 multiplot のデモ (multiplt.dem)
?commands set mx2tics
?commands unset mx2tics
?commands show mx2tics
?set mx2tics
?unset mx2tics
?show mx2tics
?mx2tics
?nomx2tics
 x2 (上) 軸の小目盛り刻みの印は `set mx2tics` で制御されます。以下参照:
 `set mxtics`。
?commands set mxtics
?commands unset mxtics
?commands show mxtics
?set mxtics
?unset mxtics
?show mxtics
?mxtics
?nomxtics
 x 軸の小目盛り刻みの印は `set mxtics` で制御されます。`unset mxtics`
 によってそれを表示させなくすることが出来ます。同様の制御コマンドが各軸
 毎に用意されています。

 書式:
       set mxtics {<freq> | default}
       unset mxtics
       show mxtics

 これらの書式は `mytics`, `mztics`, `mx2tics`, `my2tics`, `mrtics`,
 `mttics`, `mcbtics` に対しても同じです。

 <freq> は大目盛り間の、小目盛りによって分割される区間の数 (小目盛りの
 数ではありません) です。通常の線形軸に対してはデフォルトの値は 2 か 5
 で、これは大目盛りによって変化します。よって大目盛り間に 1 つ、または
 4 つの小目盛りが入ることになります。`default` を指定することによって小
 目盛りの数はデフォルトの値に戻ります。

 軸が対数軸である場合、分割区間の数はデフォルトでは有意な数にセットされ
 ます (10 個の長さを元にして)。<freq> が与えられていればそちらが優先さ
 れます。しかし、対数軸では通常の小目盛り (例えば 1 から 10 までの 2, 3,
 ..., 8, 9 の刻み) は、9 つの部分区間しかありませんが、<freq> の設定は
 10 とすることでそうなります。

 小目盛りを任意の位置に設定するには、("<label>" <pos> <level>, ...) の
 形式を `set {x|x2|y|y2|z}tics` で使用してください。ただし、<label> は
 空 ("") で、<level> を 1 にします。

 コマンド `set m{x|x2|y|y2|z}tics` は、大目盛りが一様の間隔の場合にのみ
 働きます。もし全ての大目盛りが `set {x|x2|y|y2|z}tics` によって手動で
 配置された場合は、この小目盛りのコマンドは無視されます。自動的な大目盛
 りの配置と手動の小目盛りの配置は、`set {x|x2|y|y2|z}tics` と
 `set {x|x2|y|y2|z}tics add` とを使うことで共存できます。

 例:
       set xtics 0, 5, 10
       set xtics add (7.5)
       set mxtics 5
 この場合、大目盛りは 0,5,7.5,10、小目盛りは 1,2,3,4,6,7,8,9 の場所
       set logscale y
       set ytics format ""
       set ytics 1e-6, 10, 1
       set ytics add ("1" 1, ".1" 0.1, ".01" 0.01, "10^-3" 0.001, \
                      "10^-4" 0.0001)
       set mytics 10
 この場合、大目盛りは指定された書式で、小目盛りは対数的に配置

 デフォルトでは小目盛りの表示は、線形軸ではオフで、対数軸ではオンになっ
 ています。その設定は、大目盛りに対する `axis|border` と `{no}mirror`
 の指定を継承します。これらに関する情報については、以下参照:
 `set xtics`。
?commands set my2tics
?commands unset my2tics
?commands show my2tics
?set my2tics
?unset my2tics
?show my2tics
?my2tics
?nomy2tics
 y2 (右) 軸の小目盛り刻みの印は `set my2tics` で制御されます。以下参照:
 `set mxtics`。
?commands set mytics
?commands unset mytics
?commands show mytics
?set mytics
?unset mytics
?show mytics
?mytics
?nomytics
 y 軸の小目盛り刻みの印は `set mytics` で制御されます。以下参照:
 `set mxtics`。
?commands set mztics
?commands unset mztics
?commands show mztics
?set mztics
?unset mztics
?show mztics
?mztics
?nomztics
 z 軸の小目盛り刻みの印は `set mztics` で制御されます。以下参照:
 `set mxtics`。
?commands set nonlinear
?set nonlinear
?nonlinear
 書式:
       set nonlinear <axis> via f(axis) inverse g(axis)
       unset nonlinear <axis>

 [version 5.2 での新コマンド]
 このコマンドはコマンド `set link` に似ていますが、2 つのリンクされた軸
 の一方のみを表示する点が違います。隠される軸は線形軸のままです。表示す
 る軸に沿う座標は、g(x) を適用して隠れている軸の座標から割り当てられ、
 f(x) は表示する軸の座標を隠れている線形軸に対応させます。

 例:

       set xrange [1:1000]
       set nonlinear x via log10(x) inverse 10**x

 この例は対数軸を作成していて、`set log x` と同じ効果を生むもう一つの方
 法です。この場合隠れている軸は、[log10(xmin):log10(xmax)] を計算するこ
 とで [0:3] という範囲を持ちます。変換式と逆変換式は、その両方を指定す
 る必要があります。

 例:

       set xrange [-3:3]
       set nonlinear x via norm(x) inverse invnorm(x)

 この例は確率スケール ("プロビット") の x 軸を作成し、累積正規分布関数
 Phi(x) のグラフが線形の y 軸に対して直線となります。

 例:

       logit(p) = log(p/(1-p))
       logistic(a) = 1. / (1. + exp(-a))
       set xrange [.001 : .999]
       set nonlinear y via logit(y) inverse logistic(y)
       plot logit(x)

 この例はロジットスケールの y 軸を作成し、線形の x 軸に対する logit(x)
 のグラフが直線になります。

 例:

       f(x) = (x <= 100) ? x : (x < 500) ? NaN : x-390
       g(x) = (x <= 100) ? x : x+390
       set xrange [0:1000] noextend
       set nonlinear x via f(x) inverse g(x)
       set xtics add (100,500)
       plot sample [x=1:100] x, [x=500:1000] x

 この例は "切断軸" を作成します。x 座標は左に 0 から 100、右に 500 から
 1000 が並び、その間に 10 幅の小さな隙間ができます。100 < x < 500 の間
 のデータは描画されず、これは期待通りの動作をします。
?objects
?commands set object
?commands show object
?set object
?show object
 コマンド `set object` は、その後のすべてのグラフに現れる単一のオブジェ
 クトを定義します。オブジェクトはいくつでも定義できます。オブジェクトの
 型は、現在は `rectangle` (長方形)、`circle` (円)、`ellipse` (楕円) を
 サポートしています。長方形は、コマンド `set style rectangle` によって
 設定されたスタイルの属性の組 (塗り潰し、色、境界) をデフォルトとして受
 け継ぎますが、個々のオジェクトを別々のスタイル属性で描画することももち
 ろん可能です。円と楕円は、`set style fill` による塗り潰しスタイルを受
 け継ぎます。2 次元グラフのオブジェクトは、軸座標、グラフ座標 (`graph`),
 極座標、スクリーン座標 (`screen`) のいずれの組み合わせでも定義できます。

 3 次元グラフのオブジェクト指定では、グラフ座標は使えません。3 次元の長
 方形と楕円は、スクリーン座標だけに制限されています。

 書式:
     set object <index>
         <object-type> <object-properties>
         {front|back|behind} {clip|noclip}
         {fc|fillcolor <colorspec>} {fs <fillstyle>}
         {default} {lw|linewidth <width>} {dt|dashtype <dashtype>}
     unset object <index>

 <object-type> は、`rectangle`, `ellipse`, `circle`, `polygon` のいずれ
 かです。個々のオブジェクトの型は、その型に特有の性質もいくつか持ってい
 ます。

 `front` を指定すると、オブジェクトはすべての描画要素の前 (上) に描画さ
 れますが、`front` と指定されたラベルよりは後ろ (下) になります。`back`
 を指定すると、すべての描画要素、すべてのラベルの後ろに配置されます。
 `behind` は、軸や `back` の長方形を含むすべてのものの後ろに配置されま
 す。よって、
     set object rectangle from screen 0,0 to screen 1,1 behind
 は、グラフやページ全体の背景に色をつけるのに利用できます。

 デフォルトでは、オブジェクトは、少なくとも 1 つの頂点がスクリーン座標
 で与えられていない限り、グラフ境界でクリッピングされます。`noclip` と
 設定すると、グラフ境界でのクリッピングは無効になりますが、スクリーンサ
 イズに対するクリッピングは行われます。

 オブジェクトの塗り潰しの色は <colorspec> で指定します。`fillcolor` は
 `fc` と省略できます。塗り潰しスタイルは <fillstyle> で指定します。詳細
 は、以下参照: `colorspec`, `fillstyle`。キーワード `default` を指定す
 ると、これらの属性は描画が実際に行われるときのデフォルトの設定を受け継
 ぎます。以下参照: `set style rectangle`。
?rectangle
?commands set object rectangle
?commands show object rectangle
?set object rectangle
?show object rectangle
 書式:
     set object <index> rectangle
         {from <position> {to|rto} <position> |
          center <position> size <w>,<h> |
          at <position> size <w>,<h>}

 長方形の位置は、対角に向かい合う 2 つの頂点 (左下と右上) の位置、ある
 いは中心点の位置と横幅 (<w>) と縦幅 (<h>) で指定できます。いずれの場合
 も点の位置は、軸の座標 (`first`, `second`)、グラフ領域内の相対座標
 (`graph`)、スクリーン座標 (`screen`) のいずれかを使用できます
 (以下参照: `coordinates`)。オプション `at` と `center` は同じ意味です。

 例:
     # 座標軸で囲まれた領域全体の背景を水色に
     set object 1 rect from graph 0, graph 0 to graph 1, graph 1 back
     set object 1 rect fc rgb "cyan" fillstyle solid 1.0

     # 左下角が 0,0, 右上角が 2,3 の赤い四角を一つ置く
     set object 2 rect from 0,0 to 2,3 fc lt 1

     # 青い境界の空 (塗り潰さない) 長方形を置く
     set object 3 rect from 0,0 to 2,3 fs empty border rgb "blue"

     # 頂点は移動しないまま、塗り潰しと色をデフォルトに変更
     set object 2 rect default

 スクリーン座標で長方形の角を指定すると、それは現在のグラフ領域の端を越
 えることも可能ですが、その他の場合は長方形はグラフ内に収まるようにクリ
 ッピングされます。

?ellipse
?commands set object ellipse
?commands show object ellipse
?set object ellipse
?show object ellipse
 書式:
     set object <index> ellipse {at|center} <position> size <w>,<h>
         {angle <orientation>} {units xy|xx|yy}
         {<other-object-properties>}

 楕円の位置は、中心を指定し、その後ろに幅と高さ (主軸と副軸) を指定しま
 す。キーワード `at` と `center` は同じ意味です。中心の位置の指定には、
 軸の座標 (`first`, `second`)、グラフ領域内の相対座標 (`graph`)、スクリ
 ーン座標 (`screen`) のいずれかを使用できます (以下参照: `coordinates`)。
 主軸と副軸の長さは、軸の座標で与えなければいけません。楕円の向き
 (orientation) は、水平軸と楕円の主軸との間の角度で指定します。角度を与
 えなければ、デフォルトの楕円の向きが代わりに使われます (以下参照:
 `set style ellipse`)。キーワード `units` は、楕円の軸の縮尺の制御に使
 用します。`units xy` は、主軸は x 軸の単位で、副軸は y 軸の単位で計算
 しますが、`units xx` は両軸とも x 軸の単位で縮尺し、`units yy` は両軸
 とも y 軸の単位になります。
 デフォルトは `xy` ですが、`set style ellipse units` の設定でいつでも変
 更できます。

 注意: x 軸と y 軸の縮尺が等しくない場合 (そして `units xy` の場合)、回
 転後の主軸と副軸の比は正しくはなりません。

 `set object ellipse size <2r>,<2r>` と `set object circle <r>` とは、
 一般には同じことにはならないことに注意してください。circle の半径は常
 に x 軸の単位で計られ、よって x 軸と y 軸の縮尺が違ったり、描画のアス
 ペクト比が 1 でなくても、常に円が生成されます。`units` が `xy` に設定
 されていれば、'set object ellipse' では、最初の <2r> は x 軸の単位で、
 後ろの <2r> は y 軸の単位で計られますが、これは x 軸と y 軸の縮尺が同
 じで、かつ描画のアスペクト比が 1 である場合のみ円を生成することを意味
 します。しかし、`units` を `xx` や `yy` にセットすれば、コマンド
 `set object` で指定した直径は同じ単位で計算されるので、楕円は正しいア
 スペクト比を持ち、描画をリサイズしてもそのアスペクト比は保持されます。

?circle
?commands set object circle
?commands show object circle
?set object circle
?show object circle
 書式:
     set object <index> circle {at|center} <position> size <radius>
         {arc [<begin>:<end>]} {no{wedge}}
         {<other-object-properties>}

 円の位置は、中心を指定し、その後ろに半径を指定します。キーワード `at`
 と `center` は同じ意味です。2 次元グラフでは、位置と半径は任意の座標系
 で指定できます。以下参照: `coordinates`。3 次元グラフの円にはグラフ座
 標は使えません。そのどの場合でも、半径は軸、グラフ、スクリーンの水平方
 向の縮尺に対して計られ、水平方向と垂直方向の縮尺にずれがあっても、結果
 が常に正しく円になるように直されます。円をグラフの座標で描きたい (つま
 り水平軸と垂直軸のスケールが違う場合にはそれが楕円として表示されるよう
 にしたい) 場合は、代わりに `set object ellipse` を使ってください。

 デフォルトでは、完全な円が描画されます。オプションの `arc` に開始角と
 終了角を度を単位として指定すると円弧を描画します。円弧は、常に反時計回
 りに描かれます。

 以下も参照: `set style circle`, `set object ellipse`。

?polygon
?commands set object polygon
?commands show object polygon
?set object polygon
?show object polygon
 書式:
     set object <index> polygon
         from <position> to <position> ... {to <position>}
 または
         from <position> rto <position> ... {rto <position>}

 多角形の位置は、頂点の位置の列を与えることで指定できます。それらには、
 任意の座標系が使えます。相対的な座標 (rto) を指定する場合は、その座標
 系は前の頂点と同じ座標系でなければいけません。以下参照: `coordinates`。

 例:
     set object 1 polygon from 0,0 to 1,1 to 2,0
     set object 1 fc rgb "cyan" fillstyle solid 1.0 border lt -1

?commands set offsets
?commands unset offsets
?commands show offsets
?set offsets
?unset offsets
?show offsets
?offsets
?nooffsets
 オフセットは、自動縮尺されたグラフの中のデータの周りに空の境界を置く仕
 組みを提供します。オフセットは、x1,y1 軸と 2 次元の `plot` コマンドの
 みで意味を持ちます。

 書式:
       set offsets <left>, <right>, <top>, <bottom>
       unset offsets
       show offsets

 各オフセットは定数、または数式が使え、それらのデフォルトの値は 0 です。
 デフォルトでは、左右のオフセットは x1 軸と同じ単位で指定し、上下のオフ
 セットは y1 軸と同じ単位で指定しますが、キーワード "graph" を用いるこ
 とで軸の全範囲に対する割合としてオフセットを指定することもできます。正
 のオフセットの値は、軸の範囲を指定された方向へ伸ばします。例えば正の下
 方向のオフセットは y の最小値をより小さな値にします。許されている範囲
 での負のオフセットは、自動縮尺、あるいはクリッピングとの思いもよらぬ結
 果を生む可能性があります。自動縮尺機能から軸の範囲の調節を守りたい場合
 は、"set auto fix" も指定するといいでしょう。

 例:
       set auto fix
       set offsets graph 0.05, 0, 2, 2
       plot sin(x)

 この sin(x) のグラフの y の範囲は [-3:3] になります。それは、関数の
 y の範囲は [-1:1] に自動縮尺されますが、垂直方向のオフセットがそれぞ
 れ 2 であるためです。x の範囲は [-11:10] になりますが、これはデフォ
 ルトが [-10:10] でその全範囲が左に 0.05 の割合だけ伸ばされるためです。
?commands set origin
?commands show origin
?set origin
?show origin
?origin
 コマンド `set origin` はスクリーン上で曲面描画の原点を指定 (すなわち、
 グラフとその余白) するのに使用します。その座標系はスクリーン座標系
 (`screen`) で与えます。この座標系に関する情報については、以下参照:
 `coordinates`。

 書式:
       set origin <x-origin>,<y-origin>
?commands set output
?commands show output
?set output
?show output
?output
?output file
 デフォルトでは、グラフは標準出力に表示されます。コマンド `set output` は
 その出力を指定されたファイルやデバイスにリダイレクトします。

 書式:
       set output {"<filename>"}
       show output

 ファイル名は引用符で囲まなければなりません。ファイル名が省略された場合
 は、直前の `set output` で開かれたファイルがクローズされ、新たな出力が
 標準出力 (STDOUT) に送られます。(もし、`set output "STDOUT"` とすると
 出力は "STDOUT" という名前のファイルに送られるかもしれません ! ["かも
 しれない" というのは、例えば `x11` や `wxt` などの terminal (出力形式)
 では `set output` が無視されるからです。])

 `set terminal` と `set output` の両方を指定する場合、`set terminal` を
 先に指定する方が安全です。それは、ある種の terminal では、OS が必要と
 するフラグをセットすることがあるからです。例えば、バイナリファイルに対
 して別々の open コマンドを必要とするような OS などがそれに該当します。

 パイプをサポートする環境では、パイプ出力も有用です。例えば以下の通りで
 す:

       set output "|lpr -Plaser filename"
       set term png; set output "|display png:-"

 MS-DOS では、`set output "PRN"` とすると標準のプリンタに出力されます。
 VMS では出力は任意のスプール可能なデバイスに送ることが出来ます。
?commands set parametric
?commands unset parametric
?commands show parametric
?set parametric
?unset parametric
?show parametric
?parametric
?noparametric
 `set parametric` コマンドは `plot` および `splot` の意味を通常の関数描
 画から媒介変数表示 (parametric) 関数描画に変更します。`unset parametric`
 を使えば元の描画モードに戻ります。

 書式:
       set parametric
       unset parametric
       show parametric

 2 次元グラフにおいては、媒介変数表示関数はひとつの媒介変数に対する 2
 つの関数で定められます。例としては plot sin(t),cos(t) とすることによっ
 て円が描けます (アスペクト比が正しく設定されていれば。以下参照:
 `set size`)。`gnuplot` は、両方の関数が媒介変数による `plot` のために
 与えられていなければエラーメッセージを出します。

 3 次元グラフにおいては面は x = f(u,v), y = g(u,v), z = h(u,v) で定め
 られます。よって 3 つの関数を組で指定する必要があります。例としては、
 `cos(u)*cos(v),cos(u)*sin(v),sin(u)` とすることによって球面が描けます。
 `gnuplot` は、3 つ全部の関数が媒介変数による `splot` のために与えられ
 ていなければエラーメッセージを出します。

 これによって表現できる関数群は、単純な f(x) 型の関数群の内包することに
 なります。なぜならば、2 つ (3 つ) の関数は x, y (, z) の値を独立に計算
 する記述ができるからです。実際、t,f(t) のグラフは、一番目の関数のよう
 な恒等関数を用いて x の値が計算される場合に f(x) によって生成されるグ
 ラフと等価です。同様に、3 次元での u,v,f(u,v) の描画は、f(x,y) と等価
 です。

 媒介変数表示関数は、x の関数、y の関数 (、z の関数) の順に指定し、それ
 らは共通の媒介変数およびその変域で定義されることに留意して下さい。

 さらに、`set parametric` の指定は、新しい変数変域を使用することを暗に
 宣言します。通常の f(x) や f(x,y) が xrange、yrange (、zrange) を使用
 するのに対して、媒介変数モードではそれに加えて、trange, urange, vrange
 を使用します。これらの変域は `set trange`, `set urange`, `set vrange`
 によって直接指定することも、`plot` や `splot` で指定することもできます。
 現時点では、これらの媒介変数のデフォルトの変域は [-5:5] となっています。
 将来的にはこれらのデフォルト値をもっと有意なものに変更する予定です。
?paxis
?commands set paxis
?set paxis
?show paxis
 書式:
       set paxis <axisno> {range <range-options> | tics <tic-options>}
       show paxis <axisno> {range | tics}
 コマンド `set paxis` は、平行座標描画の p1, p2, ... 軸の一つに作用する
 こと以外は、`set xrange` や `set xtics` と同じです。以下参照:
 `parallelaxes`, `set xrange`, `set xtics`。range と tics コマンドへの
 通常のオプションは、平行座標描画スタイルには意味のないものもありますが、
 一応すべてを受けつけます。
?commands show plot
?show plot
 コマンド `show plot` は現在の描画コマンド、すなわち `replot` コマンド
 で再現される、直前に行われた `plot` や `splot` コマンドを表示します。

 さらにコマンド`show plot add2history` は、この現在の描画コマンドを
 `history` に書き出します。これは、`replot` を使って直前の描画コマンド
 に曲線を追加した場合、そしてコマンド行全体をすぐに編集したい場合に便利
 です。
?commands set pm3d
?commands show pm3d
?set pm3d
?show pm3d
?pm3d
 pm3d は `splot` の一つのスタイルで、パレットに割り付けられた 3 次元、
 4 次元データを、カラー/灰色の色地図/曲面として描画します。これはあるア
 ルゴリズムを用いていて、これはデータが格子状であっても、データ走査毎に
 点の数が違っているような非格子状のデータであっても、前処理することなく
 描画できます。

 書式 (オプションは任意の順で与えることができます):
       set pm3d {
                  { at <position> }
                  { interpolate <steps/points in scan, between scans> }
                  { scansautomatic | scansforward | scansbackward | depthorder }
                  { flush { begin | center | end } }
                  { ftriangles | noftriangles }
                  { clip1in | clip4in }
                  { {no}clipcb }
                  { corners2color
                    { mean|geomean|harmean|rms|median|min|max|c1|c2|c3|c4 }
                  }
                }
       show pm3d
       unset pm3d

 splot コマンドで `with pm3d` を指定した場合、またはデータや関数描画ス
 タイル (`style`) が大域的に pm3d にセットされている場合、あるいは、
 pm3d モードが `set pm3d implicit` となっている場合は、pm3d のカラー曲
 面が描画されます。後の 2 つの場合は、plot コマンドで指定したスタイルで
 生成される網目に p3md 曲面を追加する形で描画します。例えば、
       splot 'fred.dat' with lines, 'lola.dat' with lines
 は、各データ集合毎に折れ線による網目と pm3d 曲面の両方を描画します。
 オプション `explicit` が ON (または `implicit` が OFF) の場合は、属性
 `with pm3d` が指定された描画のみが pm3d 曲面として描画されます。例えば
       splot 'fred.dat' with lines, 'lola.dat' with pm3d
 は、'freq.dat' は折れ線で (線のみで)、'lola.dat' は pm3d 曲面で描画さ
 れます。

 gnuplot の起動時はそのモードは `explicit` になっています。歴史的、そし
 て互換性のために、コマンド `set pm3d;` (すなわちオプションを指定しない
 場合) と `set pm3d at X ...` (すなわち `at` が最初のオプションの場合)
 はモードを `implicit` に変更します。コマンド `set pm3d;` は、その他の
 オプションをそれらのデフォルトの状態に設定します。

 デフォルトのデータ/関数の描画スタイルを `pm3d` にしたい場合は、例えば
       set style data pm3d
 とします。この場合、オプション `implicit` と `explicit` は効力を持ちま
 せん。

 いくつかの描画においては、それらはコマンドラインで与えられた順に描画さ
 れることに注意してください。これは特に、以前の描画を上書きしてそれでそ
 の一部を隠してしまう可能性があるような曲面の塗りつぶしの際に関心を持た
 れるでしょう。

 p3md の色付けは、3 つの異なる位置 `top`, `bottom`, `surface` のいずれ
 か、またはすべてに行えます。以下参照: `pm3d position`。以下のコマンド
 は、異なった高さで 3 つの色付きの曲面を描きます:
       set border 4095
       set pm3d at s
       splot 10*x with pm3d at b, x*x-y*y, x*x+y*y with pm3d at t

 以下も参照: `set palette`, `set cbrange`, `set colorbox`。そしてもちろ
 んデモファイル `demo/pm3d.dem` も参考になるでしょう。
?pm3d algorithm

 まず、地図/曲面がどのように描かれるのかについて記述します。入力データ
 は、関数を評価して得られるかまたは `splot data file` から得られます。
 曲面は、走査 (孤立線) の繰り返しで構成されます。pm3d アルゴリズムでは、
 最初の走査で検出された隣り合う 2 点と、次の走査で検出された他の 2 点の
 間の領域が、これら 4 点の z の値 (または追加された 'color' 用の列の値、
 以下参照: `using`) に従って灰色で (または カラーで) 塗られます。デフォ
 ルトでは 4 つの角の値の平均値が使われますが、それはオプション
 `corners2color` で変更できます。それなりの曲面を描くためには、隣り合う
 2 点の走査が交差してはいけなくて、近接点走査毎の点の数が違いすぎてはい
 けません。もちろん、最も良いのは走査の点の数が同じことです。他には何も
 必要ではありません (例えばデータは格子状である必要もない)。他にもこの
 pm3d アルゴリズムは、入力された (計測された、あるいは計算された) 領域
 の外には何も描かない、という長所があります。

 曲面の色づけは、以下のような入力データに関して行われます:

 1. 関数、または 1 つか 3 つのデータ列からなるデータの splot: 上に述べ
 た四角形の 4 つの角の z 座標の平均値 (または `corners2color`) から、灰
 色の範囲 [0:1] を与える `zrange` または `cbrange` の範囲
 [min_color_z,max_color_z] への対応により、灰色/カラーの値が得られます。
 この値は、直接灰色の色地図用の灰色の値として使うことができます。正規化
 された灰色の値をカラーに対応させることもできます。完全な説明は、以下参
 照: `set palette`。

 2. 2 つか 4 つのデータ列からなるデータの splot: 灰色/カラーの値は、z
 の値の代わりに最後の列の座標を使って得られますので、色と z 座標が独立
 なものになります。これは 4 次元データの描画に使うことができます。

 他の注意:

 1. 物理学者の間では、gnuplot の文書やソースに現われる 'iso_curve' (孤
 立線) という言葉よりも、上で言及した '走査 (scan)' という言葉の方が使
 われています。1 度の走査と他の走査の記録により色地図を評価する、という
 のはそういう意味です。

 2. 'gray' や 'color' の値 (scale) は、滑らかに変化するカラーパレットへ
 の、連続な変数の線形写像です。その写像の様子は描画グラフの隣に長方形で
 表示されます。この文書ではそれを "カラーボックス (colorbox)" と呼び、
 その変数をカラーボックス軸の変数と呼びます。以下参照: `set colorbox`,
 `set cbrange`。
?lighting
?pm3d lighting
?pm3d nolighting
?set pm3d lighting
 デフォルトでは、pm3d の色の割り当ては、向きや視方位には依存しません。
 その状態は `set pm3d nolighting` に対応します。
 一方、コマンド `set pm3d lighting` は、一点の点光源からの照明からの
 50% の光による単純な光源モデルを選択します。周囲の明るさに対するその光
 源の強度は `set pm3d lighting primary <fraction>` で調整できます。反射
 光 (specular) を含ませる度合いは、その比率の設定ができます:
      set pm3d lighting primary 0.50 specular 0.0   # ハイライトなし
      set pm3d lighting primary 0.50 specular 0.6   # 強いハイライト
?pm3d position
?set pm3d position
 色の曲面は底面か天井 (この場合は灰色/カラーの平面地図) か曲面上の点の
 z 座標 (灰色/カラー曲面) に描くことができます。その選択は、オプション
 `at` に、`b`, `t`, `s` の 6 つまでの組合せの文字列をつけて指定すること
 で行えます。例えば `at b` は底面のみに描画しますし、`at st` は最初に曲
 面に描いて次に天井面に色地図を描きますし、`at bstbst` は ... 真面目な
 話、こんなものは使いません。

 塗られた四角形は、次から次へと描画されて行きます。曲面を描画する場合
 (`at s`)、後の四角形が前のものに重なり (上書きし) ます (gnuplot は塗ら
 れた多角形の網の重なりの相互作用を計算するような仮想現実ツールではあり
 ません)。 最初に走査されるデータを最初に描くか最後に描くかを切替えるス
 イッチオプション `scansforward` と `scansbackward` を試してみてくださ
 い。デフォルトは `scansautomatic` で、これは gnuplot 自身に走査の順を
 推測させます。一方で、オプション `depthorder` は四角形の順序を完全に再
 構成します。塗りつぶしは深さ順に並び変えされた後で行われ、これによりか
 なり複雑な曲面でも視覚的なものにすることができます。詳細は、以下参照:
 `pm3d depthorder`。
?pm3d scanorder
?pm3d depthorder
?pm3d flush
?pm3d ftriangles
?set pm3d scanorder
?set pm3d depthorder
?set pm3d flush
?set pm3d ftriangles
?depthorder
 デフォルトでは、pm3d の塗り潰し曲面を構成する四角形は、それらが曲面の
 格子点に沿って出会う順番に塗り潰されます。この順番は、オプション
 `scansautomatic`|`scansforward`|`scansbackward` で制御できます。これら
 の走査 (scan) オプションは、一般には隠面処理とは両立しません。

 2 回の連続する走査で点の数が同じでなかった場合、四角形の点の取り始めを、
 両方の走査の最初から (`flush begin`) にするか、最後から (`flush end`)
 にするか、真中から (`flush center`) にするかを決定しなければいけません。
 `flush (center|end)` は `scansautomatic` とは両立せず、よって
 `flush center` または `flush end` を指定して `scansautomatic` が設定さ
 れた場合、それは無言で `scansforward` に変更されます。

 2 回の連続する走査で点の数が同じでなかった場合、個々の走査で点が足りな
 い場合に、走査の最後に色三角形を描くかどうかをオプション `ftriangles`
 は指示します。これは滑らかな色地図の境界を描くのに使われます。

 gnuplot は、曲面の塗り潰しにおいては、本当の隠面処理は行いませんが、た
 いていは遠い方から近い方へ順に四角形要素を塗り潰すことで十分なできあが
 りになります。このモードは、以下のオプションを使うことで選択できます:
       set pm3d depthorder hidden3d
 オプション `depthorder` は塗り潰し四角形への指示で、オプション
 `hidden3d` は同様に境界線 (もし描くなら) への指示です。大域的なオプシ
 ョンである `set hidden3d` は、pm3d 曲面には影響しないことに注意してく
 ださい。

?pm3d clipping
?set pm3d clipping
?clipcb
?pm3d clipcb
?pm3d noclipcb
?noclipcb
 四角形の x,y 座標に関する pm3d のクリッピングは 2 つの方法で行われます。
 `clip1in`: 各四角形の全ての 4 点が定義されていなければならず、少なくと
 もそのうちの 1 点が x, y の範囲におさまっていなければなりません。
 `clip4in`: 各四角形の全ての 4 点が x, y の範囲におさまっていなければな
 りません。

 `clipcb`: (デフォルト) パレットカラー値は cbmin, cbmax 範囲内に。
 `noclipcb`: その時の cbrange 外のパレットカラー値の四辺形は何も描画し
 ません。

?pm3d color_assignment
 `3 列のデータ (x,y,z) の場合`:

 色づけの設定はカラーボックスの描画と同様に `set palette` で決定されま
 す。一つの描画では一つのパレットのみが存在し得ます。いくつもの曲面を異
 なるパレットで描画するには、`origin` と `size` を固定して `mutiplot`
 を使うことで行えます。出力ドライバが利用できる色を使い尽くしてしまう場
 合には `set palette maxcolors` を使うことを忘れずに。

 描画される各 pm3d 四角形には一つの灰色/カラー値が対応します (それは色
 勾配ではなく無地の色です)。その値は、`corners2color <option>` に従って
 4 つの角の z 座標から計算されます。
 `4 列のデータ (x,y,z,color) の場合`:

 4 列目にデータを与えた場合、それを通常は別にパレットに割り当てる灰色階
 調値とみなします。個々の四角形の彩色は上と同様に行いますが、色の値は z
 の値とは切り離されます。別の彩色オプションにより、4 列目のデータに RGB
 色を与えることもできます。以下参照: `rgbcolor variable`。この場合、描
 画コマンドは以下のようにする必要があります:

       splot ... using 1:2:3:4 with pm3d lc rgb variable

 与えられた節点に対して、その周りの 4 つの節点の平均化された (x,y) 座標
 から角を得て四角形を作って、その四角形を節点の色で塗る、といったような
 他の描画アルゴリズムが将来実装されるかもしれません。
 これは、イメージの描画 (2 次元の格子) に対しては `image` と `rgbimage`
 スタイルによって既に行なわれています。

 z の値の範囲と曲面の色の値の範囲は、z と cb に関する `set log` 同様、
 `set zrange` と `set cbrange` によって独立に調整し得ることに注意して
 ください。色地図は cb 軸のみで調節されます。以下も参照: `set view map`,
 `set colorbox`。
?pm3d corners2color
?set pm3d corners2color
?corners2color
 pm3d 曲面の各四角形の色は、その 4 つの頂点の色の値に基づいて割り当てら
 れます。<option> は 'mean' (デフォルト)、'geomean', 'harmean', 'rms',
 'median' で、曲面のカラーの平滑化に幾つかの種類を与え、'min','max' は
 それぞれ最小値、最大値を選択します。これらは鋭敏な、あるいは急激なピー
 ク値を持つようなピクセルイメージや色地図を作るときには必要ありません。
 そのような場合には、むしろオプション 'c1', 'c2', 'c3', 'c4' を使って、
 四角形の色の割当にただ一つの角の z 座標を使うようにすればいいでしょう。
 どの角が 'c1' に対応するのかを知るためには何回か実験してみる必要がある
 でしょう。その向きは描画の方向に依存しています。
 pm3d アルゴリズムは、カラー曲面を入力データ点の範囲の外には描かないの
 で、オプション 'c<j>' は、格子の 2 つのへりに沿ったピクセルが、どの四
 角形の色にも寄与しない、という結果をもたらします。例えば、pm3d アルゴ
 リズムを 4x4 のデータ点の格子に適用するスクリプト `demo/pm3d.dem` (是
 非見てください) では、(4-1)x(4-1)=9 色しかない長方形が生成されます。
?set pm3d hidden3d
?pm3d hidden3d
?set pm3d border
?pm3d border
 オプション `set pm3d border {line-properties}` は、各四角形の境界線を、
 四角形が描画されてあるように描画します。通常これは、擬似的な隠線処理を
 行うために、オプション `depthorder` とともに使用します。pm3d グラフで
 は、大域的なオプション `set hidden3d` は何の効果も生まないことに注意し
 てください。デフォルトの線の属性 (色、幅) を、キーワード border の後ろ
 にオプションとして後ろにつけます。そのデフォルト値は、その後の splot
 コマンドで変更できます。

 推奨する使用例:

       set pm3d at s depthorder border lw 0.2 lt black
       unset hidden3d
       unset surf
       splot x*x+y*y linecolor rgb "blue"   # こうしないと黒

 注: 非推奨のオプション `set pm3d hidden3d N` もまだ使えますが、これは
 `set pm3d border ls N` と同じです。

?set pm3d interpolate
?pm3d interpolate
 オプション `interpolate m,n` は、より細かな網目を作るために格子点間を
 補間します。データ描画に対しては、これは色の曲面を滑らかにし、その曲面
 の尖りを補正します。関数描画に対しては、この補間はほとんど意味はありま
 せんから、関数描画の場合は普通 `samples` や `isosamples` を使って標本
 数を増加させるのがいいでしょう。

 正の m, n に対しては各四角形、または三角形は、それぞれの方向に m 回、
 n 回補間されます。負の m, n では補間の頻度は、少なくとも |m|, |n| 点が
 描画されるように選択されます。これは特別な格子関数と見なすことができま
 す。

 注意: `interpolate 0,0` は、自動的に最適な補間曲面点数を選択します。

 注意: corners2color で幾何平均 (geomean) のような非線形評価が設定され
 ていたとしても、現在の色の補間は常に線形補間で行われます。
?set pm3d deprecated_options
?pm3d deprecated_options
?set pm3d map
?pm3d map
?map
 非推奨のコマンド `set pm3d map` は、以下の一連のものと同値です:
 `set pm3d at b; set view map; set style data pm3d; set style func pm3d;`
?commands set palette
?commands show palette
?set palette
?show palette
?palette
 パレットは、`pm3d` で、カラー等高線や多角形、カラーヒストグラム、色勾
 配の背景、その他実装されている、あるいは実装されるものの塗りつぶしで使
 われる、色の記憶場所です。ここではそれは滑らかで "連続的な" カラーや灰
 色階調のパレットを意味しますが、それを単にパレットと呼ぶことにします。

 カラーパレットは、多角形の色の塗りつぶしと滑らかな色のパレットをサポー
 トした出力形式を必要とし、それは現在、`pm3d` で一覧表示される出力形式
 で使用可能です。色の値の範囲は、`set cbrange` と `set log cb` で独立に
 調整可能です。カラーパレット全体は `colorbox` 中に表示されます。

 書式:
       set palette
       set palette {
                  { gray | color }
                  { gamma <gamma> }
                  {   rgbformulae <r>,<g>,<b>
                    | defined { ( <gray1> <color1> {, <grayN> <colorN>}... ) }
                    | file '<filename>' {datafile-modifiers}
                    | functions <R>,<G>,<B>
                  }
                  { cubehelix {start <val>} {cycles <val>} {saturation <val>} }
                  { model { RGB | HSV | CMY | XYZ } }
                  { positive | negative }
                  { nops_allcF | ps_allcF }
                  { maxcolors <maxcolors> }
                }
       show palette
       show palette palette <n> {{float | int}}
       show palette gradient
       show palette fit2rgbformulae
       show palette rgbformulae
       show colornames

 `set palette` は (すなわちオプションなしでは) デフォルトの値を設定しま
 す。それ以外の場合、オプションは任意の順に与えることができます。
 `show palette` は、現在のパレットの属性を表示します。

 `show palette gradient` は、パレットの勾配 (gradient) の定義が (それが
 適切であれば) 表示されます。`show palette rgbformulae` は、定義済で利
 用できる、灰色値からカラーへの変換公式が表示されます。
 `show colornames` は、認識できる色名を表示します。

 `show palette palette <n>` は、<n> 個の離散的な色を持つパレットの、現
 在のパレットの設定によって計算される RGB の値の組とパレットの表を、画
 面、または `set print` で指定されたファイルに書き出します。デフォルト
 の広い表は、追加のオプション float または int によって、3 列の [0..1]
 の実数値だけにするか [0..255] の整数値だけにするかをそれぞれ指定できま
 す。この方法で gnuplot のカラーパレットを、Octave のような他の画像アプ
 リケーションに渡すことができます。この他にも、コマンド `test palette`
 で、現在のパレットの R,G,B 成分の対応状態 (profile) を描画しその値をデ
 ータブロック $PALETTE に残させることもできます。

 以下のオプションは、色付けの属性を決定します。

 このパレットを使用する図は、`gray` か `color` になります。例えば、
 `pm3d` カラー曲面では、範囲 [min_z,max_z] が灰色の範囲 [0:1] に対応し
 ていて、微小曲面四角形の 4 つの角の z 座標の平均値をこの範囲の中に対応
 させることで各微小部分の灰色の値 (gray) が得られます。この値は、灰色階
 調の色地図での灰色の値として直接使うことができますし、カラーの色地図で
 は、その灰色の値から (R,G,B) への変換、すなわち [0:1] から
 ([0:1],[0:1],[0:1]) への写像が使われます。

 基本的に、2 種類の異なる写像方式が利用可能です: 1 つは灰色からカラーへ
 の解析的な公式、もう一つは離散的な対応表の補間によるものです。
 `palette rgbformulae` と `palette functions` が解析的な公式用で、
 `palette defined` と `palette file` が補間表用です。`palette rgbformulae`
 は postscript 出力のサイズを小さくすることができます。

 コマンド `show palette fit2rgbformulae` は、現在の `set palette` に最
 も良く対応する `set palette rgbformulae` を見つけ出します。当然、それ
 は rgbformulae パレット以外に対しても意味を持ちます。このコマンドは主
 に、パレットの rgbformulae 定義が gnuplot と同じ物を使っている外部プロ
 グラム、例えば zimg などにとって有用です (
           http://zimg.sourceforge.net
 )。

 `set palette gray` は、灰色階調のみのパレットにし、
 `set palette rgbformulae`, `set palette defined`, `set palette file`,
 `set palette functions` はカラーパレットにします。灰色パレットから直前
 のカラーパレットへ、`set palette color` で簡単に復帰できます。

 `set palette gamma <gamma>` による自動的なガンマ補正は、灰色のパレット
 (`set palette gray`) と、`cubehelix` カラーパレット形式に行われます。
 gamma = 1 の場合は、線形の光度勾配を生成します。以下参照:
 `test palette`。

 出力形式の多くは、有限個の色数しかサポートしていません (例えば gif で
 は 256 個)。デフォルトの gnuplot の線種色を割り当てた後の残りの有効な
 色領域は、デフォルトでは pm3d 用に保存されます。よって、複数のパレット
 を使用するような multiplot は、最初のパレットがすべての有効な色の配置
 として使用されてるので、失敗してしまうでしょう。このような制限は、十分
 小さい値 N で `set palette maxcolors <N>` を使うことで緩和できます。こ
 のオプションは、N 個の離散的な色を、連続的なパレットから等間隔なサンプ
 リングで選択します。不等間隔な N 個の離散色を使いたい場合は、一つの連
 続的なパレットの代わりに `set palette defined` を使用してください。

 RGB 色空間が作業を行うのに常にもっとも有用な色空間であるとは限らない、
 という理由で、色空間は `model` を使うことで、`RGB`, `HSV`, `CMY` のい
 ずれかに変更できます。RGB 以外の色空間では `set palette defined` の表
 で色名を使うと、それはおかしな色になります。
 全ての説明は RGB 色空間用に書いてありますが、それぞれの色空間で、例え
 ば `R` は `H`, `C` のことを意味することに注意してください (`G`, `B` も
 同様)。

 全ての色空間で、全ての値は [0,1] に制限されています。

 RGB は赤、緑、青を、CMY は水色 (Cyan)、紫 (Magenta)、黄 (Yellow) を、
 HSV は色相 (Hue)、彩度 (Saturation)、明度 (Value) をそれぞれ意味します。
 色モデルのより詳しい情報については以下を参照してください:
           http://en.wikipedia.org/wiki/Color_space
 注意: 以前のバージョンの gnuplot では、YIQ と XYZ の色空間モデルもサポ
 ートしていましたが、その実装は完全ではないか、正しくありませんでした。

?commands set palette rgbformulae
?set palette rgbformulae
?palette rgbformulae
?rgbformulae
 `rgbformulae` 用には 3 つの適切な割り当て関数が選ばれる必要があります。
 この選択は `rgbformulae <r>,<g>,<b>` を通して行われます。使うことがで
 きる割り当て関数の一覧は `show palette rgbformulae` で見ることができま
 す。デフォルトは `7,5,15` で、他の例としては `3,11,6`, `21,23,3`,
 `3,23,21` などがあります。`3,-11,-6` のような負の値は、逆のカラーを意
 味します (すなわち、1-gray をその関数に代入します)。

 RGB の色空間では、いくつかの良い割り当て公式があります:
    7,5,15   ... 伝統的 pm3d (黒-青-赤-黄)
    3,11,6   ... 緑-赤-紫
    23,28,3  ... 海 (緑-青-白); 他の組み合わせも試してみてください
    21,22,23 ... 温度色 (黒-赤-黄-白)
    30,31,32 ... 白黒のカラー表示化 (黒-青-紫-黄-白)
    33,13,10 ... 虹 (青-緑-黄-赤)
    34,35,36 ... AFM 温度色 (黒-赤-黄-白)

 HSV 色空間でのフルカラーパレット:
    3,2,2    ... 赤-黄-緑-水色-青-紫-赤

 `rgbformulae` という名前で呼ばれていても、例の通り、それらの関数は実際
 には <H>,<S>,<V> または <X>,<Y>,<Z>, ... といった色の成分を決定するか
 もしれないということに注意してください。

 図の色を反転させるには `positive` や `negative` を使ってください。

 他の色体系に対する最も良い rgbformulae の集合は、以下のコマンドで見つ
 けることができることを覚えておいてください。
    show palette fit2rgbformulae
?commands set palette defined
?set palette defined
?palette defined
 灰色から RGB への対応は `palette defined` を使うことで手動で設定できま
 す: 色勾配 (gradient) は RGB の値を与えるために定義され使用されます。
 勾配は、[0,1] の灰色値から [0,1]x[0,1]x[0,1] の RGB 空間への、区分的に
 線形な写像です。その線形補間に使われる灰色値と RGB 値の組を指定する必
 要があります:

 書式:
       set palette  defined { ( <gray1> <color1> {, <grayN> <colorN>}... ) }

 <grayX> は [0,1] に割り当てられるべき灰色値で、<colorX> はそれに対応す
 る RGB 色です。カラー値は 3 種類の方法で指定することができます:

      <color> :=  { <r> <g> <b> | '<color-name>' | '#rrggbb' }

 赤、緑、青に対応する空白で区切られた 3 つの値 (それぞれ [0,1] 内)、引
 用符でくくられた色名、または引用符でくくられた X 形式の指定方式、のい
 ずれかです。勾配の定義では、これらの 3 種の型を自由に組み合わせること
 ができますが、色空間として RGB でないものが選択された場合色名 "red" は
 少し違ったものになるでしょう。使用できる色名は `show colornames` でそ
 の一覧を見ることができます。

 <r> と書いても、HSV 色空間ではそれは <H> 成分を、といったように選択さ
 れたカラーモデルに依存して意味が違うことに注意してください。

 <gray> の値は実数の昇順に並べる必要があります。その列の値は自動的に
 [0,1] に変換されます。

 カッコつきの勾配の定義なしで `set palette defined` とした場合、RGB 色
 空間にし、あらかじめ設定されたフルスペクトル色勾配を使用します。勾配を
 表示するには `show palette gradient` を使用してください。

 例:

 灰色のパレット (役に立たないが教訓的な) を生成するには:
       set palette model RGB
       set palette defined ( 0 "black", 1 "white" )

 青黄赤のパレット (全てが等価の) を生成するには:
       set palette defined ( 0 "blue", 1 "yellow", 2 "red" )
       set palette defined ( 0 0 0 1, 1 1 1 0, 2 1 0 0 )
       set palette defined ( 0 "#0000ff", 1 "#ffff00", 2 "#ff0000" )

 虹のようなパレットを生成するには:
       set palette defined ( 0 "blue", 3 "green", 6 "yellow", 10 "red" )

 HSV 色空間でのフルカラースペクトル:
       set palette model HSV
       set palette defined ( 0 0 1 1, 1 1 1 1 )
       set palette defined ( 0 0 1 0, 1 0 1 1, 6 0.8333 1 1, 7 0.8333 0 1)

 MATLAB で使われるデフォルトパレットの近似:
       set pal defined (1 '#00008f', 8 '#0000ff', 24 '#00ffff', \
                        40 '#ffff00', 56 '#ff0000', 64 '#800000')

 等間隔な少しの色だけのパレットを生成するには:
       set palette model RGB maxcolors 4
       set palette defined ( 0 "yellow", 1 "red" )

 '交通信号' (滑らかではなく gray = 1/3, 2/3 で跳びを持つ):
       set palette model RGB
       set palette defined (0 "dark-green", 1 "green", \
                            1 "yellow",     2 "dark-yellow", \
                            2 "red",        3 "dark-red" )

?commands set palette functions
?set palette functions
?palette functions
 色の割り当ての R(gray), G(gray), B(gray) の 3 つの関数を与えるには
 `set palette functions <Rexpr>, <Gexpr>, <Bexpr>` を使ってください。
 それらの 3 つの関数の変数は、[0,1] の値を取る変数 `gray` であり、その
 値も [0,1] の中に取る必要があります。
 <Rexpr> は、HSV 色空間が選択されている場合は、H の値を表す式でなければ
 いけないことに注意してください (他の式、または他の色空間でも同様です)。

 例:

 フルカラーパレットを生成するには:
       set palette model HSV functions gray, 1, 1

 黒から金色への良いパレット:
       set palette model RGB functions 1.1*gray**0.25, gray**0.75, 0

 ガンマ補正の白黒のパレット:
       gamma = 2.2
       color(gray) = gray**(1./gamma)
       set palette model RGB functions color(gray), color(gray), color(gray)
?commands set palette gray
?set palette gray
?set palette grey
?palette gray
 `set palette gray` は、0.0 = 黒から 1.0 = 白への灰色階調 (グレイスケー
 ル) パレットに切り替えます。灰色階調パレットから、直前のカラーパレット
 にまた戻すには、`set palette color` とするのが簡単です。
?commands set palette cubehelix
?set palette cubehelix
?cubehelix
 オプション "cubehelix" はあるパレット族を定義しますが、これは、灰色階
 調値が 0 から 1 に増加するのに伴ない、正味の光度が単調に増加するのと同
 時に、色相 (hue) が標準色相環に従って変化します。
       D A Green (2011) http://arxiv.org/abs/1108.5083
 `start` は、色相環に沿った開始点をラジアン単位で決定します。
 `cycles` は、パレットの範囲を渡って色相環を何回回るかを決定します。
 `saturation` (彩度) が大きいと、よりあざやかな色になります。1 より大き
 い彩度は、個々の RGB 成分をクリッピングすることになり、光度は単調では
 なくなってしまいます。`set palette gamma` もパレットに影響を与えます。
 デフォルト値は以下の通りです。
       set palette cubehelix start 0.5 cycles -1.5 saturation 1
       set palette gamma 1.5

?commands set palette file
?set palette file
?palette file
 `set palette file` は基本的に `set palette defined (<gradient>)` と同
 じで、この <gradient> がデータファイルから読み込まれます。4 列 (gray,
 R,G,B) かまたは 3 列 (R,G,B) のデータが `using` データファイル修飾子に
 よって選択される必要があります。3 列の場合、行番号が gray の値として使
 われますが、その gray の範囲は自動的に [0,1] にスケール変換されます。
 ファイルは通常のデータファイルとして読まれるので、全てのデータファイル
 修飾子が使えます。
 例えば HSV 色空間が選択されている場合には、`R` は実際には `H` を指すと
 いうことに注意してください。

 例によって、<filename> が `'-'` の場合は、データがインライン形式で引き
 続いて与えられ、一つの `e` のみの行でそれが終了することを意味します。

 勾配 (gradient) を表示するには `show palette gradient` を使用してくだ
 さい。

 例:

 RGB のパレットを [0,255] の範囲で読み込む:
       set palette file 'some-palette' using ($1/255):($2/255):($3/255)

 等距離の虹色 (青-緑-黄-赤) パレット:
       set palette model RGB file "-"
       0 0 1
       0 1 0
       1 1 0
       1 0 0
       e

 バイナリパレットファイルも同様にサポートされています。以下参照:
 `binary general`。R,G,B の double のデータの 64 個の 3 つ組をファイル
 palette.bin に出力し、それを読み込む例:
       set palette file "palette.bin" binary record=64 using 1:2:3


?commands set palette gamma-correction
?set palette gamma-correction
?palette gamma-correction
?gamma-correction
 灰色の配色に対するガンマ補正は `set palette gamma <gamma>` で ON にで
 きます。<gamma> のデフォルトは 1.5 で、これは多くの出力形式に適切な値
 です。

 ガンマ補正は、cubehelix カラーパレット形式には適用されますが、他の色形
 式には適用されません。しかし、明示的な色関数にガンマ補正を実装するのは
 難しくありません。

 例:
       set palette model RGB
       set palette functions gray**0.64, gray**0.67, gray**0.70

 補間された勾配を使ってガンマ補正を行うには、適当なカラーに中間の値を指
 定します。

       set palette defined ( 0 0 0 0, 1 1 1 1 )

 の代わりに例えば以下を指定してください:

       set palette defined ( 0 0 0 0, 0.5 .73 .73 .73, 1 1 1 1 )

 または、線形補間が "ガンマ補正" の補間に十分良く適合するまでより良い中
 間の点を探してください。

?commands set palette postscript
?set palette postscript
 postscript ファイルのサイズを小さくする目的で、灰色の輝度値、そして全
 てではないいくつかの計算された RGB の輝度値がそのファイル中に書かれま
 す。成分関数は postscript 言語で直接コード化され、pm3d の描画の直前に
 ヘッダとしておかれます。/g や /cF の定義を参照してください。通常その定
 義をその中に書くことは、3 つの式のみが使われる場合に意味を持ちます。し
 かし、multiplot やその他の理由で postscript ファイル中のその変換関数を
 直接手で編集したいと思うかも知れません。これがデフォルトのオプション
 `nops_allcF` です。オプション `ps_allcF` を使うと、全ての公式の定義が
 postscript ファイル中に書かれます。一つのグラフ中で、異なる曲面に異な
 るパレットを持たせたいという目的で postscript ファイルを編集したい場合
 に、このオプションに関心を持つでしょう。その機能は、`origin` と `size`
 を固定して `multiplot` を使うことで実現できるでしょう。

 pm3d 曲面を PostScript ファイルへ書いている場合、gnuplot に付属する
 awk スクリプト `pm3dCompress.awk` を使うことで、そのファイルサイズを
 50% まで小さくできるかもしれません。データが四角形の格子状になっている
 場合は、スクリプト `pm3dConvertToImage.awk` を使うことでより大きな圧縮
 率が得られる可能性があります。
 使用法:
     awk -f pm3dCompress.awk thefile.ps >smallerfile.ps
     awk -f pm3dConvertToImage.awk thefile.ps >smallerfile.ps

?commands set pointintervalbox
?set pointintervalbox
?pointintervalbox
 線属性 `pointinterval`, `pointnumber` は、描画スタイル `linespoints`
 でのみ使われます。pointinterval や pointnumber の値を負、例えば -N と
 すると、点の記号を描く前に、各点の記号の後ろの箱 (実際には円) の部分
 を背景色で塗りつぶすことで消します。コマンド `set pointintervalbox` は
 その消す領域の大きさ (半径) を制御します。指定する値はデフォルトの半径
 (= pointsize) に対する倍率です。
?commands set pointsize
?commands show pointsize
?set pointsize
?show pointsize
?pointsize
 コマンド `set pointsize` は描画で使われる点の大きさを変更します。

 書式:
       set pointsize <multiplier>
       show pointsize

 デフォルトは 1.0 倍です。画像データ出力では、大きいポイントサイズの方
 が見やすいでしょう。

 一つの描画に対するポイントサイズは `plot` コマンドの上でも変更できます。
 詳細は、以下参照: `plot with`。

 ポイントサイズの設定は、必ずしも全ての出力形式でサポートされているわけ
 ではないことに注意してください。
?commands set polar
?commands unset polar
?commands show polar
?set polar
?unset polar
?show polar
?polar
?nopolar
 コマンド `set polar` はグラフの描画方法を xy 直交座標系から極座標系に
 変更します。

 書式:
       set polar
       unset polar
       show polar

 極座標モードでは、仮変数 (t) は角度θを意味します。t のデフォルトの範
 囲は [0:2*pi] ですが、単位として度が選択されていれば [0:360] となりま
 す (以下参照: `set angles`)。

 コマンド `unset polar` は描画方法をデフォルトの xy 直交座標系に戻しま
 す。

 `set polar` コマンドは `splot` ではサポートされていません。`splot` に
 対する同様の機能に関しては、以下参照: `set mapping`。

 極座標モードでは t の数式の意味は r=f(t) となり、t は回転角となります。
 trange は関数の定義域 (角度) を制御し、rrange, xrange, yrange はそれぞ
 れグラフの x,y 方向の範囲を制御することになります。これらの範囲と
 rrange は自動的に設定されるか、または明示的に設定できます。詳細に関し
 ては、以下参照: `set rrange`, `set xrange`。

 例:
       set polar
       plot t*sin(t)
       set trange [-2*pi:2*pi]
       set rrange [0:3]
       plot t*sin(t)

 最初の `plot` はデフォルトの角度の範囲の 0 から 2*pi を使います。動径
 方向とグラフのサイズは自動的に伸縮されます。2 番目の `plot` は角度の定
 義域を拡張し、グラフのサイズを原点から 3 の幅に制限します。これは x,y
 のそれぞれの方向を [-3:3] に制限することになります。

 デフォルトでは極座標グラフは角度 0 (θ=0) が右向きで、増加は反時計回り
 となるように向きづけられています。その 0 の向きと増加方向の両方を明示
 的に変更可能です。以下参照: `set theta`。

 `set size square` とすると `gnuplot` はアスペクト比 (縦横の比) を 1 に
 するので円が (楕円でなく) 円に見えるようになります。同心円の周囲の目盛
 りの刻みは、`set ttics` で指定できます。
 以下も参照
 極座標のデモ (polar.dem)
 および
 極座標データの描画 (poldat.dem)。
?commands set print
?commands show print
?set print
?show print
 コマンド `set print` は `print` コマンドの出力をファイルにリダイレクト
 します。

 書式:
       set print
       set print "-"
       set print "<filename>" [append]
       set print "|<shell_command>"
       set print $datablock [append]

 パラメータなしの `set print` は、出力を <STDERR> に復帰させます。"-"
 という <filename> は <STDOUT> を意味します。`append` フラグはファイル
 を追加 (append) モードで開くことを意味します。パイプをサポートするプラ
 ットホーム上では、<filename> が "|" で始まっていたら、<shell_command>
 へのパイプが開かれます。

 コマンド `print` の対象は名前付きデータブロックでも構いません。データ
 ブロック名は '$' で始まります。以下参照: `inline data`。
?commands set psdir
?commands show psdir
?set psdir
?show psdir
?psdir
 コマンド `set psdir <directory>` は、postscript 出力形式が prologue.ps
 や文字エンコード用のファイルを探すのに使用する検索パスを制御します。こ
 の仕組みは、別にローカルにカスタマイズした prolog ファイル群と切り替え
 るのに使えます。検索の順番は以下のようになっています。
       1) `set psdir` を指定した場合はそのディレクトリ
       2) 環境変数 GNUPLOT_PS_DIR で指定したディレクトリ
       3) 組み込まれたヘッダー、またはデフォルトのシステムディレクトリ
       4) `set loadpath` で指定したディレクトリ
?commands set raxis
?raxis
?set raxis
?unset raxis
 コマンド `set raxis` と `unset raxis` は、動径軸を格子線と x 軸から分
 離して描画するかどうかを切り替えます。現在の rrange の最小値が 0 でな
 い (そして自動縮尺でない) 場合、グラフと軸が原点に達しないことを示す白
 丸が極座標グラフの中心に描かれます。軸の線は、グラフの境界と同じ線種で
 描画されます。以下参照: `polar`, `rrange`, `rtics`, `rlabel`,
 `set grid`。
?commands set rgbmax
?set rgbmax
?rgbmax
?unset rgbmax
 書式:
      set rgbmax {1.0 | 255}
      unset rgbmax
 rgbimage グラフの RGB (赤、緑、青) 色成分は、デフォルトでは [0:255] の
 範囲の整数値であるとみなします。`set rgbmax 1.0` とすると、gnuplot は
 `rgbimage` や `rgbalpha` でのグラフの色成分の生成に使うデータ値を、
 [0:1] の範囲の実数値であるとみなします。`unset rgbmax` は、それをデフ
 ォルトの整数値の範囲 [0:255] に戻します。

 警告: このコマンドは試験段階です。詳細は変更する可能性があります。
 特に、gnuplot の将来の版では、rgbmax は大域的な設定ではなく、むしろフ
 ァイル毎、あるいは plot 毎に適切に設定される形で実装されるでしょう。
?commands set rlabel
?rlabel
?set rlabel
?unset rlabel
 このコマンドは、r 軸の上にラベルを配置します。そのラベルは、グラフが極
 座標モード (polar) であるか否かに関わらず表示されます。追加の指定キー
 ワードについては以下参照: `set xlabel`。
?commands set rmargin
?set rmargin
?rmargin
 コマンド `set rmargin` は右の余白のサイズをセットします。
 詳細は、以下参照: `set margin`。
?commands set rrange
?commands show rrange
?set rrange
?show rrange
?rrange
 コマンド `set rrange` は極座標モードのグラフの動径方向の範囲を設定しま
 す。これは xrange と yrange の両方も設定してしまいます。両者は、
 [-(rmax-rmin) : +(rmax-rmin)] になります。しかし、これの後で xrange や
 yrange を変更しても (例えば拡大するために)、それは rrange を変更しない
 ので、データ点は rrange に関してクリッピングされたままとなります。他の
 軸とは違い、r 軸の自動縮尺では常に rmin = 0 となります。`reverse` では
 自動縮尺フラグは無視されます。
 注意: rmin を負の値を設定すると、予期せぬ結果を生む可能性があります。
?commands set rtics
?commands show rtics
?set rtics
?show rtics
?rtics
 コマンド `set rtics` は、動径軸に沿って目盛りを配置します。目盛りとそ
 の見出しは原点の右側に描かれます。キーワード `mirror` は、それらを原点
 の左側にも描きます。その他のキーワードに関する話については以下参照:
 `polar`, `set xtics`, `set mxtics`。
?commands set samples
?commands show samples
?set samples
?show samples
?samples
 関数、またはデータの補間に関するデフォルトのサンプリング数は、コマンド
 `set samples` で変更できます。個々のグラフの描画範囲 (sampling range)
 の変更は、以下参照: `plot sampling`。

 書式:
       set samples <samples_1> {,<samples_2>}
       show samples

 デフォルトではサンプル数は 100 点と設定されています。この値を増やすと
 より正確な描画が出来ますが遅くなります。このパラメータはデータファイル
 の描画には何の影響も与えませんが、補間/近似のオプションが使われている
 場合はその限りではありません。2 次元描画については `plot smooth` を、
 3 次元描画に関しては、以下参照: `set dgrid3d`。

 2 次元のグラフ描画が行なわれるときは <samples_1> の値のみが関係します。

 隠線処理なしで曲面描画が行なわれるときは、samples の値は孤立線毎に評価
 されるサンプル数の指定になります。各 v-孤立線は <samples_1> 個のサンプ
 ル点を持ち、u-孤立線は <samples_2> 個のサンプル数を持ちます。<samples_1>
 のみ指定すると、<samples_2> の値は <samples_1> と同じ値に設定されます。
 以下も参照: `set isosamples`。
?commands set size
?commands show size
?set size
?show size
?size
?aspect ratio
?set size square
?set size ratio
?ratio
?square
 書式:
       set size {{no}square | ratio <r> | noratio} {<xscale>,<yscale>}
       show size

 <xscale> と <yscale> は描画全体の拡大の倍率で、描画全体とはグラフとラ
 ベルと余白の部分を含みます。

 重要な注意:
       gnuplot の以前の版では、`set size` の値を、出力する描画領域
       (キャンバス) のサイズを制御するのにも使っていた出力形式もありま
       したが、すべての出力形式がそうだったわけではありませんでした。
       現在は、ほとんどの出力形式が以下のルールに従います:

 `set term <terminal_type> size <XX>, <YY>` は、出力ファイルのサイズ、
 または "キャンバス" のサイズを制御します。サイズパラメータの有効な値に
 ついては、個々の出力形式のヘルプを参照してください。デフォルトでは、グ
 ラフはそのキャンバス全体に描画されます。

 `set size <XX>, <YY>` は、描画自体をキャンバスのサイズに対して相対的に
 伸縮させます。1 より小さい伸縮値を指定すると、グラフはキャンバス全体を
 埋めず、1 より大きい伸縮値を指定すると、グラフの一部分のみがキャンバス
 全体に合うように描画されます。1 より大きい伸縮値を指定すると、ある出力
 形式では問題が起こるかもしれないことに注意してください。

 `ratio` は、指定した <xscale>, <yscale> の描画範囲内で、グラフのアスペ
 クト比 (縦横比) を <r> にします (<r> は x 方向の長さに対する y 方向の
 長さの比)。

 <r> の値を負にするとその意味は違って来ます。<r>=-1 のとき、x 軸、y 軸
 の双方の単位 (つまり 1) の目盛りの長さが同一になるよう設定されます。こ
 れは、3 次元用のコマンド `set view equal xy` の 2 次元での同等物です。
 <r>=-2 のとき、y 軸の単位目盛りの長さは x 軸の単位目盛りの長さの 2 倍
 に設定されます。<r> が負の値に関して以下同様です。

 `gnuplot` が指定されたアスペクト比のグラフをちゃんと書けるかは選択され
 る出力形式に依存します。グラフの領域は出力の指定された部分にちゃんと収
 まり、アスペクト比が <r> であるような最大の長方形となります (もちろん
 適当な余白も残しますが)。

 `set size square` は `set size ratio 1` と同じ意味です。

 `noratio` と `nosquare` はいずれもグラフをその出力形式 (terminal) での
 デフォルトのアスペクト比に戻しますが、<xscale> と <yscale> はそのデフ
 ォルトの値 (1.0) には戻しません。

 `ratio` と `square` は 3 次元描画では意味を持ちませんが、`set view map`
 を使用した 3 次元描画の 2 次元射影には影響を与えます。 以下も参照:
 `set view equal`。これは、3 次元の x 軸と y 軸を強制的に同じスケールに
 します。

 例:

 グラフが現在のキャンバスを埋めるような大きさに設定します:
       set size 1,1

 グラフを通常の半分の大きさで正方形にします:
       set size square 0.5,0.5

 グラフの高さを横幅の 2 倍にします:
       set size ratio 2

?set style
?show style
?unset style
 デフォルトの描画スタイルは、`set style data` と `set style function`
 で設定できます。関数やデータのデフォルトの描画スタイルを個々に変更す
 る方法については、以下参照: `plot with`。スタイルの一覧全体は、以下参
 照: `plotting styles`, `plot with`。

 書式:
       set style function <style>
       set style data <style>
       show style function
       show style data

 指定できる描画要素のデフォルトスタイルも設定できます。

 書式:
       set style arrow <n> <arrowstyle>
       set style boxplot <boxplot style options>
       set style circle radius <size> {clip|noclip}
       set style ellipse size <size> units {xy|xx|yy} {clip|noclip}
       set style fill <fillstyle>
       set style histogram <histogram style options>
       set style line <n> <linestyle>
       set style rectangle <object options> <linestyle> <fillstyle>
       set style textbox {opaque|transparent} {{no}border} {fillcolor}

?commands set style arrow
?commands unset style arrow
?commands show style arrow
?set style arrow
?unset style arrow
?show style arrow
?arrowstyle
 各出力形式は矢や点の形のデフォルトの集合を持っていて、それはコマンド
 `test` で参照できます。`set style arrow` は矢の形、幅、点の形、サイズ
 を定義し、それらを後で使うときにいちいち同じ情報を繰り返して指定しなく
 てもインデックスで参照できるようにします。

 書式:
       set style arrow <index> default
       set style arrow <index> {nohead | head | backhead | heads}
                               {size <length>,<angle>{,<backangle>} {fixed}}
                               {filled | empty | nofilled | noborder}
                               {front | back}
                               { {linestyle | ls <line_style>}
                                 | {linetype | lt <line_type>}
                                   {linewidth | lw <line_width}
                                   {linecolor | lc <colorspec>}
                                   {dashtype | dt <dashtype>} }
       unset style arrow
       show style arrow

 <index> は整数で、それで矢のスタイル (arrowstyle) を特定します。

 `default` を指定すると、全ての arrow スタイルパラメータはそのデフォル
 トの値になります。

 <index> の arrowstyle が既に存在する場合、他の全ては保存されたまま、与
 えられたパラメータのみが変更されます。<index> が存在しなければ、指定さ
 れなかった値はデフォルトの値になります。

 `nohead` を指定することで、矢先のない矢、すなわち線分を書くこともでき
 ます。これは描画の上に線分を描く別な方法を与えます。デフォルトでは 1
 つの矢先がついています。`heads` の指定で線分の両端に矢先が描かれます。

 矢先の大きさは `size <length>,<angle>` または
 `size <length>,<angle>,<backangle>` で制御できます。`<length>` は矢先
 の各枝の長さで、`<angle>` は矢先の枝と矢軸がなす角度 (単位は度) です。
 `<length>` の単位は x 軸と同じですが、それは `<length>` の前に `first`,
 `second`, `graph`, `screen`, `character` をつけることで変更できます。
 詳細は、以下参照: `coordinates`。

 デフォルトでは、とても短い矢の矢先は小さくしますが、これは、`size` コ
 マンドの後ろに `fixed` を使うことで無効にできます。

 `<backangle>` は、矢先の後ろの部分の矢軸との切り角 (`<angle>` と同じ方
 向、単位は度) になりますが、スタイルが `nofilled` の場合はこれを無視し
 ます。

 `filled` を指定すると、矢先の回りの線 (境界線) を描き、矢先を塗りつぶ
 します。`noborder` を指定すると、矢先は塗りつぶしますが、境界線は描き
 ません。この場合、矢先の先端がベクトルの終点ピッタリの場所に置かれ、そ
 の矢先は全体として少し小さくなります。点線で矢を描く場合は、点線の境界
 線は汚いので、常に `noborder` を使うべきです。矢先の塗りつぶしは、すべ
 ての出力形式がサポートしているとは限りません。

 線種はユーザの定義したラインスタイルのリストから選ぶこともできますし
 (以下参照: `set style line`)、用意されている `<line_type>` の値 (デフ
 ォルトのラインスタイルのリストの番号) そして `<linewidth>` (デフォルト
 の幅の倍数) を使ってここで定義することもできます。

 しかし、ユーザー定義済のラインスタイルが選択された場合、その属性 (線種、
 幅) は、単に他の `set style arrow` コマンドで適当な番号や `lt`, `lw`
 などを指定しても、変更はできないことに注意して下さい。

 `front` を指定すると、矢はグラフのデータの上に描かれます。`back` が指
 定された場合 (デフォルト) は矢はグラフのデータの下に描かれます。`front`
 を使えば、密集したデータで矢が見えなくなることを防ぐことができます。

 例:

 矢先がなく、倍の幅が矢を描くには:
       set style arrow 1 nohead lw 2
       set arrow arrowstyle 1

 その他の例については、以下参照: `set arrow`。

?commands set style boxplot
?commands unset style boxplot
?commands show style boxplot
?set style boxplot
?unset style boxplot
?show style boxplot
 コマンド `set style boxplot` により、描画スタイル `boxplot` で生成する
 描画のレイアウトを変更できます。

 書式:
       set style boxplot {range <r> | fraction <f>}
                         {{no}outliers} {pointtype <p>}
                         {candlesticks | financebars}
                         {medianlinewidth <width>}
                         {separation <x>}
                         {labels off | auto | x | x2}
                         {sorted | unsorted}

 boxplot の箱は、常にデータ点の第一四分位から第三四分位の値の範囲にかか
 っています。箱から延長される箱ひげの限界は、2 つの異なる方法で制御でき
 ます。デフォルトでは、箱ひげは、その箱のそれぞれの端から、四分位範囲の
 1.5 倍 (すなわち、その箱の厳密な垂直方向の高さ) に等しい範囲にまで延長
 されます。箱ひげそれぞれは、データ集合のある点に属する y の値で終了す
 るように、メジアンに向かって切り捨てられます。四分位範囲の丁度 1.5 倍
 の値の点がない場合もありますから、箱ひげはその名目上の範囲よりも短くな
 る場合もあります。このデフォルトは以下に対応します。
       set style boxplot range 1.5

 もう一つの方法として、箱ひげがかかる点の総数の割合 (fraction) を指定す
 ることができます。この場合、その範囲はメジアン値から、データ集合の指定
 した分を囲い込むまで、対称に延長されます。このときも、個々の箱ひげはデ
 ータ集合内の点の端までに制限されます。データ集合の 95% の点をはるには
 以下のようにします。
       set style boxplot fraction 0.95

 箱ひげの範囲の外にある任意の点は、outliers と見なされます。デフォルト
 ではそれらはひとつひとつ円 (pointtype 7) で描かれますが、オプション
 `nooutliers` はこれを無効にします。

 デフォルトでは boxplot は candlesticks と似たスタイルで描画しますが、
 financebars と似たスタイルで描画するためのオプションもあります。

 箱の境界と同じ線種を使って、メジアンを示す横断線を描きますが、そのメジ
 アン線をより太くしたければ、以下のようにできます。
       set style boxplot medianlinewidth 2.0
 メジアン線が必要なければ、それを 0 にセットしてください。

 boxplot の using 指定が 4 列目を持つ場合、その列の値はある因子変数の離
 散的なレベル値であると見なします。この場合、その因子変数のレベルの数と
 同じだけの複数の boxplot が描かれます。それらの boxplot の隣り合うもの
 同士の距離はデフォルトでは 1.0 (x 軸の単位で) ですが、この間隔はオプシ
 ョン `separation` で変更できます。

 オプション `labels` は、これらの boxplot (それぞれデータ集合のある部分
 に対応する) のどこに、どのようにラベルをつけるかを決定します。デフォル
 トでは因子の値を水平軸 (x か x2 のいずれか plot で使われている方) の目
 盛ラベルに出力します。これはオプションの `labels auto` に対応します。
 オプション `labels x`, `labels x2` によって、強制的に x 軸、x2 軸にそ
 れぞれ出力させることもできますし、`labels off` でオフにすることもでき
 ます。

 デフォルトでは、因子変数の異なるレベルに対応する boxplot は整列化はせ
 ず、データファイルにそのレベルが現れる順番に描画します。この挙動はオプ
 ションの `unsorted` に対応しますが、オプション `sorted` を使用すると、
 まずレベルを辞書順にソートし、その順に boxplot を描画します。

 オプション `separation`, `labels`, `sorted`, `unsorted` は、plot に 4
 列目の指定を与えた場合のみ効力を持ちます。

 以下参照: `boxplot`, `candlesticks`, `financebars`。

?commands set style data
?commands show style data
?set style data
?show style data
?data style
 コマンド `set style data` はデータ描画に対するデフォルトの描画スタイル
 を変更します。

 書式:
       set style data <plotting-style>
       show style data

 選択項目については、以下参照: `plotting styles`。`show style data` は
 現在のデフォルトのデータ描画スタイルを表示します。
?commands set style fill
?commands show style fill
?set style fill
?show style fill
?fillstyle
 コマンド `set style fill` は、boxes, histograms, candlesticks,
 filledcurves での描画における描画要素のデフォルトのスタイルの設定に使
 われます。このデフォルトは、個々の描画に塗り潰しスタイル (fillstyle)
 を指定することで上書きできます。以下参照: `set style rectangle`。

 書式:
       set style fill {empty
                       | {transparent} solid {<density>}
                       | {transparent} pattern {<n>}}
                      {border {lt} {lc <colorspec>} | noborder}

 デフォルトの塗りつぶしスタイル (fillstyle) は `empty` です。

 オプション `solid` は、出力形式がサポートしている場合、その色でのベタ
 塗りを行います。パラメータ <density> は塗りつぶし色の強さを表していて
 <density> が 0.0 なら箱は空、<density> が 1.0 なら箱はその内部は現在の
 線種と完全に同じ色で塗られます。出力形式によっては、この強さを連続的に
 変化させられるものもありますが、その他のものは、部分的な塗りつぶしの幾
 つかのレベルを実装しているに過ぎません。パラメータ <density> が与えら
 れなかった場合はデフォルトの 1 になります。

 オプション `pattern` は、出力ドライバによって与えられるパターンでの塗
 りつぶしを行います。利用できる塗りつぶしパターンの種類と数は出力ドライ
 バに依存します。塗りつぶしの boxes スタイルで複数のデータ集合を描画す
 る場合そのパターンは、複数の曲線の描画における線種の周期と同様、有効な
 パターンを、パターン <n> から始めて周期的に利用します。

 オプション `empty` は、箱を塗りつぶしませんが、これがデフォルトです。

?fillcolor
?fc
 塗り潰し色 (`fillcolor <colorspec>`) は、塗り潰しスタイル (fill style)
 から分離されています。すなわち、fillstyle は描画要素やオブジェクトで別
 々の色を持ったまま共有することができます。fillstyle を受けつける大抵の
 場所で fillcolor を指定できます。fillcolor は `fc` の省略形も使えます。
 指定しない場合は、塗り潰し色は現在の線種 (linetype) から取ります。
 例:

       plot FOO with boxes fillstyle solid 1.0 fillcolor "cyan"

?commands set style fill border
?set style fill border
?fillstyle border
 キーワード `border` は、塗り潰しオブジェクトを現在の線種と色の実線で囲
 むようにします。その線の色は、linetype や linecolor を追加指定すれば変
 更できます。`noborder` は、境界の線を描かないようにします。
 例:
      # 塗り潰しは強度半分、境界は同じ色で全強度
      set style fill solid 0.5 border
      # 塗り潰しは半分透過、境界は実線の黒 (線種 -1)
      set style fill transparent solid 0.5 border -1
      # 現在の色でのパターン塗り潰し、境界は線種 5 の色で
      plot ... with boxes fillstyle pattern 2 border lt 5
      # 水色 (cyan) での領域の塗り潰し、境界は青
      plot ... with boxes fillcolor "cyan" fs solid border linecolor "blue"

 注意: fill スタイルの border (境界) 属性は、デフォルトモードの closed
 (閉曲線) の `with filledcurves` のグラフにしか影響を与えません。
?commands set style fill transparent
?set style fill transparent
?fillstyle transparent
?transparent
 いくつかの出力形式は、塗りつぶし領域の `transparent` (透明化) 属性をサ
 ポートしています。transparent solid の領域塗りつぶしでは、`density`
 (密度) パラメータはアルファ値として使用されます。つまり、密度 0 は完全
 な透明を、密度 1 は完全な不透明を意味します。transparent pattern の塗
 りつぶしでは、パターンの背景が完全な透明か完全な不透明のいずれかです。

 透明な塗りつぶし領域を含むグラフを見たり作ったりするのには、別な制限が
 ありうることに注意してください。例えば、png 出力形式では、"truecolor"
 オプションが指定されている場合にのみ透明化の塗り潰しが利用できます。
 PDF ファイルには透明化領域が正しく記述されていても、PDF の表示ソフトに
 よってはそれを正しく表示できないこともありえます。実際に PostScript プ
 リンタでは問題はないのに、Ghostscript/gv ではパターン塗りつぶし領域を
 正しく表示できません。
?commands set style function
?commands show style function
?set style function
?show style function
 コマンド `set style function` は関数描画に対するデフォルトの描画スタイ
 ル (lines, points, filledcurves など) を変更します。以下参照:
 `plotting styles`。

 書式:
       set style function <plotting-style>
       show style function
?commands set style increment
?commands show style increment
?set style increment
?show style increment
 `注意`: このコマンドは非推奨です。代わりに新しいコマンド `set linetype`
 を使用してください。これは、代用のための一時的な適当な線種を検索するの
 ではなく、線種自体を再定義します。以下参照: `set linetype`。

 書式:
       set style increment {default|userstyles}
       show style increment

 デフォルトでは、同じグラフ上の次の描画は、現在の出力形式でデフォルトで
 定義されている線種の次のもので行われます。
 しかし、`set style increment user` を選択すると、デフォルトの線種では
 なく、ユーザ定義ラインスタイル番号のものを使用させることができます。

 例:

       set style line 1 lw 2 lc rgb "gold"
       set style line 2 lw 2 lc rgb "purple"
       set style line 4 lw 1 lc rgb "sea-green"
       set style increment user

       plot f1(x), f2(x), f3(x), f4(x)

 これは、関数 f1, f2, f4 は新たにユーザ定義されたラインスタイルで描画さ
 れます。ユーザ定義ラインスタイルが見つからない場合は、代わりにそれに対
 応するデフォルトの線種が利用されます。例えば、上の例では、f3(x) はデフ
 ォルトの線種 3 で描画されます。

?commands set style line
?commands unset style line
?commands show style line
?set style line
?unset style line
?show style line
?linestyle
?linewidth
 出力装置にはおのおのデフォルトの線種と点種の集合があり、それらはコマン
 ド `test` で見ることができます。`set style line` は線種と線幅、点種と
 点の大きさを、個々の呼び出しで、それらの情報を全部指定する代わりに、単
 なる番号で参照できるようにあらかじめ定義するものです。

 書式:
       set style line <index> default
       set style line <index> {{linetype  | lt} <line_type> | <colorspec>}
                              {{linecolor | lc} <colorspec>}
                              {{linewidth | lw} <line_width>}
                              {{pointtype | pt} <point_type>}
                              {{pointsize | ps} <point_size>}
                              {{pointinterval | pi} <interval>}
                              {{pointnumber | pn} <max_symbols>}
                              {{dashtype | dt} <dashtype>}
                              {palette}
       unset style line
       show style line

 `default` は、全てのラインスタイルパラメータをそれと同じ index を持つ
 線種 (linetype) に設定します。

 <index> の linestyle が既に存在する場合、他の全ては保存されたまま、与
 えられたパラメータのみが変更されます。<index> が存在しなければ、指定さ
 れなかった値はデフォルトの値になります。

 このようにつくられるラインスタイルは、デフォルトの型 (線種, 点種) を
 別なものに置き換えることはしないので、ラインスタイル、デフォルトの型、
 どちらも使えます。ラインスタイルは一時的なもので、コマンド `reset` を
 実行すればいつでもそれらは消え去ります。線種自体を再定義したい場合は、
 以下参照: `set linetype`。

 線種と点種は、その index 値をデフォルトとします。その index 値に対する
 実際の記号の形は、出力形式によって異なり得ます。

 線幅と点の大きさは、現在の出力形式のデフォルトの幅、大きさに対する乗数
 です (しかし、ここでの <point_size> は、コマンド `set pointsize` で与
 えられる乗数には影響を受けないことに注意してください)。

 `pointinterval` は、スタイル `linespoints` でグラフ中に描かれる点の間
 隔を制御します。デフォルトは 0 です (すべての点が描画される)。例えば、
 `set style line N pi 3` は、点種が N、点の大きさと線幅は現在の出力形式
 のデフォルトで、`with linespoints` での描画では点は 3 番目毎に描画され
 るようなラインスタイルを定義します。その間隔を負の値にすると、それは間
 隔は正の値の場合と同じですが、点の記号の下になる線を書かないようにしま
 す (出力形式によっては)。

 `pointnumber` 属性は、`pointinterval` と似ていますが、N 個おきに描くよ
 うにする代わりに、全体の点の個数を N 個に限定するところが違います。

 全ての出力装置が `linewidth` や `pointsize` をサポートしているわけでは
 ありません。もしサポートされていない場合はそれらのオプションは無視され
 ます。

 出力形式に依存しない色を `linecolor <colorspec>` か `linetype <colorspec>`
 (省略形は `lc`, `lt`) のいずれかを使って割り当てることができます。この
 場合、色は RGB の 3 つ組で与えるか、gnuplot の持つパレットの色名、現在
 のパレットに対する小数指定、または cbrange への現在のパレットの対応に
 対する定数値、のいずれかで与えます。以下参照: `colors`, `colorspec`,
 `set palette`, `colornames`, `cbrange`。

 `set style line <n> linetype <lt>` は、出力形式に依存した点線/破線のパ
 ターンと色の両方をセットします。`set style line <n> linecolor <colorspec>`
 や `set style line <n> linetype <colorspec>` は、現在の点線/破線のパタ
 ーンを変更せずに新しい線色を設定します。

 3 次元モード(`splot` コマンド) では、"linetype palette z" の省略形とし
 て特別にキーワード `palette` を使うことも許されています。その色の値は、
 splot の z 座標 (高さ) に対応し、曲線、あるいは曲面に沿って滑らかに変
 化します。

 例:
 以下では、番号 1, 2, 3 に対するデフォルトの線種をそれぞれ赤、緑、青とし、
 デフォルトの点の形をそれぞれ正方形、十字、三角形であるとします。このとき
 以下のコマンド

       set style line 1 lt 2 lw 2 pt 3 ps 0.5

 は、新しいラインスタイルとして、緑でデフォルトの 2 倍の幅の線、および
 三角形で半分の幅の点を定義します。また、以下のコマンド

       set style function lines
       plot f(x) lt 3, g(x) ls 1

 は、f(x) はデフォルトの青線で、g(x) はユーザの定義した緑の線で描画しま
 す。同様に、コマンド

       set style function linespoints
       plot p(x) lt 1 pt 3, q(x) ls 1

 は、p(x) を赤い線で結ばれたデフォルトの三角形で、q(x) は緑の線で結ばれ
 た小さい三角形で描画します。

       splot sin(sqrt(x*x+y*y))/sqrt(x*x+y*y) w l pal

 は、`palette` に従って滑らかな色を使って曲面を描画します。これはそれを
 サポートした出力形式でしかちゃんとは動作しないことに注意してください。
 以下も参照: `set palette`, `set pm3d`。

       set style line 10 linetype 1 linecolor rgb "cyan"

 は、RGB カラーをサポートするすべての出力形式で、ラインスタイル 10 に実
 線の水色を割り当てます。

?commands set style circle
?commands unset style circle
?commands show style circle
?set style circle
?unset style circle
?show style circle

 書式:
       set style circle {radius {graph|screen} <R>}
                        {{no}wedge}
                        {clip|noclip}

 このコマンドは、描画スタイル "with circles" で使われるデフォルトの半径
 を設定します。これは、データ描画で 2 列のデータ (x,y) しか与えなかった
 場合、あるいは関数描画のときに適用されます。デフォルトは、以下のように
 なっています: "set style circle radius graph 0.02"。`nowedge` は、扇形
 の円弧部分から中心に向かう 2 本の半径を描かないようにしますが、デフォ
 ルトは `wedge` です。このパラメータは完全な円に対しては何もしません。
 `clip` は円を描画境界でクリッピングしますが、`noclip` はこれを無効にし
 ます。デフォルトは `clip` です。

?commands set style rectangle
?commands unset style rectangle
?commands show style rectangle
?set style rectangle
?unset style rectangle
?show style rectangle

 コマンド `set object` で定義された長方形には別々のスタイルを設定できま
 す。しかし、個別のスタイル指定をしなければ、そのオブジェクトはコマンド
 `set style rectangle` によるデフォルトを受け継ぎます。

 書式:
     set style rectangle {front|back} {lw|linewidth <lw>}
                         {fillcolor <colorspec>} {fs <fillstyle>}

 以下参照: `colorspec`, `fillstyle`。`fillcolor` は `fc` と省略できます。

 例:
     set style rectangle back fc rgb "white" fs solid 1.0 border lt -1
     set style rectangle fc linsestyle 3 fs pattern 2 noborder

 デフォルトの設定は、背景色での塗り潰しで、境界は黒になっています。

?commands set style ellipse
?commands show style ellipse
?set style ellipse
?unset style ellipse
?show style ellipse

 書式:
       set style ellipse {units xx|xy|yy}
                         {size {graph|screen} <a>, {{graph|screen} <b>}}
                         {angle <angle>}
                         {clip|noclip}

 このコマンドは、楕円の直径を同じ単位で計算するかどうかを制御します。
 デフォルトは `xy` で、これは楕円の主軸 (第 1 軸) の直径は x (または x2)
 軸と同じ単位で計算し、副軸 (第 2 軸) の直径は y (または y2) 軸の単位で
 計算します。このモードでは、楕円の両軸の比は、描画軸のアスペクト比に依
 存します。`xx` か `yy` に設定すれば、すべての楕円の両軸は同じ単位で計
 算されます。これは、描画される楕円の両軸の比は、回転しても正しいままで
 すが、水平方向か垂直方向の一方の縮尺の変更により正しくなくなることを意
 味します。

 これは、object として定義された楕円、コマンド `plot` によって描画され
 る楕円の両方に影響を与える全体的な設定ですが、`units` の値は、描画毎、
 オブジェクト毎に設定を再定義できます。

 楕円のデフォルトのサイズも、キーワード `size` で設定できます。デフォル
 トのサイズは、2 列のみのデータ、または関数の plot 命令で適用されます。
 2 つの値は、楕円の (2 つの主軸、2 つの副軸に向かい合う) 主軸直径と副軸
 直径として使用されます。

 デフォルトは、"set style ellipse size graph 0.05,0.03" です。

 最後になりますが、デフォルトの向きをキーワード `angle` で設定もできま
 す。向きは、楕円の主軸とグラフの x 軸の方向となす角で、単位は度で与え
 る必要があります。

 `clip` は楕円を描画境界でクリッピングしますが、`noclip` はこれを無効に
 します。デフォルトは `clip` です。

 楕円の object の定義に関しては以下も参照: `set object ellipse`。2 次元
 の描画スタイルに関しては以下参照: `ellipses`。
?commands set style textbox
?commands show style textbox
?set style textbox
?unset style textbox
?show style textbox
?textbox
?boxed

 書式: set style textbox {opaque|transparent}
                         {{no}border {<bordercolor>}}{linewidth <lw>}
                         {fillcolor <color>}
                         {margins <xmargin>,<ymargin>}

 このコマンドは、属性 `boxed` による label の表示を制御します。箱付き文
 字列をサポートしない出力形式はこのスタイルを無視します。
 注意: 現在の実装は試験的で、仕様は変更されるかもしれません。
 いくつかの出力形式 (svg, latex) での実装は不完全です。
 また、ほとんどの出力形式は、回転した文字列の箱付けが正しくできません。
?commands set surface
?commands unset surface
?commands show surface
?set surface
?unset surface
?show surface
?surface
?nosurface
 コマンド `set surface` は 3 次元描画 (`splot`) にのみ関係します。

 書式:
       set surface {implicit|explicit}
       unset surface
       show surface

 `unset surface` により `splot` は、関数やデータファイルの点に対するど
 んな点や線も描かなくなります。これは主に、等高線を作る曲面を描く代わり
 に等高線のみを描く場合に有用です。その場合でも `set contour` の設定に
 よりますが、曲面上に等高線が描かれます。他のものは通常のままで、ある一
 つの関数やデータファイルの曲面のみをオフにするには、`splot` コマンド上
 でキーワード `nosurface` を指定してください。等高線を格子の土台に表示
 したい場合は `unset surface; set contour base` という組が便利でしょう。
 以下も参照: `set contour`。

 3 次元データの組が網目 (格子線) と認識されると、gnuplot はデフォルトで
 は格子曲面を要求しているものとして、暗黙に `with lines` の描画スタイル
 を用います。以下参照: `grid_data`。コマンド `set surface explicit` は
 この機能を抑制し、入力ファイルのデータの分離されたブロックで記述される
 孤立線のみを描画します。この場合でも、splot で明示的に `with surface`
 とすれば格子曲面が描画されます。
?commands set table
?set table
?table
 `table` モードが有効な場合、`plot` と `splot` コマンドは、現在の出力形
 式に対する実際の描画を生成する代わりに
      X Y {Z} <flag>
 の値の複数列からなる表形式のテキスト出力を行ないます。フラグ文字 <frag>
 は、その点が有効な範囲内にある場合は "i"、範囲外の場合は "o"、未定義値
 (undefined) の場合は "u" です。データの書式は、軸の刻みの書式 (以下参
 照: `set format`) によって決まります。列は、デフォルトでは空白区切りで
 す。表データを CSV 形式で書き出す方法の詳細は、以下参照: `with table`。
 これは、等高線を生成し、それを再利用のために保存したいときに便利です。
 この方法は、補間されたデータを保存するのにも使うことができます (以下参
 照: `set samples`, `set dgrid3d`)。

 書式:
       set table {"outfile" | $datablock} {append}
                 {separator {whitespace|tab|comma|"<char>"}
       plot <whatever>
       unset table

 この後の表形式の出力は、ファイル "outfile" を指定していればそれに書き
 出しますが、そうでなければ標準出力か、現在の `set output` が指定するも
 のに出力します。`outfile` が既に存在する場合は、`append` キーワードを
 指定すれば追加出力、指定しなければこの出力が上書きします。他に、表形式
 出力を名前付きデータブロックにリダイレクトすることもできます。データブ
 ロック名は '$' で始まります。以下も参照: `inline data`。現在の出力形式
 の標準的な描画に戻すには、`unset table` を明示的に行なう必要があります。

 `separator` 文字は、CSV ファイル (コンマ区切り) の出力に使えます。その
 モードは、描画スタイル `with table` にのみ影響を与えます。以下参照:
 `plot with table`。

?plot with table
?with table
?csv
 以下の説明は、特別な描画スタイル `with table` にのみ適用されます。

 表データに変換される入力データに対する描画スタイルに依存する処理 (平滑
 化、誤差線の延長、2 軸範囲のチェック等) を避けるため、あるいは表データ
 に変換できる列の数を増やすには、通常の描画スタイルの代わりに "table"
 キーワードを使ってください。この場合、範囲内/範囲外/未定義を意味する
 `i`, `o`, `u` が置かれる最後の追加列は、出力にはつきません。その出力先
 は、最初に `set table <where>` で指定する必要があります。
 例:

      set table $DATABLOCK1
      plot <file> using 1:2:3:4:($5+$6):(func($7)):8:9:10 with table

 この場合、実際の描画スタイルがない状態なので、各列には特定の軸は対応し
 ないことになり、よって xrange, yrange 等の設定は無視されます。

 文字列に対して `using` で評価した場合は、文字列も表データ化されます。
 数値データは常に %g の書式で書き出されますが、他の書式を使いたい場合は、
 そのように書式化された文字列を生成するように sprintf か gprintf を使用
 してください。

      plot <file> using ("File 1"):1:2:3 with table
      plot <file> using (sprintf("%4.2f",$1)) : (sprintf("%4.2f",$3)) with table

 CSV ファイルを生成するには、以下のようにします。
      set table "tab.csv" separator comma
      plot <foo> using 1:2:3:4 with table

?commands set terminal
?commands show terminal
?set terminal
?set term
?show terminal
?show term
?set terminal push
?set term push
?terminal push
?term push
?push
?set terminal pop
?set term pop
?terminal pop
?term pop
?pop
 `gnuplot` は数多くのグラフィック形式をサポートしています。コマンド
 `set terminal` を使って `gnuplot` の出力の対象となる形式の種類を選んで
 ください。出力先をファイル、または出力装置にリダイレクトするには
 `set output` を使ってください。

 書式:
       set terminal {<terminal-type> | push | pop}
       show terminal

 <terminal-type> が省略されると `gnuplot` は利用可能な出力形式の一覧を
 表示します。<terminal-type> の指定には短縮形が使えます。

 `set terminal` と `set output` の両方を使う場合、`set terminal` を最初
 にする方が安全です。それは、OS によっては、それが必要とするフラグをセ
 ットする出力形式があるからです。

 いくつかの出力形式はたくさんの追加オプションを持ちます。
 各 `<term>` に対し、直前の `set term <term> <options>` で使用されたオ
 プションは記憶され、その後の `set term <term>` がそれをリセットするこ
 とはありません。これは例えば印刷時に有用です。幾つかの異なる出力形式を
 切替える場合、前のオプションを繰り返し唱える必要はありません。

 コマンド `set term push` は、現在の出力形式とその設定を `set term pop`
 によって復帰するまで記憶しています。これは `save term`, `load term` と
 ほぼ同等ですが、ファイルシステムへのアクセスは行わず、よって例えばこれ
 は、印刷後にプラットホームに依存しない形で出力形式を復帰する目的に使え
 ます。gnuplot の起動後、デフォルト、または `startup` ファイルに書かれ
 た出力形式が自動的に記憶 (push) されます。よって、明示的に出力形式を記
 憶させることなく、任意のプラットホーム上でデフォルトの出力形式を
 `set term pop` によって復帰させる、という動作を期待したスクリプトを可
 搬性を失わずに書くことが出来ます。

 詳細は、以下参照: `complete list of terminals`。

?commands set termoption
?set termoption
?termoption
 コマンド `set termoption` は、現在使用している出力形式の振舞いを、新た
 な `set terminal` コマンドの発行なしに変更することを可能にします。この
 コマンド一つに対して一つのオプションのみが変更できます。そしてこの方法
 で変更できるオプションはそう多くはありません。現在使用可能なオプション
 は以下のもののみです。

      set termoption {no}enhanced
      set termoption font "<fontname>{,<fontsize>}"
      set termoption fontscale <scale>
      set termoption {linewidth <lw>}{lw <lw>}

?commands set theta
?set theta
?unset theta
?theta
 極座標グラフは、デフォルトでは角の 0 の方向 (θ = 0) がグラフの右側を
 指すよう向きづけられ、角の増加は反時計回りに行われ、θ = 90 が真上を向
 くようになっています。`set theta` により、極座標の角の座標に関する 0
 の向きと増加方向を変更できます。
      set theta {right|top|left|bottom}
      set theta {clockwise|cw|counterclockwise|ccw}
 `unset theta` は、デフォルトの状態 "set theta right ccw" に復帰します。
?commands set tics
?commands unset tics
?commands show tics
?set tics
?unset tics
?show tics
?tics
 コマンド `set tics` は、全ての軸の目盛りの刻みとラベルを一度に制御しま
 す。

 目盛りは `unset tics` で消え、`set tics` で目盛りがつきます (デフォル
 ト)。個々の軸の目盛りは、これとは別のコマンド `set xtics`, `set ztics`
 などを使って制御できます。

 書式:
       set tics {axis | border} {{no}mirror}
                {in | out} {front | back}
                {{no}rotate {by <ang>}} {offset <offset> | nooffset}
                {left | right | center | autojustify}
                {format "formatstring"} {font "name{,<size>}"} {{no}enhanced}
                { textcolor <colorspec> }
       set tics scale {default | <major> {,<minor>}}
       unset tics
       show tics

 オプションは、個々の軸 (x, y, z, x2, y2, cb) にも適用できます。例:
       set xtics rotate by -90
       unset cbtics

 軸の刻みの線属性は、すべてグラフの境界 (以下参照: `set border`) と同じ
 ものを使って描かれます。

 tics の `back` または `front` の設定は、2D 描画 (splot は不可) にのみ
 すべての軸に 1 度適用されます。これは、目盛りと描画要素が重なった場合
 に目盛りを描画要素の前面に出すか、奥に置くかを制御します。

 `axis` と `border` は `gnuplot` に目盛り (目盛りの刻み自身とその見出し)
 を、それぞれ軸につけるのか、境界につけるのかを指示します。軸が境界にと
 ても近い場合、`axis` を使用すると境界が表示されていれば (以下参照:
 `set border`) 目盛りの見出し文字を境界の外に出してしまうでしょう。この
 場合自動的なレイアウトアルゴリズムによる余白設定は大抵よくないものとな
 ってしまいます。

 `mirror` は `gnuplot` に反対側の境界の同じ位置に、見出しのない目盛りを
 出力するよう指示します。`nomirror` は、あなたが想像している通りのこと
 を行ないます。

 `in` と `out` は目盛りの刻みを内側に描くか外側に描くかを切り変えます。

 `set tics scale` は、目盛りの刻みの大きさを制御します。最初の <major>
 の値には、自動的に生成され、またユーザも指定できる大目盛り (レベル 0)
 を指定し、2 つ目の <minor> の値には、自動的に生成され、またユーザも指
 定できる小目盛り (レベル 1) を指定します。<major> のデフォルトは 1.0
 で、<minor> のデフォルトは <major>/2 です。さらに値を追加すれば、レベ
 ル 2, 3, ... の目盛りの大きさになります。`set tics scale default` でデ
 フォルトの目盛りの大きさに復帰します。

 `rotate` は、文字列を 90 度回転させて出力させようとします。これは、文
 字列の回転をサポートしている出力ドライバ (terminal) では実行されます。
 `norotate` はこれをキャンセルします。`rotate by <ang>` は角度 <ang> の
 回転を行ないますが、これはいくつかの出力形式 (terminal) でサポートされ
 ています。

 x と y 軸の大目盛りのデフォルトは `border mirror norotate` で、x2, y2
 軸は `border nomirror norotate` がデフォルトです。z 軸のデフォルトは
 `nomirror` です。

 <offset> は x,y かまたは x,y,z の形式ですが、それに座標系を選択して、
 その前に `first`, `second`, `graph`, `screen`, `character` のいずれか
 をつけることもできます。<offset> は、目盛りの見出し文字列のデフォルト
 の位置からのずらし位置で、そのデフォルトの単位系は `character` です。
 詳細は、以下参照: `coordinates`。`nooffset` は offset を OFF にします。

 デフォルトでは見出しラベルは、美しい結果を生むように、軸と回転角に依存
 した位置に自動的に揃えられますが、気にいらなければ、明示的に `left`,
 `right`, `center` のキーワードにより位置揃えを変更できます。
 `autojustify` でデフォルトの挙動に復帰します。

 オプションなしの `set tics` は、第 1 軸に対する鏡映 (mirror) と内側向
 き目盛りの刻みをデフォルトの挙動に復帰しますが、その他の全てのオプショ
 ンは、直前の値を保持します。

 大目盛り (ラベルのつく) の他の制御に関しては、以下参照: `set xtics`。
 小目盛りの制御に関しては、以下参照: `set mxtics`。これらのコマンドは、
 各軸の独立な制御を提供します。
?commands set ticslevel
?commands show ticslevel
?set ticslevel
?show ticslevel
?ticslevel
 現在は推奨されていません。以下参照: `set xyplane`。
?commands set ticscale
?commands show ticscale
?set ticscale
?show ticscale
?ticscale
 コマンド `set ticscale` は現在は推奨されていません。代わりに
 `set tics scale` を使ってください。
?commands set timestamp
?commands unset timestamp
?commands show timestamp
?set timestamp
?unset timestamp
?show timestamp
?timestamp
?notimestamp
 コマンド `set timestamp` は現在の時刻と日付をグラフの余白に表示します。

 書式:
       set timestamp {"<format>"} {top|bottom} {{no}rotate}
                     {offset <xoff>{,<yoff>}} {font "<fontspec>"}
                     {textcolor <colorspec>}
       unset timestamp
       show timestamp

 書式文字列 (format) は、書かれる日付と時刻の書式に使用されます。デフォ
 ルトは asctime() が使用する "%a %b %d %H:%M:%S %Y" です (曜日、月名、
 日、時、分、秒、4 桁の西暦)。`top` と `bottom` を使って、日付の配置を
 左上、左下のいずれの余白にするかを選択できます (デフォルトは左下)。
 `rotate` は、日付を垂直方向に書き出します。定数 <xoff>、<yoff> はずれ
 (offset) を意味し、これによってより適切な位置決めが行えます。<font> は
 日付が書かれるフォントを指定します。

 `timestamp` の代わりに省略名 `time` を使っても構いません。

 例:
       set timestamp "%d/%m/%y %H:%M" offset 80,-2 font "Helvetica"

 日付の書式文字列に関する詳しい情報については、以下参照: `set timefmt`。
?commands set timefmt
?commands show timefmt
?set timefmt
?show timefmt
?timefmt
 このコマンドは、データが日時の形式になっている場合に、その時系列データ
 に適用されます。これはコマンド `set *data time` も与えられていないと意
 味がありません。

 書式:
       set timefmt "<format string>"
       show timefmt

 文字列引数 (<format string>) は `gnuplot` に日時データをデータファイル
 からどのように読むかを指示します。有効な書式は以下の通りです:

       書式         説明
       %d           何日, 1--31
       %m           何月, 1--12
       %y           何年, 0--99
       %Y           何年, 4-digit
       %j           1 年の何日目, 1--365
       %H           何時, 0--24
       %M           何分, 0--60
       %s           Unix epoch (1970-01-01, 00:00 UTC) からの秒数
       %S           何秒 (出力では 0--60 の整数、入力では実数)
       %b           月名 (英語) の 3 文字省略形
       %B           月名 (英語)



 任意の文字を文字列中で使用できますが、規則に従っている必要があります。
 \t (タブ) は認識されます。バックスラッシュ + 8 進数列 (\nnn) はそれが
 示す文字に変換されます。日時要素の中に分離文字がない場合、%d, %m, %y,
 %H, %M, %S はそれぞれ 2 桁の数字を読み込みます。%S での読み込みで小数
 点がそのフィールドについている場合は、その小数点つきの数を小数の秒指定
 だと解釈します。%Y は 4 桁、%j は 3 桁の数字を読み込みます。%b は 3 文
 字を、%B は必要な分だけの文字を要求します。

 空白 (スペース) の扱いはやや違います。書式文字列中の 1 つの空白は、フ
 ァイル中の 0 個、あるいは 1 つ以上の空白文字列を表します。すなわち、
 "%H %M" は "1220" や "12     20" を "12 20" と同じように読みます。

 データ中の非空白文字の集まりそれぞれは、`using n:n` 指定の一つ一つの列
 とカウントされます。よって `11:11  25/12/76  21.0` は 3 列のデータと認
 識されます。混乱を避けるために、日時データが含まれる場合 `gnuplot` は、
 あなたの `using` 指定が完璧なものであると仮定します。

 日付データが曜日、月の名前を含んでいる場合、書式文字列でそれを排除しな
 ければいけませんが、"%a", "%A", "%b", "%B" でそれらを表示することはで
 きます。`gnuplot` は数値から月や曜日を正しく求めます。これら、及び日時
 データの出力の他のオプションの詳細に関しては、以下参照: `set format`。

 2 桁の西暦を %y で読む場合、69-99 は 2000 年未満、00-68 は 2000 年以後
 と見なします。注意: これは、UNIX98 の仕様に合わせたものですが、この慣
 例はあちこちで違いがあるので、2 桁の西暦値は本質的にあいまいです。

 他の情報については、以下も参照: `set xdata`, `time/date`。

 例:
       set timefmt "%d/%m/%Y\t%H:%M"
 は、`gnuplot` に日付と時間がタブで分離していることを教えます (ただし、
 あなたのデータをよーく見てください。タブだったものがどこかで複数のスペ
 ースに変換されていませんか ? 書式文字列はファイル中に実際にある物と一
 致していなければなりません)。
 以下も参照
 時系列データ (time data) デモ。
?commands set title
?commands show title
?set title
?show title
?title
 コマンド `set title` は、描画の上の真中に書かれる描画タイトルを生成し
 ます。`set title` は `set label` の特殊なもの、とみなせます。

 書式:
       set title {"<title-text>"} {offset <offset>} {font "<font>{,<size>}"}
                 {{textcolor | tc} {<colorspec> | default}} {{no}enhanced}
       show title

 <offset> を x,y かまたは x,y,z の形式で指定した場合は、タイトルは与え
 られた値だけ移動されます。それに座標系を選択して、その前に `first`,
 `second`, `graph`, `screen`, `character` のいずれかをつけることもでき
 ます。詳細は、以下参照: `coordinates`。デフォルトでは `character` 座標
 系が使われます。例えば、"`set title offset 0,-1`" はタイトルの y 方向
 の位置のみ変更し、大ざっぱに言って 1 文字分の高さだけタイトルを下に下
 げます。1 文字の大きさは、フォントと出力形式の両方に依存します。

 <font> はタイトルが書かれるフォントを指定するのに使われます。<size> の
 単位は、どの出力形式 (terminal) を使っているかによって変わります。

 `textcolor <colorspec>` は、文字の色を変更します。<colorspec> は、線
 種、rgb 色、またはパレットへの割当のいずれかが指定できます。以下参照:
 `colorspec`, `palette`。

 `noenhanced` は、拡張文字列処理 (enhanced text) モードが有効になってい
 る場合でも、タイトルを拡張文字列処理させないようにします。

 `set title` をパラメータなしで使うとタイトルを消去します。

 バックスラッシュ文字列の作用、及び文字列を囲む単一引用符と二重引用符の
 違いについては、以下参照: `syntax`。
?commands set tmargin
?set tmargin
?tmargin
 コマンド `set tmargin` は上の余白のサイズをセットします。詳細は、以下
 参照: `set margin`。
?commands set trange
?commands show trange
?set trange
?show trange
?trange
 コマンド `set trange` は、媒介変数モード、あるいは極座標モードでの x,y
 の値を計算するのに使われる媒介変数の範囲を設定します。詳細は、以下参照:
 `set xrange`。
?commands set ttics
?commands show ttics
?set ttics
?show ttics
?ttics
 コマンド `set ttics` は、極座標グラフの周囲に目盛り刻みをつけます。そ
 れは、`set border polar` とした場合は境界になりますが、そうでなければ
 極座標格子の、r 軸に沿って最も右端の刻みの場所に書かれる最も外側の円周
 になります。以下参照: `set grid`, `set rtics`。角の位置は、常に度の単
 位でラベル付けされます。現在の角の範囲の設定 (trange) に関係なく、同心
 円全体に刻みラベルをつけることができます。刻みラベルが必要な範囲の設定
 は、下に示す例のようにしてください。刻みに関する追加属性を設定すること
 もできます。以下参照: `xtics`。

      set ttics -180, 30, 180
      set ttics add ("Theta = 0" 0)
      set ttics font ":Italic" rotate
?commands set urange
?commands show urange
?set urange
?show urange
?urange
 `set urange` と `set vrange` は、`splot` の媒介変数モードで x,y,z の値
 を計算するのに使われる媒介変数の範囲を設定します。詳細は、以下参照:
 `set xrange`。
?commands show variables
?show variables all
?show variables
 `show variables` コマンドはユーザ定義変数と内部変数の現在の値の一覧を
 表示します。gnuplot は、GPVAL_, MOUSE_, FIT_, TERM_ で始まる名前を持つ
 変数を内部で定義しています。

 書式:
       show variables      # GPVAL_ で始まるもの以外の変数を表示
       show variables all  # GPVAL_ で始まるものも含め全ての変数を表示
       show variables NAME # NAME で始まる変数のみを表示

?show version
 コマンド `show version` は現在起動している gnuplot のバージョン、最終
 修正日、著作権者と、FAQ や info-gnuplot メーリングリスト、バグレポート
 先のメールアドレスを表示します。対話的にプログラムが呼ばれているときは
 スクリーン上にその情報を表示します。

 書式:
       show version {long}

 `long` オプションを与えると、さらにオペレーティングシステム、`gnuplot`
 インストール時のコンパイルオプション、ヘルプファイルの置き場所、そして
 (再び) 有用なメールアドレスを表示します。
?commands set view
?commands show view
?set view
?set view map
?show view
?view
 コマンド `set view` は `splot` の視線の角度を設定します。これは、グラ
 フ描画の 3 次元座標をどのように 2 次元の画面 (screen) に投影するかを制
 御します。これは、描画されたデータの回転と縮尺の制御を与えてくれますが
 正射影しかサポートしていません。3 次元射影、および 2 次元描画的地図上
 への 2 次元直交射影がサポートされています。

 書式:
       set view <rot_x>{,{<rot_z>}{,{<scale>}{,<scale_z>}}}
       set view map {scale <scale>}
       set view {no}equal {xy|xyz}
       set view azimuth <angle>
       show view

 ここで <rot_x> と <rot_z> は、画面に投影される仮想的な 3 次元座標系の
 回転角 (単位は度) の制御で、最初は (すなわち回転が行なわれる前は)
 画面内の水平軸は x, 画面内の垂直軸は y, 画面自身に垂直な軸が z となっ
 ています。最初は x 軸の周りに <rot_x> だけ回転されます。次に、新しい
 z 軸の周りに <rot_z> だけ回転されます。

 コマンド `set view map` は、グラフを地図のように表示するのに使います。
 これは等高線 (`contour`) のグラフや、pm3d モードによる 2 次元温度分布
 などで `with image` よりもむしろ有用です。後者では、入力データ点のフィ
 ルタ用の `zrange` の設定、および色の範囲の縮尺に関する `cbrange` の設
 定を適切に行うことに注意してください。

 <rot_x> は [0:180] の範囲に制限されていて、デフォルトでは 60 度です。
 <rot_z> は [0:360] の範囲に制限されていて、デフォルトでは 30 度です。
 <scale> は `splot` 全体の伸縮率を制御し、<scale_z> は z 軸の伸縮のみを
 行ないます。伸縮率のデフォルトはどちらも 1.0 です。

 例:
       set view 60, 30, 1, 1
       set view ,,0.5

 最初の例は 4 つの全てをデフォルトの値にしています。2 つめの例は縮小率
 のみを 0.5 に変更しています。
?set view azimuth
?view azimuth
?azimuth
       set view azimuth <angle-in-degrees>
 azimuth の設定は、3 次元グラフ (splot) の z 軸の向きに影響します。デフ
 ォルトは azimuth = 0 で、グラフの z 軸はスクリーンの水平方向に対して垂
 直な平面に含まる、すなわち、z 軸の 2 次元射影がスクリーンの鉛直方向に
 なります。0 でない azimuth は視界を原点に関して回転し、z 軸の射影は鉛
 直方向ではなくなります。azimuth = 90 では z 軸は鉛直方向ではなく、水平
 方向になります。
?set view equal_axes
?set view equal xyz
?set view equal
?view equal_axes
?view equal xyz
?equal_axes
?equal xyz
 コマンド `set view equal xy` は x 軸と y 軸の単位の長さが強制的に等し
 くなるように縮尺を合わせ、グラフがページに丁度合うようにその縮尺を選択
 します。コマンド `set view equal xyz` は、さらに z 軸も x と y 軸に合
 うようにしますが、現在の z 軸の範囲が、描画境界の範囲に合う保証はあり
 ません。デフォルトでは、3 つの軸は独立に有効な領域を埋めるように伸縮さ
 れます。

 以下も参照: `set xyplane`。
?commands set vrange
?commands show vrange
?set vrange
?show vrange
?vrange
 コマンド `set urange` と `set vrange` は、`splot` の媒介変数 (パラメー
 タ) モードで x, y, z の値を計算するのに使われる媒介変数の範囲を設定し
 ます。 詳細は、以下参照: `set xrange`。
?commands set x2data
?commands show x2data
?set x2data
?show x2data
?x2data
 コマンド `set x2data` は x2 (上) 軸のデータを時系列 (日時) 形式に設定
 します。詳細は、以下参照: `set xdata`。
?commands set x2dtics
?commands unset x2dtics
?commands show x2dtics
?set x2dtics
?unset x2dtics
?show x2dtics
?x2dtics
?nox2dtics
 コマンド `set x2dtics` は x2 (上) 軸の目盛りを曜日に変更します。詳細は、
 以下参照: `set xdtics`。
?commands set x2label
?commands show x2label
?set x2label
?show x2label
?x2label
 コマンド `set x2label` は x2 (上) 軸の見出しを設定します。詳細は、以下
 参照: `set xlabel`。
?commands set x2mtics
?commands unset x2mtics
?commands show x2mtics
?set x2mtics
?unset x2mtics
?show x2mtics
?x2mtics
?nox2mtics
 コマンド `set x2mtics` は、x2 (上) 軸を 1 年の各月に設定します。詳細は、
 以下参照: `set xmtics`。
?commands set x2range
?commands show x2range
?set x2range
?show x2range
?x2range
 コマンド `set x2range` は x2 (上) 軸の表示される水平範囲を設定します。
 コマンドオプションのすべての説明については、以下参照: `set xrange`。以
 下も参照: `set link`。
?commands set x2tics
?commands unset x2tics
?commands show x2tics
?set x2tics
?unset x2tics
?show x2tics
?x2tics
?nox2tics
 コマンド `set x2tics` は x2 (上) 軸の、見出し付けされる大目盛りの制御
 を行ないます。詳細は、以下参照: `set xtics`。
?commands set x2zeroaxis
?commands unset x2zeroaxis
?commands show x2zeroaxis
?set x2zeroaxis
?unset x2zeroaxis
?show x2zeroaxis
?x2zeroaxis
?nox2zeroaxis
 コマンド `set x2zeroaxis` は、原点を通る x2 (上) 軸 (y2 = 0) を描きま
 す。詳細は、以下参照: `set zeroaxis`。
?commands set xdata
?commands show xdata
?set xdata
?show xdata
?xdata
 このコマンドは x 軸のデータ形式の解釈を制御します。他の軸それぞれにも
 同様のコマンドが機能します。

 書式:
       set xdata time
       show xdata

 `ydata`, `zdata`, `x2data`, `y2data`, `cbdata` にも同じ書式が当てはま
 ります。

 `time` オプションはデータが秒単位の日時データであることを伝えます。現
 在の gnuplot は時刻をミリ秒の精度保存します。

 オプションなしの場合は、データの解釈方法を通常の形式に戻します。
?commands set xdata time
?set xdata time
 `set xdata time` は、x 座標がミリ秒精度の日時データであることを意味し
 ます。`set ydata time` という同様のコマンドもあります。

 日時データの入力と出力の解釈には、別々の書式機構があります。ファイルか
 らの入力データは、全体に通用する `timefmt` を使うか、または plot コマ
 ンド内で timecolumn() 関数を使って読み込みます。この入力機構は、軸の範
 囲 (range) を設定するときに時間の値を使用する際にも適用されます。以下
 参照: `set timefmt`, `timecolumn`。

 例:

      set xdata time
      set timefmt "%d-%b-%Y"
      set xrange ["01-Jan-2013" : "31-Dec-2014"]
      plot DATA using 1:2
 または
      plot DATA using (timecolumn(1,"%d-%b-%Y")):2

 出力、すなわち軸に沿った目盛りのラベルや、マウス操作での座標出力につい
 ては、デフォルトでは、秒での内部時刻から日時を表現する文字列への変換に
 は、関数 'strftime' (unix でそれを調べるには "man strftime" とタイプし
 てください) を使います。`gnuplot` はこれを適当に意味のある書式で表示し
 ようとしますが、`set format x` か `set xtics format` のいずれかを使っ
 てカスタマイズすることもできます。
 特別な時間書式指定子に関しては、以下参照: `time_specifiers`。他の情報
 については、以下も参照: `time/date`。
?commands set xdtics
?commands unset xdtics
?commands show xdtics
?set xdtics
?unset xdtics
?show xdtics
?xdtics
?noxdtics
 コマンド `set xdtics` は x 軸の目盛りの刻みを曜日に変換します (0=Sun,
 6=Sat)。6 を越える場合は 7 による余りが使われます。`unset xdtics` は
 その見出しをデフォルトの形式に戻します。他の軸にも同じことを行なう同
 様のコマンドが用意されています。

 書式:
       set xdtics
       unset xdtics
       show xdtics

 `ydtics`, `zdtics`, `x2dtics`, `y2dtics`, `cbdtics` にも同じ書式が当て
 はまります。

 以下も参照: `set format`。
?commands set xlabel
?commands show xlabel
?set xlabel
?show xlabel
?xlabel
 コマンド `set xlabel` は x 軸の見出しを設定します。他の軸にも見出しを
 設定する同様のコマンドがあります。

 書式:
       set xlabel {"<label>"} {offset <offset>} {font "<font>{,<size>}"}
                  {textcolor <colorspec>} {{no}enhanced}
                  {rotate by <degrees> | rotate parallel | norotate}
       show xlabel

 同じ書式が `x2label`, `ylabel`, `y2label`, `zlabel`, `cblabel` にも適
 用されます。

 <offset> を x,y かまたは x,y,z の形式で指定した場合は、見出しは与えら
 れた値だけ移動されます。それに座標系を選択して、その前に `first`,
 `second`, `graph`, `screen`, `character` のいずれかをつけることもでき
 ます。詳細は、以下参照: `coordinates`。デフォルトでは `character` 座標
 系が使われます。例えば、"`set xlabel offset -1,0`" は見出しの x 方向の
 位置のみ変更し、大ざっぱに言って 1 文字分の幅だけ見出しを左にずらしま
 す。1 文字の大きさは、フォントと出力形式の両方に依存します。

 <font> は見出しが書かれるフォントを指定するのに使われます。フォントの
 <size> (大きさ) の単位は、どんな出力形式を使うかに依存します。

 `noenhanced` は、拡張文字列処理 (enhanced text) モードが有効になってい
 る場合でも、ラベル文字列を拡張文字列処理させないようにします。

 見出しを消去するには、オプションをつけずに実行します。例: "`set y2label`"

 軸の見出しのデフォルトの位置は以下の通りです:

 xlabel: x 軸の見出しはグラフの下の真中

 ylabel: y 軸の見出しはグラフの左の真中で、水平方向に書かれるか垂直方向
 になるかは出力形式依存。
 グラフの左側に回転させない ylabel 文字列を置くには、十分なスペースがな
 い場合もありえます。その場合は、`set lmargin` で揃えられます。

 zlabel: z 軸の見出しは軸の表示範囲より上で、見出しの真中が z 軸の真上

 cblabel: 色見本 (color box) の軸の見出しは箱に沿って中央揃えされ、箱の
 向きが水平なら下に、垂直なら右に

 y2label: y2 軸の見出しは y2 軸の右。その位置は、出力形式依存で y 軸と
 同様の規則で決定。

 x2label: x2 軸の見出しはグラフの上で、タイトルよりは下。これは、 改行
 文字を使えば、それによる複数の行からなる描画タイトルで x2 軸の見出しを
 生成することも可能。例:

       set title "This is the title\n\nThis is the x2label"

 これは二重引用符を使うべきであることに注意してください。この場合、もち
 ろん 2 つの行で同じフォントが使われます。

 2 次元描画の場合の x, x2, y, y2 軸のラベルの方向 (回転角) は、
 `rotate by <角度>` を指定することで変更できます。3 次元描画の x, y 軸
 のラベルの方向はデフォルトでは水平方向になっていますが、
 `rotate parallel` を指定することで軸に平行にすることができます。

 もし軸の位置のデフォルトの位置が気に入らないならば、代わりに `set label`
 を使ってください。このコマンドは文字列をどこに配置するかをもっと自由に
 制御できます。

 バックスラッシュ文字列の作用、及び文字列を囲む単一引用符と二重引用符の
 違いに関するより詳しい情報については、以下参照: `syntax`。
?commands set xmtics
?commands unset xmtics
?commands show xmtics
?set xmtics
?unset xmtics
?show xmtics
?xmtics
?noxmtics
 コマンド `set xmtics` は x 軸の目盛りの見出しを月に変換します。1=Jan
 (1 月)、12=Dec (12 月) となります。12 を越えた数字は、12 で割ったあまりの
 月に変換されます。`unset xmtics` で目盛りはデフォルトの見出しに戻ります。
 他の軸に対しても同じ役割をする同様のコマンドが用意されています。

 書式:
       set xmtics
       unset xmtics
       show xmtics

 `x2mtics`, `ymtics`, `y2mtics`, `zmtics`, `cbmtics` にも同じ書式が適用
 されます。

 以下も参照: コマンド `set format`。
?commands set xrange
?commands show xrange
?set xrange
?show xrange
?writeback
?restore
?xrange
 コマンド `set xrange` は表示される水平方向の範囲を指定します。他の軸
 にも同様のコマンドが存在しますし、極座標での動径 r, 媒介変数 t, u, v
 にも存在します。

 書式:
       set xrange [{{<min>}:{<max>}}] {{no}reverse} {{no}writeback} {{no}extend}
                  | restore
       show xrange

 ここで <min> と <max> は定数、数式、または '*' で、'*' は自動縮尺機能
 を意味します。日時データの場合、範囲は `set timefmt` の書式に従った文
 字列を引用符で囲む必要があります。<min> や <max> を省略した場合は、現
 在の値を変更しません。自動縮尺機能に関する詳細は下に述べます。以下も参
 照: `noextend`。

 `yrange`, `zrange`, `x2range`, `y2range`, `cbrange`, `rrange`, `trange`,
 `urange`, `vrange` は同じ書式を使用します。

 x と x2 軸、あるいは y と y2 軸の範囲をリンクするオプションについては
 以下参照: `set link`。

 オプション `reverse` は、自動縮尺の軸の方向を逆にします。例えば、デー
 タ値の範囲が 10 から 100 であるとき、これは、set xrange [100:10] とし
 たのと同じように自動縮尺します。`reverse` は、自動縮尺ではない軸に対し
 ては機能しません。注意: この変更は、バージョン 4.7 で導入されました。

 自動縮尺機能: <min> (同様のことが <max> にも適用されます) がアスタリス
 ク "*" の場合は自動縮尺機能がオンになります。その場合のその値に、下限
 <lb>、または上限 <ub>、またはその両方の制限を与えられます。書式は以下
 の通りです。
       { <lb> < } * { < <ub> }
 例えば
       0 < * < 200
 は <lb> = 0, <ub> = 200 となります。そのような設定では、<min> は自動縮
 尺されますが、その最終的な値は 0 から 200 の間になります (記号は '<'
 ですが両端の値も含みます)。下限か上限を指定しない場合は、その '<' も省
 略できます。<ub> が <lb> より小さい場合は、制限はオフになり、完全な自
 動縮尺になります。
 この機能は、自動縮尺だけれども範囲に制限がある測定データの描画や、外れ
 値のクリッピング、またはデータがそれほどの範囲を必要としていなくても最
 小の描画範囲を保証するのに有用でしょう。

 オプション `writeback` は、`set xrange` で占められているバッファの中に
 自動縮尺機能により作られた範囲を保存します。これは、いくつかの関数を同
 時に表示し、しかしその範囲はそのうちのいくつかのものから決定させたい場
 合に便利です。`writeback` の作用は、`plot` の実行中に機能するので、その
 コマンドの前に指定する必要があります。最後に保存した水平方向の範囲は
 `set xrange restore` で復元できます。例を上げます。

       set xrange [-10:10]
       set yrange [] writeback
       plot sin(x)
       set yrange restore
       replot x/2

 この場合、y の範囲 (yrange) は sin(x) の値域として作られた [-1:1] の方
 になり、x/2 の値域 [-5:5] は無視されます。上記のそれぞれのコマンドの後
 に `show yrange` を実行すれば、上で何が行なわれているかを理解する助け
 になるでしょう。

 2 次元描画において、`xrange` と `yrange` は軸の範囲を決定し、`trange`
 は、媒介変数モードの媒介変数の範囲、あるいは極座標モードの角度の範囲を
 決定します。同様に 3 次元媒介変数モードでは、`xrange`, `yrange`, `zrange`
 が軸の範囲を管理し、`urange` と `yrange` が媒介変数の範囲を管理します。

 極座標モードでは、`rrange` は描画される動径の範囲を決定します。<rmin>
 は動径への追加の定数として作用し、一方 <rmax> は動径を切り捨てる (clip)
 ように作用し、<rmax> を越えた動径に対する点は描画されません。`xrange`
 と `yrange` は影響されます。これらの範囲は、グラフが r(t)-rmin のグラ
 フで、目盛りの見出しにはそれぞれ rmin を加えたようなものであるかのよう
 にセットされます。

 全ての範囲は部分的に、または全体的に自動縮尺されますが、データの描画で
 なければ、パラメータ変数の自動縮尺機能は意味がないでしょう。

 範囲は `plot` のコマンドライン上でも指定できます。コマンドライン上で与
 えられた範囲は単にその `plot` コマンドでだけ使われ、`set` コマンドで設
 定された範囲はその後の描画で、コマンドラインで範囲を指定していないもの
 全てで使われます。これは `splot` も同じです。

 例:

 x の範囲をデフォルトの値にします:
       set xrange [-10:10]

 y の範囲が下方へ増加するようにします:
       set yrange [10:-10]

 z の最小値には影響を与えずに (自動縮尺されたまま)、最大値のみ 10 に設
 定します:
       set zrange [:10]

 x の最小値は自動縮尺とし、最大値は変更しません:
       set xrange [*:]

 x の最小値を自動縮尺としますが、その最小値は 0 以上にします。
       set xrange [0<*:]

 x の範囲を自動縮尺としますが、小さくても 10 から 50 の範囲を保持します
 (実際はそれより大きくなるでしょう):
       set xrange [*<10:50<*]

 自動縮尺で最大範囲を -1000 から 1000、すなわち [-1000:1000] 内で自動縮
 尺します:
       set xrange [-1000<*:*<1000]

 x の最小値を -200 から 100 の間のどこかにします:
       set xrange [-200<*<100:]

?commands set xtics
?commands unset xtics
?commands show xtics
?set xtics
?unset xtics
?show xtics
?xtics
?noxtics
 x 軸の (見出しのつく) 大目盛りは コマンド `set xtics` で制御できます。
 目盛りは `unset xtics` で消え、`set xtics` で (デフォルトの状態の) 目
 盛りがつきます。y,z,x2,y2 軸の大目盛りの制御を行なう同様のコマンドがあ
 ります。

 書式:
       set xtics {axis | border} {{no}mirror}
                 {in | out} {scale {default | <major> {,<minor>}}}
                 {{no}rotate {by <ang>}} {offset <offset> | nooffset}
                 {left | right | center | autojustify}
                 {add}
                 {  autofreq
                  | <incr>
                  | <start>, <incr> {,<end>}
                  | ({"<label>"} <pos> {<level>} {,{"<label>"}...) }
                 {format "formatstring"} {font "name{,<size>}"} {{no}enhanced}
                 { numeric | timedate | geographic }
                 {{no}logscale}
                 { rangelimited }
                 { textcolor <colorspec> }
       unset xtics
       show xtics

 同じ書式が `ytics`, `ztics`, `x2tics`, `y2tics`, `cbtics` にも適用され
 ます。

 `axis` と `border` は `gnuplot` に目盛り (目盛りの刻み自身とその見出し)
 を、それぞれ軸につけるのか、境界につけるのかを指示します。軸が境界にと
 ても近い場合、`axis` を使用すると目盛りの見出し文字を境界の外に出して
 しまうでしょう。この場合自動的なレイアウトアルゴリズムによる余白設定は
 大抵よくないものとなってしまいます。

 `mirror` は `gnuplot` に反対側の境界の同じ位置に、見出しのない目盛りを
 出力するよう指示します。`nomirror` は、あなたが想像している通りのこと
 を行ないます。

 `in` と `out` は目盛りの刻みを内側に描くか外側に描くかを切り変えます。

 目盛りの刻みのサイズは `scale` で調整できます。<minor> の指定が省略さ
 れた場合は、それは 0.5*<major> になります。デフォルトのサイズは、大目
 盛りが 1.0 で小目盛りが 0.5 で、これは `scale default` で呼びだせます。

 `rotate` は、文字列を 90 度回転させて出力させようとします。これは、文
 字列の回転をサポートしている出力ドライバ (terminal) では実行されます。
 `norotate` はこれをキャンセルします。`rotate by <ang>` は角度 <ang> の
 回転を行ないますが、これはいくつかの出力形式 (terminal) でサポートされ
 ています。

 x と y 軸の大目盛りのデフォルトは `border mirror norotate` で、x2, y2
 軸は `border nomirror norotate` がデフォルトです。z 軸には、
 `{axis | border}` オプションは無効で、デフォルトは `nomirror` です。z
 軸の目盛りをミラー化したいなら、多分 `set border` でそのための空間をあ
 ける必要があるでしょう。

 <offset> は x,y かまたは x,y,z の形式で指定しますが、それに座標系を選
 択して、その前に `first`, `second`, `graph`, `screen`, `character` の
 いずれかをつけることもできます。<offset> は刻み文字のデフォルトの位置
 からのずれを表し、デフォルトの座標系は `character` です。詳細は、以下
 参照: `coordinates`。`nooffset` はずらしを無効にします。

 例:

 xtics をより描画に近づける:
       set xtics offset 0,graph 0.05

 デフォルトでは見出しラベルは、美しい結果を生むように、軸と回転角に依存
 した位置に自動的に揃えられますが、気にいらなければ、明示的に `left`,
 `right`, `center` のキーワードにより位置揃えを変更できます。
 `autojustify` でデフォルトの挙動に復帰します。

 オプションなしで `set xtics` を実行すると、目盛りが表示される状態であ
 れば、それはデフォルトの境界、または軸を復元し、そうでなければ何もしま
 せん。その前に指定した目盛りの間隔、位置 (と見出し) は保持されます。

 目盛りの位置は、デフォルト、またはオプション `autofreq` が指定されてい
 れば自動的に計算されます。

 目盛りの位置の列は、目盛りの間隔のみ、または開始位置と間隔と終りの位置、
 のいずれかを指定することができます (以下参照: `xtics series`)。

 明示的な位置のリストを与えることで、個々の目盛りの位置を個別に指定する
 こともできます。各位置には、それに対する見出しラベルを指定することもで
 きます。以下参照: `xtics list`。

 しかし指定しても、表示されるのはあくまで描画範囲のものだけです。

 目盛りの見出しの書式 (または省略) は `set format` で制御されます。ただ
 しそれは `set xtics (`<label>`)` の形式の明示的な見出し文字列が含まれ
 ていない場合だけです。

 (見出し付けされない) 小目盛りは、`set mxtics` コマンドで自動的に追加す
 るか、または位置を手動で `set xtics ("" <pos> 1, ...)` の形式で与える
 こともできます。

 刻みの見た目 (線種、幅等) は、それを軸の上に描く場合であっても、境界線
 によって決定されます (以下参照: `set border`)。
?set xtics series
?xtics series
 書式:
      set xtics <incr>
      set xtics <start>, <incr>, <end>
 暗示的な <start>, <incr>, <end> 形式は、目盛りの列を <start> から <end>
 の間を <incr> の間隔で表示します。<end> を指定しなければ、それは無限大
 とみなされます。<incr> は負の値も可能です。<start> と <end> の両方が指
 定されていない場合、<start> は -∞、<end> は +∞とみなされ、目盛りは
 <incr> の整数倍の位置に表示されます。軸が対数軸の場合、目盛りの間隔
 (増分) は、倍数として使用されます。

 負の <start> や <incr> を、数値の後ろに指定すると (例えば
 `rotate by <angle>` とか `offset <offset>` の後ろ)、gnuplot の構文解析
 器は、その値からその負の <start> や <incr> の値の引き算を行おうとする
 間違いを犯します。これを回避するには、そのような場合は、`0-<start>` や
 `0-<incr>` のように指定してください。

 例:
       set xtics border offset 0,0.5 -5,1,5
 最後の ',' のところで失敗します。
       set xtics border offset 0,0.5 0-5,1,5
 か
       set xtics offset 0,0.5 border -5,1,5
 ならば、ちゃんと指示通りに、目盛りを境界に、目盛り見出し文字列を 0,0.5
 文字分だけずらして、start, increment, end をそれぞれ -5,1,5 に設定しま
 す。

 `set grid` のオプション 'front', 'back', 'layerdefault' も、x 軸の目盛
 りの描画の順序に影響します。

 例:

 目盛りを 0, 0.5, 1, 1.5, ..., 9.5, 10 の位置に生成
       set xtics 0,.5,10

 目盛りを ..., -10, -5, 0, 5, 10, ... に生成
       set xtics 5

 目盛りを 1, 100, 1e4, 1e6, 1e8 に生成
       set logscale x; set xtics 1,100,1e8

?set xtics list
?set xtics add
?xtics list
?xtics add
 書式:
      set xtics {add} ("label1" <pos1> <level1>, "label2" <pos2> <level2>, ...)

 明示的な ("label" <pos> <level>, ...) の形式は、任意の目盛りの位置、あ
 るいは数字でない見出しの生成も可能にします。この形式では、目盛りは位置
 の数字の順に与える必要はありません。各目盛りは位置 (pos) と見出し
 (label) を持ちますが、見出しは必須ではありません。

 見出しは引用符で囲んだ文字列か、または文字列値の数式です。それには、
 "%3f clients" のようにその位置を数字に変換する書式文字列を入れても構い
 ませんし、空文字列 "" でも構いません。より詳しい情報については、以下参
 照: `set format`。もし、文字列を指定しなければ、デフォルトの数字の見出
 しを使用します。

 明示的な形式では 3 つ目のパラメータとしてレベルを指定できます。デフォ
 ルトのレベルは 0 で、これは大目盛りを意味し、レベル 1 の場合は小目盛り
 を生成します。ラベルは、小目盛りには決して付きません。大目盛りと小目盛
 りは gnuplot が自動的に生成しますが、ユーザが明示的に指定もできます。
 レベルが 2 以上の目盛りは、ユーザが明示的に指定しなければならず、自動
 生成の目盛りよりも高い優先度を持ちます。各レベルの目盛りの刻みの大きさ
 は、`set tics scale` で制御します。

 例:
       set xtics ("low" 0, "medium" 50, "high" 100)
       set xtics (1,2,4,8,16,32,64,128,256,512,1024)
       set ytics ("bottom" 0, "" 10, "top" 20)
       set ytics ("bottom" 0, "" 10 1, "top" 20)

 2 番目の例では、全ての目盛りが見出し付けされます。3 番目の例では、端の
 ものだけが見出し付けされます。4 番目の例の、見出しのない目盛りは小目盛
 りになります。

 通常明示的な (手動の) 目盛り位置が与えられた場合、自動的に生成される目
 盛りは使われません。逆に、`set xtics auto` のようなものが指定された場
 合は、以前に手動で設定した目盛りは消されてしまします。この手動の目盛り
 と自動的な目盛りを共存させるにはキーワード `add` を使用してください。
 これは追加する目盛りのスタイルの前に書かなければいけません。

 例:
       set xtics 0,.5,10
       set xtics add ("Pi" 3.14159)

 これは自動的に目盛りの刻みを x 軸に 0.5 間隔でつけますが、πのところに
 明示的な見出しも追加します。
?set xtics timedata
?xtics timedata tics
?timedata tics
 時間と日付は内部では秒数として保持されています。

 入力: 非数値の日時値は、入力時に `timefmt` で指定した書式を用いて秒数
 に変換します。軸に対する位置や軸の範囲も `timefmt` で解釈される日時で、
 引用符で囲んで与えます。
 <start>, <incr>, <end> 形式を使う場合、<incr> は秒単位で与えなければい
 けません。入力データの解釈には `timefmt` を使ってください。軸の範囲と
 目盛りの位置は、`set xdata time` で変更されます。

 出力: 軸の目盛りラベルは、`set format` か `set xtics format` のいずれ
 かで指定された、別の書式を使って生成します。デフォルトでは、それは通常
 の数値書式指定であると認識しますが (`set xtics numeric`)、他に、地理座
 標 (`set xtics geographic`) や、日時データ (`set xtics time`) のオプシ
 ョンがあります。

 注意: 以前の版の gnuplot との互換性のため、コマンド `set xdata time`
 も暗黙に `set xtics time` を実行しますし、`set xdata` や `unset xdata`
 は暗黙に `set xtics numeric` へリセットします。しかし、これはその後に
 `set xtics` を呼び出すことで変更できます。

 例:
       set xdata time           # 入力データの解釈の制御
       set timefmt "%d/%m"      # 入力データの読み込みの書式
       set xtics timedate       # 出力書式の解釈の制御
       set xtics format "%b %d" # 目盛りラベルで使う書式
       set xrange ["01/12":"06/12"]
       set xtics "01/12", 172800, "05/12"

       set xdata time
       set timefmt "%d/%m"
       set xtics format "%b %d" time
       set xrange ["01/12":"06/12"]
       set xtics ("01/12", "" "03/12", "05/12")
 これらは両方とも "Dec 1", "Dec 3", "Dec 5", の目盛りを生成しますが、2
 番目の例 "Dec 3" の目盛りは見出し付けされません。
?commands set xtics geographic
?set xtics geographic
?geographic
 `set xtics geographic` は、x 軸の値が度の単位の地理座標であることを意
 味します。その軸の刻みの見出しの表現の指定には、`set xtics format` か
 `set format x` を使います。地理座標データに関する書式指定子は以下の通
 り:
        %D                   = 度の整数表示
        %<width.precision>d  = 度の浮動小数表示
        %M                   = 分の整数表示
        %<width.precision>m  = 分の浮動小数表示
        %S                   = 秒の整数表示
        %<width.precision>s  = 秒の浮動小数表示
        %E                   = +/- でなく E/W のラベル
        %N                   = +/- でなく N/S のラベル
 例えば、コマンド `set format x "%Ddeg %5.2mmin %E"` は、x 座標の -1.51
 という値を `" 1deg 30.60min W"` のように表示します。

 xtics がデフォルトの状態のまま (`set xtics numeric`) の場合は、座標は
 10 進数の度で表示し、`format` も上の特別な記号ではなく、通常の数値書式
 が使われているとみなされます。

 マップ上にラベルを置くなど、軸の目盛りとは異なる場所で度/分/秒の出力を
 するには、strptime に相対的時間書式指定 %tH %tM %tS を使用できます。以
 下参照: `time_specifiers`, `strptime`。
?set xtics logscale
?xtics logscale
 対数軸に沿う刻みに対して `logscale` 属性を設定すると、刻みの間隔は公差
 ではなく、公比と解釈されます。例:
      # y=20 y=200 y=2000 y=20000 に刻み列を作成
      set log y
      set ytics 20, 10, 50000 logscale
 y=50000 は 2*10^x の数列には含まれないので、そこには刻みはつかないこと
 に注意してください。logscale 属性が無効の場合、軸の増分は、たとえ対数
 軸であっても公差として扱われます。例:
      # y=20 y=40 y=60 ... y=200 に刻みを作成
      set log y
      set yrange [20:200]
      set ytics 20 nologscale
 `logscale` 属性は、コマンド `set log` で自動的に設定されるので、2 つ目
 の例のような軸の刻み間隔に強制的にしたい場合でなければ、通常はこのキー
 ワードは必要ありません。
?set xtics rangelimited
?xtics rangelimited
?rangelimited
?range-frame
 このオプションは、自動的に生成される軸の目盛りの見出しと、描画されたデ
 ータで実際に与えられる範囲に対応する描画境界の両方を制限します。これは
 描画に対する現在の範囲制限とは無関係であることに注意してください。例え
 ばデータ "file.dat" のデータがすべて 2 < y < 4 の範囲にあるとすると、
 以下のコマンドは、左側の描画境界 (y 軸) は y の範囲全体 ([0:10]) のこ
 の部分 ([2:4]) のみが描画され、この範囲 ([2:4]) の軸の目盛りのみが作ら
 れる描画を生成します。つまり、描画は y の範囲全体 ([0:10]) に拡大され
 ますが、左の境界は 0 から 2 の間、4 から 10 の間は空白領域となります。
 このスタイルは、`範囲枠` グラフ (range-frame) とも呼ばれます。
       set border 3
       set yrange [0:10]
       set ytics nomirror rangelimited
       plot "file.dat"
?commands set xyplane
?commands show xyplane
?set xyplane
?show xyplane
?xyplane
 `set xyplane` コマンドは 3D 描画で描かれる xy 平面の位置を調整するのに
 使われます。後方互換性のために、"set ticslevel" も同じ意味のコマンドと
 して使うことができます。

 書式:
       set xyplane at <zvalue>
       set xyplane relative <frac>
       set ticslevel <frac>        # set xyplane relative と同等
       show xyplane

 `set xyplane relative <frac>` は、xy 平面を Z 軸の範囲のどこに置くかを
 決定します。<frac> には、xy 平面と z の一番下の位置との差の、z 軸の範
 囲全体に対する割合を与えます。デフォルトの値は 0.5 です。負の値も許さ
 れていますが、そうすると 3 つの軸の目盛りの見出しが重なる可能性があり
 ます。

 もう一つの形式である `set xyplane at <zvalue>` は、現在の z の範囲を気
 にすることなく、指定した z の値の位置に xy 平面を固定します。よって、
 x,y,z 軸を共通の原点を通るようにするには、`set xyplane at 0` とすれば
 いいことになります。

 以下も参照: `set view`, `set zeroaxis`。
?commands set xzeroaxis
?commands unset xzeroaxis
?commands show xzeroaxis
?set xzeroaxis
?unset xzeroaxis
?show xzeroaxis
?xzeroaxis
?noxzeroaxis
 コマンド `set xzeroaxis` は y = 0 の直線を描きます。詳細に関しては、以
 下参照: `set zeroaxis`。
?commands set y2data
?commands show y2data
?set y2data
?show y2data
?y2data
 コマンド `set y2data` は y2 (右) 軸のデータを時系列 (日時) 形式に設定
 します。詳細は、以下参照: `set xdata`。
?commands set y2dtics
?commands unset y2dtics
?set y2dtics
?unset y2dtics
?show y2dtics
?y2dtics
?noy2dtics
 コマンド `set y2dtics` は y2 (右) 軸の目盛りを曜日に変更します。詳細は、
 以下参照: `set xdtics`。
?commands set y2label
?commands show y2label
?set y2label
?show y2label
?y2label
 コマンド `set y2label` は y2 (右) 軸の見出しを設定します。詳細は、以下
 参照: `set xlabel`。
?commands set y2mtics
?commands unset y2mtics
?commands show y2mtics
?set y2mtics
?unset y2mtics
?show y2mtics
?y2mtics
?noy2mtics
 コマンド `set y2mtics` は y2 (右) 軸の目盛りを 1 年の各月に変更します。
 詳細は、以下参照: `set xmtics`。
?commands set y2range
?commands show y2range
?set y2range
?show y2range
?y2range
 コマンド `set y2range` は y2 (右) 軸の表示される垂直範囲を設定します。
 コマンドオプションのすべての説明については、以下参照: `set xrange`。以
 下も参照: `set link`。
?commands set y2tics
?commands unset y2tics
?commands show y2tics
?set y2tics
?unset y2tics
?show y2tics
?y2tics
?noy2tics
 コマンド `set y2tics` は y2 (右) 軸の、見出し付けされる大目盛りの制御
 を行ないます。詳細は、以下参照: `set xtics`。
?commands set y2zeroaxis
?commands unset y2zeroaxis
?commands show y2zeroaxis
?set y2zeroaxis
?unset y2zeroaxis
?show y2zeroaxis
?y2zeroaxis
?noy2zeroaxis
 コマンド `set y2zeroaxis` は、原点を通る y2 (右) 軸 (x2 = 0) を描きま
 す。詳細は、以下参照: `set zeroaxis`。
?commands set ydata
?commands show ydata
?set ydata
?show ydata
?ydata
 コマンド `set ydata` は y 軸のデータを時系列 (日時) 形式に設定します。
 以下参照: `set xdata`。
?commands set ydtics
?commands unset ydtics
?commands show ydtics
?set ydtics
?unset ydtics
?show ydtics
?ydtics
?noydtics
 コマンド `set ydtics` は y 軸の目盛りを曜日に変更します。詳細は、以下
 参照: `set xdtics`。
?commands set ylabel
?commands show ylabel
?set ylabel
?show ylabel
?ylabel
 このコマンドは y 軸の見出しを設定します。以下参照: `set xlabel`。
?commands set ymtics
?commands unset ymtics
?commands show ymtics
?set ymtics
?unset ymtics
?show ymtics
?ymtics
?noymtics
 コマンド `set ymtics` は、y 軸の目盛りを月に変更します。詳細は、以下参
 照: `set xmtics`。
?commands set yrange
?commands show yrange
?set yrange
?show yrange
?yrange
 コマンド `set yrange` は、y 方向の垂直範囲を設定します。詳細は、以下参
 照: `set xrange`。
?commands set ytics
?commands unset ytics
?commands show ytics
?set ytics
?unset ytics
?show ytics
?ytics
?noytics
 コマンド `set ytics` は y 軸の (見出し付けされる) 大目盛りを制御します。
 詳細は、以下参照: `set xtics`。
?commands set yzeroaxis
?commands unset yzeroaxis
?commands show yzeroaxis
?set yzeroaxis
?unset yzeroaxis
?show yzeroaxis
?yzeroaxis
?noyzeroaxis
 コマンド `set yzeroaxis` は x = 0 の直線 (y 軸) を書きます。詳細は、以
 下参照: `set zeroaxis`。
?commands set zdata
?commands show zdata
?set zdata
?show zdata
?zdata
 コマンド `set zdata` は z 軸のデータを時系列 (日時) 形式に設定します。
 以下参照: `set xdata`。
?commands set zdtics
?commands unset zdtics
?commands show zdtics
?set zdtics
?unset zdtics
?show zdtics
?zdtics
?nozdtics
 コマンド `set zdtics` は z 軸の目盛りを曜日に変更します。詳細は、以下
 参照: `set xdtics`。
?commands set zzeroaxis
?commands unset zzeroaxis
?commands show zzeroaxis
?set zzeroaxis
?unset zzeroaxis
?show zzeroaxis
?zzeroaxis
?nozzeroaxis
 コマンド `set zzeroaxis` は (x=0,y=0) を通る直線を描きます。これは、2D
 描画、および `set view map` での splot では効力を持ちません。詳細は、
 以下参照: `set zeroaxis`, `set xyplane`。
?commands set cbdata
?commands show cbdata
?set cbdata
?show cbdata
?cbdata
 このコマンドはカラーボックス軸のデータを時系列 (日時) 形式に式に設定し
 ます。以下参照: `set xdata`。
?commands set cbdtics
?commands unset cbdtics
?commands show cbdtics
?set cbdtics
?unset cbdtics
?show cbdtics
?cbdtics
?nocbdtics
 コマンド `cbdtics` はカラーボックス軸の目盛りの刻みを曜日に変換します。
 詳細は、以下参照: `set xdtics`。
?commands set zero
?commands show zero
?set zero
?show zero
?zero
 `zero` の値は、0.0 に近いデフォルトの閾値を表します。

 書式:
       set zero <expression>
       show zero

 `gnuplot` は、(複素数値を持つ点の描画においては) その値の虚数部分の絶
 対値が `zero` 閾値より大きい場合 (つまり実数でない値を持つ点) は、その
 点を描画しません。この閾値は `gnuplot` の他の様々な部分においてその
 (大まかな) 数値誤差の閾値としても使われています。デフォルトの `zero` の
 値は 1e-8 です。1e-3 (= 典型的なビットマップディスプレイの解像度の逆数)
 より大きい `zero` の値は設定すべきではないでしょうが、`zero` を 0.0 と
 設定するのは意味のないことではありません。
?commands set zeroaxis
?commands unset zeroaxis
?commands show zeroaxis
?set zeroaxis
?unset zeroaxis
?show zeroaxis
?zeroaxis
 x 軸は `set xzeroaxis` によって描かれ、`unset xzeroaxis` によって削除
 されます。同様の y, x2, y2, z 軸用のコマンドが同様の働きをします。
 `set zeroaxis ...` (前置詞なし) は、x, y, z 軸すべてに機能します。

 書式:
       set {x|x2|y|y2|z}zeroaxis { {linestyle | ls <line_style>}
                                  | {linetype | lt <line_type>}
                                    {linewidth | lw <line_width>}
                                    {linecolor | lc <colorspec>}
                                    {dashtype | dt <dashtype>} }
       unset {x|x2|y|y2|z}zeroaxis
       show {x|y|z}zeroaxis


 デフォルトでは、これらのオプションはオフになっています。選択された 0
 の軸は <line_type> の線の型、<line_width> の線の幅、<colorspec> の色、
 <dashtype> の点線/破線パターンで (いずれも現在使用している出力形式が
 サポートしていれば)、あるいはあらかじめ定義された <line_style> のスタ
 イルで描かれます。以下参照: `set style line`。

 線の型を指定しなければ、軸は通常の軸の線の型 (型 0) で描かれます。

 例:

 y=0 の軸を見えるように簡単に書く場合:

        set xzeroaxis

 太い線にして、違った色、または点線パターンにしたい場合:

        set xzeroaxis linetype 3 linewidth 2.5
?commands set zlabel
?commands show zlabel
?set zlabel
?show zlabel
?zlabel
 このコマンドは z 軸の見出しを設定します。以下参照: `set xlabel`。
?commands set zmtics
?commands unset zmtics
?commands show zmtics
?set zmtics
?unset zmtics
?show zmtics
?zmtics
?nozmtics
 コマンド `set zmtics` は z 軸の目盛りを月に変更します。詳細は、以下参
 照: `set xmtics`。
?commands set zrange
?commands show zrange
?set zrange
?show zrange
?zrange
 コマンド `set zrange` は z 軸方向に表示される範囲を設定します。このコ
 マンドは `splot` にのみ有効で、`plot` では無視されます。詳細は、以下参
 照: `set xrange`。
?commands set ztics
?commands unset ztics
?commands show ztics
?set ztics
?unset ztics
?show ztics
?ztics
?noztics
 コマンド `set ztics` は z 軸の (見出し付けされる) 大目盛りを制御します。
 詳細は、以下参照: `set xtics`。
?commands set cblabel
?commands show cblabel
?set cblabel
?show cblabel
?cblabel
 このコマンドはカラーボックス軸の見出しを設定します。以下参照:
 `set xlabel`。
?commands set cbmtics
?commands unset cbmtics
?commands show cbmtics
?set cbmtics
?unset cbmtics
?show cbmtics
?cbmtics
?nocbmtics
 コマンド `set cbmtics` はカラーボックス軸の目盛りの見出しを月に変換し
 ます。詳細は、以下参照: `set xmtics`。
?commands set cbrange
?commands show cbrange
?set cbrange
?show cbrange
?cbrange
 コマンド `set cbrange` は、スタイル `with pm3d`, `with image` や
 `with palette` などによって現在のパレット (`palette`) を使って色付けさ
 れる値の範囲を設定します。その範囲外の値に対しては、最も近い限界の値の
 色が使用されます。

 カラーボックス軸 (cb-軸) が `splot` で自動縮尺されている場合は、その
 カラーボックスの範囲は `zrange` が使われます。`splot ... pm3d|palette`
 で描画される点は、異なる `zrange` と `cbrange` を使うことでフィルタリ
 ングできます。

 `set cbrange` の書式に関する詳細は、以下参照: `set xrange`。以下も参照:
 `set palette`, `set colorbox`。
?commands set cbtics
?commands unset cbtics
?commands show cbtics
?set cbtics
?unset cbtics
?show cbtics
?cbtics
?nocbtics
 コマンド `set cbtics` はカラーボックス軸の (見出し付けされる) 大目盛り
 を制御します。詳細は、以下参照: `set xtics`。
?commands shell
?shell
 `shell` コマンドは対話的なシェルを起動します。`gnuplot` に戻るには、
 VMS では `logout` を、Unix ならば `exit` もしくは END-OF-FILE 文字を、
 MS-DOS か OS/2 ならば `exit` を入力して下さい。

 コマンド `shell` は、それ以外の gnuplot コマンドライン上のものをすべて
 無視します。そうでなく、シェルに直ちにコマンド文字列を渡したい場合は、
 関数 `system` か、ショートカット `!` を使用してください。以下参照:
 `system`。

 例:

       shell
       system "print previous_plot.ps"
       ! print previous_plot.ps
       current_time = system("date")

?commands splot
?splot
 `splot` は 3 次元描画のためのコマンドです (もちろんご存知でしょうが、
 実際にはその 2 次元への射影)。それは、`plot` コマンドの 3 次元版です。
 `splot` は、それぞれ単一の x, y, z 軸を提供するだけで、`plot` で用意さ
 れている第 2 軸 x2, y2 のようなものはありません。

 2 次元と 3 次元描画の両方で使える多くのオプションについては、以下参照:
 `plot`。

 書式:
       splot {<ranges>}
             {<iteration>}
             <function> | {{<file name> | <datablock name>}
                           {datafile-modifiers}}
                        | keyentry
             {<title-spec>} {with <style>}
             {, {definitions{,}} <function> ...}

 コマンド `splot` は、関数から生成されたデータ、またはデータファイルか
 ら読み込んだデータ、または事前に保存された名前付きデータブロックのデー
 タを処理します。データファイル名は、通常引用符で囲んだ文字列として与え
 ます。関数は 1 本の数式ですが、媒介変数モード (parametric) では 3 つの
 数式の組として与えます。

 デフォルトでは、`splot` は描画されるデータの下に完全な xy 面を描きます。
 z の一番下の目盛りと xy 平面の位置関係は `set xyplane` で変更できます。
 `splot` の射影の向きは `set view` で制御できます。詳細は、以下参照:
 `set view`, `set xyplane`。

 `splot` コマンドの範囲の指定の書式は `plot` の場合と同じです。媒介変数
 モード (parametric) でなければ、範囲指定は以下の順で、
       splot [<xrange>][<yrange>][<zrange>] ...
 媒介変数モード (parametric) では、範囲指定は以下の順で与えなければいけ
 ません:
       splot [<urange>][<vrange>][<xrange>][<yrange>][<zrange>] ...

 `title` オプションも `plot` と同じです。`with` も `plot` とほぼ同じで
 すが、2 次元の描画スタイル全部が使えるわけではありません。

 `datafile` オプションにはさらに違いがあります。

 媒介変数モード (parametric) や関数を利用して曲面を描く別の方法に、疑似
 ファイル '++' を利用して xy 平面の格子の上に標本点を生成するやり方があ
 ります。

 以下も参照: `show plot`, `set view map`, `sampling`。
?commands splot datafile
?splot datafile
 `plot` と同じように、`splot` でファイルからグラフを生成できます。

 書式:
       splot '<file_name>' {binary <binary list>}
                           {{nonuniform} matrix}
                           {index <index list>}
                           {every <every list>}
                           {using <using list>}

 `""` や `"-"` といった特別なファイル名も `plot` と同様に許されます。以
 下参照: `special-filenames`。

 手短にいうと、`binary` や `matrix` はそのデータが特別な形であることを、
 `index` は多重データ集合ファイルからどのデータ集合を選んで描画するかを、
 `every` は各データ集合からどのデータ行 (部分集合) を選んで描画するかを、
 `using` は各データ行からどのように列を選ぶかを指定します。

 `index` と `every` オプションは `plot` の場合と同じように振舞います。
 `using` も、`using` のリストが 2 つでなく 3 つ必要であるということを
 除いては同様です。

 `plot` のオプションである `smooth` は `splot` では利用できません。しか
 し、`cntrparam` や `dgrid3d` が、制限されてはいますが平滑化のために用
 意されています。

 データファイルの形式は、各点が (x,y,z) の 3 つ組である以外は、本質的に
 `plot` と同じです。もし一つの値だけが与えられれば、それは z として使わ
 れ、ブロック番号が y として、そして x はそのブロック内での番号が使われ
 ます。もし 2 つ、あるいは 4 つの値が与えられれば、`gnuplot` はその最後
 の値を pm3d plot での色の計算に使います。3 つの値は (x,y,z) の組と見な
 されます。他に値があれば、それは一般に誤差と見なされます。それは `fit`
 で使うことが可能です。

 `splot` のデータファイルでは、1 行の空行はデータのブロック分離子です。
 `splot` は個々のブロックを、関数の y-孤立線と同じものとして扱います。
 1 行の空行で分離されている点同士は線分で結ばれることはありません。全て
 のブロックが全く同じ点の数を持つ場合、`gnuplot` はブロックを横断し、各
 ブロックの対応する点同士を結ぶ孤立線を描きます。これは "grid data" と
 呼ばれ、曲面の描画、等高線の描画 (`set contour`)、隠線処理
 (`set hidden3d`) では、この形のデータであることが必要となります。以下
 も参照: `splot grid_data`。

 3 列の `splot` データにおいては、媒介変数モード (`parametric`) を指定
 することはもはや不要です。
?commands plot datafile matrix
?commands splot datafile matrix
?plot datafile matrix
?splot datafile matrix
?binary matrix
?matrix
 gnuplot は、matrix (配列) 形式のデータ入力を、2 つの異なる形式で解釈す
 ることができます。

 その 1 つは、x, y の座標が一様であると仮定して、その値をこの一様な格子
 の matrix のそれぞれの要素 M[i,j] に割り当てる方法です。
 割り当てられる x 座標は [0:NCOLS-1] の範囲の整数です。
 割り当てられる y 座標は [0:NROWS-1] の範囲の整数です。
 これは、テキストデータに対してはデフォルトですが、バイナリデータに対し
 てはそうではありません。
 例や追加キーワードについては以下参照: `matrix uniform`。

 2 つ目の形式は、非一様な格子で、x, y 座標は明示していると仮定するもの
 で、入力データの最初の行を y 座標、最初の列を x 座標とみなします。
 バイナリデータに対しては、1 行目の最初の要素は、列数でなければいけませ
 ん。これは、`binary matrix` 入力ではデフォルトですが、テキスト入力デー
 タに対しては追加キーワード `nonuniform` が必要になります。
 例に関しては以下参照: `matrix nonuniform`。

?commands plot datafile matrix uniform
?commands splot datafile matrix uniform
?datafile matrix uniform
?matrix uniform
?binary matrix uniform
 一様な matrix データを描画するコマンドの例:
      splot 'file' matrix using 1:2:3          # テキストデータ
      splot 'file' binary general using 1:2:3  # バイナリデータ

 一様な格子の matrix データでは、各ブロックの z の値は一行で一度に読ま
 れます。すなわち、
     z11 z12 z13 z14 ...
     z21 z22 z23 z24 ...
     z31 z32 z33 z34 ...
 等。

 テキストデータに対しては、1 行目がデータでなく列ラベルを持つ場合、追加
 キーワード `columnheaders` を使ってください。同様に、各行の最初の要素
 がデータでなくラベルである場合は、追加キーワード `rowheaders` を使用し
 てください。以下は、その両方を使用する例です:
     $DATA << EOD
     xxx A   B   C   D
     aa  z11 z12 z13 z14
     bb  z21 z22 z23 z24
     cc  z31 z32 z33 z34
     EOD
     plot $DATA matrix columnheaders rowheaders with image

 テキストデータでは、空行やコメント行は配列データを終了させ、新たな曲面
 の網 (mesh) を開始します。いつものことですが、`splot` コマンドの
 `index` オプションを使ってファイル内の網を自由に選択できます。
?commands plot datafile matrix nonuniform
?commands splot datafile matrix nonuniform
?datafile matrix nonuniform
?matrix nonuniform
?binary matrix nonuniform
 入力データの最初の行は y 座標を持ちます。
 入力データの最初の列は x 座標を持ちます。
 バイナリ入力データでは、1 行目の最初の要素は列数でなければいけません
 (テキストデータではその番号は無視されます)。

 非一様な matrix データを描画するコマンドの例:
      splot 'file' nonuniform matrix using 1:2:3  # テキストデータ
      splot 'file' binary matrix using 1:2:3      # バイナリデータ

 よって、非一様な matrix データの構造は以下のようになります:

       <N+1>  <x0>   <x1>   <x2>  ...  <xN>
        <y0> <z0,0> <z0,1> <z0,2> ... <z0,N>
        <y1> <z1,0> <z1,1> <z1,2> ... <z1,N>
         :      :      :      :   ...    :

 これらは以下のような 3 つの数字の組に変換されます:

       <x0> <y0> <z0,0>
       <x0> <y1> <z0,1>
       <x0> <y2> <z0,2>
        :    :     :
       <x0> <yN> <z0,N>

       <x1> <y0> <z1,0>
       <x1> <y1> <z1,1>
        :    :     :

 そして、これらの 3 つの数字の組は `gnuplot` の孤立線に変換され、その後
 `gnuplot` が通常の方法で描画の残りを行います。
?datafile matrix every
?matrix every
 キーワード `every` は、matrix データに対して使用すると特別な意味を持ち
 ます。データの点やブロックに適用するのでなく、データの行、列に適用しま
 す。matrix の行と列は、最初に 0 から番号付けされていますので、第 N 行
 は (N+1) 番目の行であることに注意してください。
 書式:
       plot 'file' every {<column_incr>}
                           {:{<row_incr>}
                             {:{<start_column>}
                               {:{<start_row>}
                                 {:{<end_column>}
                                   {:<end_row>}}}}}
 例:
       plot 'file' matrix every :::N::N   # 第 N 行のすべての値を描画
       plot 'file' matrix every ::3::7    # すべての行の 3-7 列を描画
       plot 'file' matrix every ::3:0:7:4 # [3,0] と [7,4] 枠の部分行列
?commands plot datafile matrix examples
?commands splot datafile matrix examples
?datafile matrix examples
?matrix examples
?binary matrix examples
 行列やベクトルの操作のサブルーチン (C による) が `binary.c` に用意され
 ています。バイナリデータを書くルーチンは

       int fwrite_matrix(file,m,nrl,nrl,ncl,nch,row_title,column_title)

 です。これらのサブルーチンを使う例が `bf_test.c` として用意されていて、
 これはデモファイル `demo/binary.dem` 用に複数のバイナリファイルを生成
 します。

 `plot` での使用法:
     plot `a.dat` matrix
     plot `a.dat` matrix using 1:3
     plot 'a.gpbin' {matrix} binary using 1:3
 これらは配列の行を描画し、using 2:3 とすれば配列の列を描画、using 1:2
 は、点の座標を描画します (多分無意味です)。オプション `every` を適用す
 ることで明示的に行や列を指定できます。

 例 -- テキストデータファイルの配列の軸の拡大:
     splot `a.dat` matrix using (1+$1):(1+$2*10):3

 例 -- テキストデータファイルの配列の第 3 行の描画:
     plot 'a.dat' matrix using 1:3 every 1:999:1:2
 (行は 0 から数えられるので、3 ではなくて 2 を指定します)。

 Gnuplot は、`array`, `record`, `format`, `filetype` などの general バ
 イナリ形式を特定するようなキーワードをつけずにオプション `binary` を使
 うことで、matrix バイナリファイルを読み込むことができます。その他の変換
 用の general バイナリキーワードは、matrix バイナリファイルにも適用でき
 るでしょう。(詳細は、以下参照: `binary general`。)
?commands splot datafile example
?splot datafile example
?splot example
 以下は3 次元データファイルの描画の単純な一つの例です。

       splot 'datafile.dat'

 ここで、"datafile.dat" は以下を含むとします:

       # The valley of the Gnu.
          0 0 10
          0 1 10
          0 2 10

          1 0 10
          1 1 5
          1 2 10

          2 0 10
          2 1 1
          2 2 10

          3 0 10
          3 1 0
          3 2 10

 この "datafile.dat" は 4*3 の格子 (それぞれ 3 点からなるブロックの
 4 つの行) を定義することに注意して下さい。行 (ブロック) は 1 行の空行
 で区切られます。

 x の値はそれぞれのブロックの中で定数になっていることに注意して下さい。
 もし y を定数の値とし、隠線処理が有効な状態で描画すると、その曲面は裏
 返しで書かれることになります。

 格子状データ (grid data) に対して、個々のブロック内で x の値を定数とし
 ておく必要はありませんし、同じ場所の y の値を同じ値に揃えておく必要も
 ありません。`gnuplot` は個々のブロック内の点の数が等しいということを必
 要としているだけです。しかし、等高線を導くのに用いられる曲面の網目は、
 対応する点を列的に選んで結ぶため、不揃いの格子データに対する曲面の描画
 への影響は予想できません。それはケースバイケースの原理でテストすべきで
 しょう。
?commands splot grid_data
?splot grid_data
?grid_data
 3 次元描画のためのルーチンは、個々の網目の格子においては一つの標本点と
 一つのデータ点がある、という形の格子状データ用に設計されています。各デ
 ータ点は、関数の値を評価すること (以下参照: `set isosamples`)、または
 データファイルを読み込むこと (以下参照: `splot datafile`) によって生成
 されます。"孤立線" という言葉は関数に対しても、データに対してもその網
 目の線を表すものとして用いられます。網目は、必ずしも x, y に関する長方
 形でなくてもよく、u,v で媒介変数表示されても構わないことに注意して下さ
 い。以下参照: `set isosamples`。

 しかし、`gnuplot` はそのような形式を必ずしも必要とはしません。例えば関
 数の場合は、`samples` は `isosamples` と違っていても構いません。すなわ
 ち、x-孤立線のうち、1 本の y-孤立線と交わないものがいくつかあることが
 あります。データファイルの場合は、個々のブロックのばらついた点の個数が
 全て同じであれば、"孤立線は" はブロックの点を結び、"横断孤立線" は各ブ
 ロックの対応する点同士を結び、"曲面" を作ろうとします。どちらの場合で
 も、等高線、および隠線処理モードは点が意図したフォーマットであった場合
 とは違った描画を与えることになります。ばらつきのあるデータは
 `set dgrid3d` によって{異なる}格子状データに変換することができます。

 等高線に関するコードは、y-孤立線の点と、それに対応する隣の y-孤立線上
 の点の間の線分に沿っての z の張力を計測します。よって、x-孤立線に、
 y-孤立線との交点とはならないような標本点があるような曲面に対しては、
 `splot` の等高線はそのような標本点を無視することになります。以下を試して
 みて下さい:
        set xrange [-pi/2:pi/2]; set yrange [-pi/2:pi/2]
        set style function lp
        set contour
        set isosamples 10,10; set samples 10,10;
        splot cos(x)*cos(y)
        set samples 4,10; replot
        set samples 10,4; replot

?commands splot surfaces
?splot surfaces
 `splot` は点の集まりとして、あるいは、それらの点を結ぶことによって曲面
 を表示することができます。`plot` と同様に、点はデータファイルから読む
 こともできますし、指定された区間で関数の値を評価して得ることもできます。
 以下参照: `set isosamples`。曲面は、各点を線分で結ぶことで近似的に作ら
 れます。以下参照: `set surface`。そしてその場合曲面は、`set hidden3d`
 で不透明にもできます。3 次元曲面を眺める向きは、`set view` で変更でき
 ます。

 さらに、格子状のデータ点に対しては、`splot` は同じ高さを持つ点を補間す
 ることができ (以下参照: `set contour`)、そしてそれらを結んで等高線を描
 くことができます。さらに、その結び方には真直な線分や滑らかな線を使うこ
 とができます (以下参照: `set cntrparam`)。関数は、常に `set isosamples`
 と `set samples` で決定される格子状データとして評価されます。一方、フ
 ァイルのデータは、`data-file` に書かれているような格子状データフォーマ
 ットにするか、あるいは格子データを生成する (以下参照: `set dgrid3d`)
 ということをしなければそうはなりません。

 等高線は曲面の上に表示することもできますし、底面に射影することもできま
 す。底面への射影は、ファイルに書き出すこともでき、そしてそれを `plot`
 で再び読み込んで `plot` のより強い整形能力を生かすこともできます。
?commands stats
?stats
?statistics
 書式:
      stats {<ranges>} 'filename' {matrix | using N{:M}} {name 'prefix'}
            {{no}output}

 このコマンドは、ファイルの 1 列、または 2 列のデータの簡単な統計情報を
 提供します。using 指定子は、plot コマンドと同じ形で解釈されますが、
 `index`, `every`, `using` 指定に関する詳細については以下参照: `plot`。
 データ点は、その解析の前に xrange, yrange に従ってフィルタにかけられま
 す。以下参照: `set xrange`。その情報はデフォルトではスクリーンに出力さ
 れますが、コマンド `set print` を先に使うことで出力をファイルにリダイ
 レクトしたり、オプション `nooutput` を使うことで出力しないようにするこ
 ともできます。

 画面出力に加え、gnuplot は個々の統計情報を 3 つの変数グループに保存し
 ます。
 1 番目の変数グループは、どんなデータが並んでいるかを示します:
      STATS_records           # 範囲内のデータ行の総数 (N)
      STATS_outofrange        # 範囲外として除かれた行数
      STATS_invalid           # 無効/不完全/欠損データ行の総数
      STATS_blank             # 空行の総数
      STATS_blocks            # ファイル内のデータの index ブロック数
      STATS_columns           # データ先頭行の列数

 2 番目の変数グループは、1 つの列の、範囲内のデータの性質を示します。こ
 の列は y の値として扱われます。y 軸が自動縮尺の場合は、対象とする範囲
 に限界はありませんが、そうでなければ範囲 [ymin:ymax] 内の値のみを対象
 とします。

 2 つの列を同時に 1 回の `stats` コマンドで解析する場合は、各変数名に
 "_x", "_y" という接尾辞を追加します。例えば STATS_min_x は、1 つ目の列
 のデータの最小値で、STATS_min_y は 2 つ目の列のデータの最小値を意味し
 ます。この場合、点は xrange と yrange の両方で検査することでふるいにか
 けます。

      STATS_min               # 範囲内のデータ点の最小値
      STATS_max               # 範囲内のデータ点の最大値
      STATS_index_min         # data[i] == STATS_min となる添字 i
      STATS_index_max         # data[i] == STATS_max となる添字 i
      STATS_lo_quartile       # 第一 (下の) 四分位境界値
      STATS_median            # メジアン値 (第二四分位境界値)
      STATS_up_quartile       # 第三 (上の) 四分位境界値
      STATS_mean              # 範囲内のデータ点の平均値
      STATS_ssd               # 範囲内のデータ点の不偏標準偏差
                                   = sqrt( Sum[(y-ymean)^2] / (N-1) )
      STATS_stddev            # 範囲内のデータ点の標本標準偏差
                                   = sqrt( Sum[(y-ymean)^2] / N )
      STATS_sum               # 和
      STATS_sumsq             # 平方和
      STATS_skewness          # 範囲内のデータ点の歪度
      STATS_kurtosis          # 範囲内のデータ点の尖度
      STATS_adev              # 範囲内のデータ点の平均絶対偏差
      STATS_mean_err          # 平均値の標準誤差
      STATS_stddev_err        # 標準偏差の標準誤差
      STATS_skewness_err      # 歪度の標準誤差
      STATS_kurtosis_err      # 尖度の標準誤差

 3 番目の変数グループは、2 つの列のデータの解析専用です。
      STATS_correlation       # x と y の不偏相関係数
      STATS_slope             # 回帰直線 y = Ax + B の係数 A
      STATS_slope_err         # A の不確かさ
      STATS_intercept         # 回帰直線 y = Ax + B の係数 B
      STATS_intercept_err     # B の不確かさ
      STATS_sumxy             # 積和 (x*y の和)
      STATS_pos_min_y         # y の最小値を与える x 座標
      STATS_pos_max_y         # y の最大値を与える x 座標

 `matrix` が指定されると、全ての行列要素がその解析の対象になります。そ
 の行列のサイズは、変数 STATS_size_x と STATS_size_y に保存されます。

 2 つ以上のファイルやデータ列からの統計情報を並列に扱うことができれば便
 利ですので、変数のデフォルトの接頭辞である "STATS" を、オプション
 `name` でユーザが指定する文字列に置き換えることができるようになってい
 ます。例えば、異なる 2 つのファイルのそれぞれの 2 列目のデータの平均値
 は以下のようにして比較できます:
      stats "file1.dat" using 2 name "A"
      stats "file2.dat" using 2 name "B"
      if (A_mean < B_mean) {...}
 キーワード `columnheader` や関数 `columnheader(N)` により、データファ
 イルの 1 行目から取得した内容により接頭辞を生成することもできます:
      do for [COL=5:8] { stats 'datafile' using COL name columnheader }

 STATS_index_xxx で示される添字の値は、plot コマンドの第 0 疑似列 ($0)
 の値に対応し、最初の点は添字は 0、最後の点の添字は N-1 となります。

 メジアンと四分位境界値を探す際はデータの値をソートし、点の総数 N が奇
 数の場合は、その (N+1)/2 番目の値をメジアン値とし、N が偶数の場合は、
 N/2 番目と (N+2)/2 番目の値の平均値をメジアン値とします。四分位境界値
 も同様に処理します。

 その後の描画に注釈をつけるためにコマンド `stats` を利用した例について
 は、以下を参照してください。
 stats.dem。

 現在のバージョンの gnuplot の `stats` コマンドでは、日時フィールド
 (`set xdata time` や `set ydata time`) がない場合は対数軸のデータも処
 理できます。この制限は、将来のバージョンで緩和されるでしょう。

?commands system
?system
 書式:
       system "command string"
       ! command string
       output = system("command string")
       show variable GPVAL_SYSTEM

 `system "command"` は、オペレーティングシステムのデフォルトシェルを呼
 び出し、そのサブプロセスとして "command" を実行します。関数として
 `system("command")` を呼び出した場合は、そのサブプロセスの標準出力から
 の文字ストリームを文字列として返します。最後に改行がついている場合は、
 それは結果文字列からは除去されます。以下も参照: `backquotes`。

 そのサブプロセスの終了コードは、変数 GPVAL_SYSTEM_ERRNO と
 GPVAL_SYSTEM_ERRMSG に保存されます。しかし、もしコマンド文字列が 2 つ
 以上のプログラムを呼び出している場合は、そのうちの一つのプログラムがエ
 ラーを出しても、"成功" を返す可能性があることに注意してください。例え
 ば、file = system("ls -1 *.plt | tail -1") は、*.plt ファイルが一つも
 ない場合でも "成功" が返ります。それは、`ls` が失敗しても `tail` は成
 功するからです。

 システムコマンドは、以下に示すように外部関数を gnuplot に取り入れるの
 に利用できますが、これはその関数を呼び出す度に別のサブプロセスを強制的
 に生成することになります。よって、たくさん呼び出す可能性のある関数は、
 動的ライブラリからサブルーチンとして直接呼び出す形で取り入れる方がいい
 でしょう。以下参照: `import`, `plugin.dem`。

       f(x) = real(system(sprintf("somecommand %f", x)))
?commands test
?test palette
?test
 このコマンドは、出力形式やパレットでどのような出力が行なえるかを画像で
 テストし表示します。

 書式:
       test {terminal | palette}

 `test` または `test terminal` は、現在使用中の出力形式 (`terminal`) で
 使える線の種類、点の種類、または利用可能なその他の描画を生成します。

 `test palette` は、R(z),G(z),B(z) (0<=z<=1) の状態を描画します。これら
 は現在のカラーパレット (`palette`) の RGB 成分を示します。また、RGB を
 灰色階調に写像する NTSC 係数を用いて計算された視光度も描画します。この
 対応関係は、$PALETTE という名前のデータブロックにも取り込まれます。
?commands toggle
?toggle
 書式:
       toggle {<plotno> | "plottitle" | all}

 このコマンドは、対話型出力形式 (qt, wxt, x11) で表示されているグラフの
 key エントリ上で左クリックしたのと同じ効果を与えます。すなわち、そのグ
 ラフが表示されていればそれを消し、グラフが消えていれば再び表示します。
 `toggle all` は、ホットキー "i" と同様、有効なグラフすべてに作用します。
 `toggle "title"` の形式は、グラフのタイトルと完全に一致するタイトルを
 指定する必要がありますが、`toggle "ti*"` の場合は、グラフのタイトルと
 '*' の前の部分が一致する最初のグラフに作用します。現在の出力形式が対話
 型でない場合は、コマンド toggle は何もしません。
?commands undefine
?undefine
 1 つ、または複数の定義済みのユーザ変数を削除します。これは、初期化テス
 トを含むようなスクリプトの状態をリセットするのに便利でしょう。

 変数名には、最後の文字としてワイルドカード文字 `*` を使うことができま
 す。ワイルドカード文字が見つかると、それより前の部分で始まるすべての変
 数を削除します。これは、共通の接頭語を使っている複数の変数を削除するの
 に便利でしょう。ただし、ワイルドカード文字は変数名の最後にしか使えない
 ことに注意してください。`undefine` にワイルドカード文字のみを引数とし
 て与えた場合は何もしません。

 例:

       undefine foo foo1 foo2
       if (!exists("foo")) load "initialize.gp"

       bar = 1; bar1 = 2; bar2 = 3
       undefine bar*                 # 3 つの変数を全部削除

?commands unset
?unset
 コマンド `set` で設定したオプションは、それに対応した `unset` コマンド
 によってそのデフォルトの値に戻すことが可能です。`unset` コマンドには繰
 り返し節も利用できます。以下参照: `plot for`。

 例:
       set xtics mirror rotate by -45 0,10,100
       ...
       unset xtics

       # 番号 100 から 200 までのラベルを unset
       unset for [i=100:200] label i
?unset linetype
 書式:
       unset linetype N
 以前に単一の線種に割り当てたすべての特性を削除します。この後にこの線種
 を使用した場合、特性、色は現在の出力形式にデフォルトで設定されているも
 のを使用します (すなわち gnuplot 4.6 より前のバージョンで有効だった、
 いわゆるデフォルトの線種)。
?unset monochrome
 現在有効な白黒の線種をカラーの線種に切り替えます。`set color` と同等で
 す。
?unset output
 複数のグラフを一つの出力ファイルに書き出すことができる出力形式もあるの
 で、描画の後で出力ファイルを自動的には閉じません。よってそのファイルを
 安全に印刷等をするためには、まず明示的に `unset out` や `set output`
 とすることで前のファイルを閉じた上で新しいファイルを開いてください。
?unset terminal
 プログラムの最初に有効になるデフォルトの出力形式は、個々のシステム環境、
 gnuplot のコンパイルオプション、および環境変数 GNUTERM に依存します。
 そのデフォルトが何であっても、gnuplot はそれを内部変数 GNUTERM に保存
 しています。コマンド `unset terminal` は、その初期初期出力形式に復帰し、
 これは、`set terminal GNUTERM` とすることと同じです。しかし、GNUTERM
 が出力形式名の後に terminal オプションも含んでいる場合は、その代わりに
 `set terminal @GNUTERM` とする必要があります。
?commands update
?update
 注意: このコマンドは「非推奨」です。代わりに `save fit` を使用してくだ
 さい。

 コマンド `update` は、バージョン 5.2 では後方互換性のために残してあり
 ますが、将来は削除する予定です。

 書式:
       update <filename> {<filename>}

 このコマンドは、与えられたファイルに保存されている変数を現在の値に更新
 しますが、これらは初期値のファイルと同じ書式でなければいけません。以下
 参照: `fit`。

 そのファイルが存在しない場合、現在定義されているすべてのユーザ変数を含
 む新しいファイルを作成しますが、最後の fit 内で使用しなかった変数には
 すべて "#FIXED" と印をつけています。これは、fit 変数の現在の値を後で使
 うために、あるいは終了/中断した当てはめを再実行するために保存しておく
 のに有用です。

 2 番目のファイル名を指定すると、元のパラメータファイルは変更せずに 2
 番目のファイルの方に更新された値を書き出します。

 そうでなければ、指定したファイルが存在すれば `gnuplot` はそのファイル
 名に `.old` をつけてファイル名を変更し、指定したファイル名のファイルを
 新たに開き直します。つまり、"`update 'fred'`" とすると、それは
 "`!rename fred fred.old; update 'fred.old' 'fred'`" としたことと同じこ
 とになります。
?while
?commands while
 書式:
       while (<expr>) {
           <commands>
       }
 これは、コマンドのブロックを、<expr> が 0 でない値と評価される間、繰り
 返し実行します。このコマンドは、古い形式 (かっこなし) の if/else 構文
 と一緒に使うことはできません。以下も参照: `do`, `continue`, `break`。
?complete list of terminals
?terminal
?term
 gnuplot はとても多くの出力形式をサポートしています。これらは、適切な
 出力形式を、必要なら機能を変更する追加オプションをつけて選択すること
 により設定されます。以下参照: `set terminal`。

 この文書は、あなたのシステム上で初期設定およびインストールがなされなか
 ったために利用できない出力形式についても記述されているかも知れません。
 インストールされた個々の gnuplot で、どの出力形式が有効なのかの一覧を
 見るには、オプションを何もつけずに 'set terminal' と打ってください。

 (訳注: この日本語訳に含まれる terminal のマニュアルは、その一覧にはな
 い出力形式のものも含まれているかもしれませんし、逆にその一覧内の出力形
 式でマニュアルがないものもあるかもしれません。)

 `legacy` と印のついた出力形式は、最近のバージョンの gnuplot ではデフォ
 ルトではビルドされず、実際には使用できないかもしれません。

?commands set terminal aifm
?set terminal aifm
?set term aifm
?terminal aifm
?term aifm
?aifm

 `注意: 古い (legacy) 出力形式`、元々は Adobe Illustrator 3.0+ 用。Adobe
 Illustrator はレベル 1 の PostScriptファイルを直接認識するので、これの
 代わりに `set terminal post level1` 使うべきでしょう。

 書式:
       set terminal aifm {color|monochrome} {"<fontname>"} {<fontsize>}

?commands set terminal aqua
?set terminal aqua
?set term aqua
?terminal aqua
?term aqua
?aqua
?Aqua
 この出力形式は Mac OS X 上の表示に関する AquaTerm.app に依存しています。

 書式:
       set terminal aqua {<n>} {title "<wintitle>"} {size <x> <y>}
                         {font "<fontname>{,<fontsize>}"}
                         {linewidth <lw>}"}
                         {{no}enhanced} {solid|dashed} {dl <dashlength>}}

 <n> は描画するウィンドウの番号 (デフォルトでは 0)
 <wintitle> はタイトルバーに表示される名前 (デフォルトは "Figure <n>"),
 <x> <y> は描画サイズ (デフォルトは 846x594 pt = 11.75x8.25 インチ) です。

 使用するフォントは <fontname> で指定し (デフォルトは "Times-Roman")、
 フォントサイズは <fontsize> で指定します (デフォルトは 14.0 pt)。

 aqua 出力形式は、拡張文字列処理モード (enhanced text mode; 以下参照:
 `enhanced`) を、重ね書き以外はサポートしてます。フォントの使用はシステ
 ムで有効なフォントに制限されています。文字エンコーディングは、
 `set encoding` で選択できますが、現在は iso_latin_1, iso_latin_2,
 cp1250 と UTF8 (default) をサポートしています。

 曲線は、実線か点線 (デフォルトは実線) のいずれかで描画でき、点線の間隔は
 倍率 <dashlength> (>0) で変更できます。

?commands set terminal be
?set terminal be
?set term be
?terminal be
?term be
?be
?BE
 出力形式 `be` は、X サーバを利用する`beos` オペレーティングシステム上
 で gnuplot をコンパイルする人のためのものです。環境変数 `DISPLAY` がセ
 ットされているか、環境変数 `TERM` が `xterm` にセットされているか、ま
 たはコマンドラインオプションとして `-display` が使われていれば、プログ
 ラムの起動時にこの出力形式が選択されます。

 書式:
           set terminal be {reset} {<n>}

 複数のグラフ描画ウィンドウをサポートしています。`set terminal be <n>`
 は番号 n のウィンドウに出力します。n>0 の場合、その番号はウィンドウタ
 イトルとアイコン名に `gplt <n>` として付けられます。現在のウィンドウは
 カーソル記号の変化で区別できます (デフォルトカーソルから十字カーソルへ)。

 `gnuplot` ドライバが別な出力ドライバに変更されても、描画ウィンドウは開
 いたままになります。描画ウィンドウは、そのウィンドウにカーソルを置いて
 文字 q を押すか、ウィンドウマネージャのメニューの `close` を選択すれば
 閉じることができます。`reset` を実行すれば全てのウィンドウを一度に閉じ
 れます。それは実際にウィンドウを管理している子プロセスを終了します (も
 し `-persist` が指定されていなければ)。

 描画ウィンドウは `-persisit` オプションが与えられていなければ、対話の
 終了時に自動的に閉じられます。

 描画サイズとアスペクト比は、`gnuplot` のウィンドウをリサイズすることで
 も変更できます。

 線の幅と点のサイズは `gnuplot` の `set linestyle` で変更可能です。

 出力ドライバ `be` に関しては、`gnuplot` は (起動時に)、コマンドライン、
 または設定ファイルから、geometry や font, name などの通常の X Toolkit
 オプションやリソースの指定を受け付けます。それらのオプションについては
 X(1) マニュアルページ (やそれと同等のもの) を参照してください。

 他にも `be` 出力形式用の多くの `gnuplot` のオプションがあります。これ
 らは `gnuplot` を呼ぶときにコマンドラインオプションとして指定するか、
 または設定ファイル ".Xdefaults" のリソースとして指定できます。これらは
 起動時に設定されるので、`gnuplot` 実行時には変更できません。
?commands set terminal be command-line-options
?set terminal be command-line-options
?set term be command-line-options
?be command-line-options
 X Toolkit オプションに加え、以下のオプションが gnuplot の立ち上げ時の
 コマンドラインで、またはユーザのファイル ".Xdefaults" 内のリソースとし
 て指定できます:
  `-mono`    カラーディスプレイ上で強制的に白黒描画
  `-gray`    グレイスケールまたはカラーディスプレイ上でのグレイスケール描画
             (デフォルトではグレイスケールディスプレイは白黒描画を受け付ける)
  `-clear`   新しい描画を表示する前に (瞬間的に) 画面を消去
  `-raise`   各描画後に描画ウィンドウを最前面へ出す
  `-noraise` 各描画後に描画ウィンドウを最前面へ出すことはしない
  `-persist` gnuplot プログラム終了後も描画ウィンドウを残す
 上記のオプション、はコマンドライン上での指定書式で、".Xdefaults" にリ
 ソースとして指定するときは異なる書式を使います。

 例:
           gnuplot*gray: on

 `gnuplot` は描画スタイル `points` で描画する点のサイズの制御にも、コマンド
 ラインオプション (`-pointsize <v>`) とリソース (`gnuplot*pointsize: <v>`)
 を提供しています。値 `v` は点のサイズの拡大率として使われる実数値
 (0 < v <= 10) で、例えば `-pointsize 2` はデフォルトのサイズの 2 倍、
 `-pointsize 0.5` は普通のサイズの半分の点が使われます。
?commands set terminal be monochrome_options
?set terminal be monochrome_options
?set term be monochrome_options
?be monochrome_options
 白黒ディスプレイに対しては `gnuplot` は描画色 (foreground) も背景色
 (background) も与えません。デフォルトでは背景は白、描画は黒です。`-rv`
 や `gnuplot*reverseVideo: on` の場合には背景が黒で描画は白になります。

?commands set terminal be color_resources
?set terminal be color_resources
?set term be color_resources
?be color_resources
 カラーディスプレイに対しては、`gnuplot` は以下のリソース (ここではその
 デフォルトの値を示します)、または白黒階調 (greyscale) のリソースを参照
 します。リソースの値はシステム上の BE rgb.txt ファイルに書かれている色
 名、または 16 進の色指定 (BE のマニュアルを参照) か、色名と強度 (0 か
 ら 1 の間の値) をコンマで区切った値を使用できます。例えば `blue, 0.5`
 は半分の強度の青、を意味します。
  gnuplot*background:  white
  gnuplot*textColor:   black
  gnuplot*borderColor: black
  gnuplot*axisColor:   black
  gnuplot*line1Color:  red
  gnuplot*line2Color:  green
  gnuplot*line3Color:  blue
  gnuplot*line4Color:  magenta
  gnuplot*line5Color:  cyan
  gnuplot*line6Color:  sienna
  gnuplot*line7Color:  orange
  gnuplot*line8Color:  coral

 これらに関するコマンドラインの書式は、例えば以下の通りです。

 例:
           gnuplot -background coral

?commands set terminal be grayscale_resources
?set terminal be grayscale_resources
?set term be grayscale_resources
?be grayscale_resources
 `-gray` を選択すると、`gnuplot` は、グレイスケールまたはカラーディスプ
 レイに対して、以下のリソースを参照します (ここではそのデフォルトの値を
 示します)。デフォルトの背景色は黒であることに注意してください。
  gnuplot*background: black
  gnuplot*textGray:   white
  gnuplot*borderGray: gray50
  gnuplot*axisGray:   gray50
  gnuplot*line1Gray:  gray100
  gnuplot*line2Gray:  gray60
  gnuplot*line3Gray:  gray80
  gnuplot*line4Gray:  gray40
  gnuplot*line5Gray:  gray90
  gnuplot*line6Gray:  gray50
  gnuplot*line7Gray:  gray70
  gnuplot*line8Gray:  gray30

?commands set terminal be line_resources
?set terminal be line_resources
?set term be line_resources
?be line_resources
 `gnuplot` は描画の線の幅 (ピクセル単位) の設定のために以下のリソースを
 参照します (ここではそのデフォルトの値を示します)。0 または 1 は最小の
 線幅の 1 ピクセル幅を意味します。2 または 3 の値によってグラフの外観を
 改善できる場合もあるでしょう。
  gnuplot*borderWidth: 2
  gnuplot*axisWidth:   0
  gnuplot*line1Width:  0
  gnuplot*line2Width:  0
  gnuplot*line3Width:  0
  gnuplot*line4Width:  0
  gnuplot*line5Width:  0
  gnuplot*line6Width:  0
  gnuplot*line7Width:  0
  gnuplot*line8Width:  0

 `gnuplot` は線描画で使用する点線の形式の設定用に以下のリソースを参照し
 ます。0 は実線を意味します。2 桁の 10 進数 `jk` (`j` と `k` は 1 から
 9 までの値) は、`j` 個のピクセルの描画に `k` 個の空白のピクセルが続く
 パターンの繰り返しからなる点線を意味します。例えば '16' は 1 個のピク
 セルの後に 6 つの空白が続くパターンの点線になります。さらに、4 桁の 10
 進数でより詳細なピクセルと空白の列のパターンを指定できます。例えば、
 '4441' は 4 つのピクセル、4 つの空白、4 つのピクセル、1 つの空白のパタ
 ーンを意味します。以下のデフォルトのリソース値は、白黒ディスプレイ、あ
 るいはカラーや白黒階調 (grayscale) ディスプレイ上の白黒描画における値
 です。カラーディスプレイではそれらのデフォルトの値はほとんど 0 (実線)
 で、`axisDashes` のみがデフォルトで '16' の点線となっています。
  gnuplot*borderDashes:   0
  gnuplot*axisDashes:        16
  gnuplot*line1Dashes:        0
  gnuplot*line2Dashes:   42
  gnuplot*line3Dashes:   13
  gnuplot*line4Dashes:   44
  gnuplot*line5Dashes:   15
  gnuplot*line6Dashes: 4441
  gnuplot*line7Dashes:   42
  gnuplot*line8Dashes:   13
?commands set terminal caca
?set terminal caca
?set term caca
?terminal caca
?term caca
?caca
 [試験段階]
 `caca` 出力形式は、`libcaca` を使ってアスキー文字によるグラフを描く、ほ
 ぼ娯楽的な出力モードです。`dumb` 出力形式と比べると、こちらは色、箱の塗
 り潰し、画像、文字列の回転、多角形の塗り潰し、マウス操作をサポートして
 います。

 書式:
       set terminal caca {{driver | format} {default | <driver> | list}}
                         {color | monochrome}
                         {{no}inverted}
                         {enhanced | noenhanced}
                         {background <rgb color>}
                         {title "<plot window title>"}
                         {size <width>,<height>}
                         {charset ascii|blocks|unicode}

 オプション `driver` (または `format`) は、表示ドライバとして `libcaca`
 を選択するか、または出力ドライバを選択します。
 `default` は、`libcaca` にその環境のデフォルトのディスプレイドライバを
 選択させます。デフォルトのドライバは、`gnuplot` の起動前に環境変数
 CACA_DRIVER を設定しておくことで変更できます。
 `set term caca driver list` を使用すると、サポートする出力モードの一覧
 を表示します。

 オプション `color` と `monochrome` は、カラーか白黒出力を選択します。
 これは、線の記号も変更することに注意してください。
 デフォルトの白背景を黒背景にしたい場合は、オプション `inverted` を使っ
 てください。これは、デフォルトの線種の黒を白にも変えます。

 拡張文字列処理は、オプション `enhanced` を使うことで有効になります。以
 下参照 `enhanced text`。

 出力ウィンドウのタイトルは、`libcaca` ドライバがサポートしていれば、オ
 プション `title` で変更できます。

 オプション `size` は、キャンバスのサイズを文字単位で選択します。デフォ
 ルトは 80 x 25 です。バックエンドがサポートしていれば、キャンバスサイズ
 は、現在のウィンドウ/ターミナルのサイズに自動的に合います。"x11" と
 "gl" ウィンドウのデフォルトのサイズは、環境変数 CACA_GEOMETRY で制御
 できます。"win32" ドライバでのウィンドウの位置・サイズ情報は、アプリ
 ケーションメニューで制御、及び恒常的な変更が行えます。

 オプション `charset` は、曲線、点、多角形や長方形の塗り潰し、画像の中間
 色表現などで使われる文字集合を選択します。バックエンドとターミナルとフ
 ォントの組み合わせによっては、`blocks` か `unicode` の文字集合はサポー
 トしない可能性もあることに注意してください。特に Windows では、
 "Lucida Console" や "Consolas" のような非ラスタフォントの使用を勧め
 ます。

 caca 出力形式は、マウス操作をサポートしています。`libcaca` のいくつかの
 バックエンド (例えば slang や ncurses) はマウスクリックしたマウスの位置
 しか更新しないことに注意してください。修飾キー (Ctrl, Alt, Shift) は、
 `libcaca` ではサポートしていないので、利用できません。

 `caca` 出力形式のデフォルトの `encoding` は utf8 です。cp437 `encoding`
 もサポートしています。

 `libcaca` のサポートする色の数は、バックエンドにより異なります。たいて
 いのバックエンドは、16 色の前景色と 16 色の背景色のみをサポートしていま
 すが、例えば "x11" バックエンドは、Truecolor をサポートしています。

 出力形式と `libcaca` バックエンドによっては、背景色 8 色しかサポートさ
 ない場合もあります。明色 (背景色の中で最も重要) は、文字を輝かせている
 と解釈されます。この場合、`background rgb "gray"` を使用してみてくだ
 さい。

 以下の libcaca Web サイト
           http://caca.zoy.org/wiki/libcaca
 および libcaca 環境変数に関する説明
           http://caca.zoy.org/doxygen/libcaca/libcaca-env.html
 も参照してみてください。
?terminal caca limitations
?terminal caca bugs
?term caca limitations
?term caca bugs
?caca limitations
?caca bugs
 `caca` 出力形式には、既知のバグと制限があります:

 Unicode のサポートは、ドライバと出力形式依存です。
 "x11" バックエンドは libcaca version 0.99.beta17 から unicode をサポ
 ートしていますが、`libcaca` < 0.99.beta20 でのバグのため、"slang" ド
 ライバは unicode をサポートしていません。
 `libcaca` < 0.99.beta19 には、不正な 8 ビット列を与えると無限ループを引
 き起こすというバグがあることに注意してください。

 明るい背景色は点滅することがあります。

 マウス操作では修飾キーはサポートしません。以下参照: `term caca`

 拡張文字列の回転、および透明化はサポートしていません。`size` オプション
 は、オンスクリーンディスプレイでは考慮されません。

 凡例 (key) の箱を正しく描くには、以下のようにしてください:

       set key width 1 height 1

 拡張文字列の位置合わせは、UTF-8 文字列が含まれている場合はうまくいきま
 せん。
 Windows のコンソールウィンドウのリサイズは、libcaca のバグのため正しく
 機能しません。
 タイトル行の上で "X" をクリックしてターミナルウィンドウを閉じる機能は
 wgnuplot を終了させてしまいますので、ウィンドウを閉じるには "q" を打
 ってください。
?set terminal cairolatex
?terminal cairolatex
?set term cairolatex
?term cairolatex
?cairolatex
 出力形式 `cairolatex` は、cairo と pango の補助ライブラリを使って、EPS
 (Encapsulated PostScript) か PDF 出力を生成しますが、文字列出力には、出
 力形式 `epslatex` と同じやり方で LaTeX を使用します。

 書式:
       set terminal cairolatex
                      {eps | pdf}
                      {standalone | input}
                      {blacktext | colortext | colourtext}
                      {header <header> | noheader}
                      {mono|color}
                      {{no}transparent} {{no}crop} {background <rgbcolor>}
                      {font <font>} {fontscale <scale>}
                      {linewidth <lw>} {rounded|butt|square} {dashlength <dl>}
                      {size <XX>{unit},<YY>{unit}}

 cairolatex 出力形式は、epscairo 出力形式 (`termnal epscairo`) や
 pdfcairo 出力形式 (`terminal pdfcairo`) と同等のグラフを出力しますが、
 テキスト文字列はグラフの中に入れるのではなく、LaTeX に渡します。以下で
 触れないオプションについては、以下参照: `pdfcairo`。

 `eps` と `pdf` は、グラフ出力の形式を選択します。latex/dvips 用には
 `eps` を、pdflatex 用には `pdf` を使用してください。

 `blacktext` は、カラーモードでもすべての文字列を黒で書くようにします。

 `cairolatex` 出力ドライバは、文字列の位置の特別な制御方法を提供します:
 (a) '{' で始まるすべての文字列は、'}' もその文字列の最後に必要ですが、
 その文字列全体を LaTeX で横にも縦にもセンタリングします。
 (b) '[' で始まる文字列は、その次に位置指定文字 (t,b,l,r,c のうち 2 つま
 で)、']{'、対象文字列、と続き最後に '}' で閉じますが、この文字列は、
 LaTeX が LR-box として処理できるものならなんでも構いません。位置合わせ
 を完全に行うには、\rule{}{} も有用でしょう。以下も参照: `pslatex`。
 複数行に渡るラベルを生成する場合、\shortstack を使用してください。例:
    set ylabel '[r]{\shortstack{first line \\ second line}}'

 コマンド `set label` のオプション `back` は、他の出力形式とはやや異なる
 方法で処理します。`back` を使用したラベルは、他のすべての描画要素の後ろ
 に印字し、`front` を使用したラベルは、他のすべての上に印字します。

 このドライバは 2 つの異なるファイルを作成します。一つは図の eps かまた
 は pdf 部分で、もう一つは LaTeX 部分です。その LaTeX ファイルの名前は、
 コマンド `set output` のものを使用し、eps/pdf ファイルの名前は、その拡
 張子 (通常は '.tex') を '.eps' か '.pdf' に置き換えたものを使用します。
 出力ファイルを指定しなかった場合は、LaTeX 出力はしません。`multiplot`
 モード以外では、次の plot を行う前に出力ファイルを閉じるのを忘れないで
 ください。

 この画像をあなたの LaTeX 文書に取り込むには、'\input{filename}' を使用
 してください。'.eps' や '.pdf' ファイルは、\includegraphics{...} コマ
 ンドで取り込むので、LaTeX 文書のプリアンブルに \usepackage{graphicx}
 を入れる必要があります。色付きの文字 (オプション `colourtext`) を使用
 する場合は、プリアンブルに \usepackage{color} も入れる必要があります。

 フォント選択に関する挙動は、ヘッダーモードに依存します。いずれの場合で
 も、与えられたフォントサイズは適切な大きさを計算するのに使われます。
 `standalone` モードを使っていない場合は、それを読みこんだところで実際に
 LaTeX が使用しているフォントとフォントサイズが使われるので、フォントを
 変更するには LaTeX のコマンドを使用してください。LaTeX 文書の方で 12pt
 のフォントサイズを使っていれば、オプションとして '", 12"' を指定して
 ください。フォント名は無視されます。'standalone' の場合は、与えられたフ
 ォントとフォントサイズを使用します。詳細は以下を参照してください。

 文字列を色付けして印字するかどうかは、TeX のブール変数 \ifGPcolor と
 \ifGPblacktext で制御できます。\ifGPcolor が true で \ifGPblacktext
 が false のときのみ文字列が色付けされます。これらの変更は、生成された
 TeX ファイル中で行うか、または大域的にあなたの TeX ファイルのプリアンブ
 ルで、例えば以下のようにして設定できます:
    \newif\ifGPblacktext
    \GPblacktexttrue
 局所的な設定は、大域的な値がない場合にのみ効力を持ちます。

 出力形式 cairolatex を使う場合は、コマンド `set output` で TeX ファイル
 設定する際にファイルの拡張子 (通常は ",tex") をつけてください。
 グラフのファイル名は、その拡張子を置きかえることで作られます。

 `standalone` モードを使う場合、LaTeX ファイルに完全な LaTeX のヘッダが
 追加され、グラフファイルのファイル名には "-inc" が追加されます。
 `standalone` モードは、dvips, pdfTeX, VTeX を使う場合に正しいサイズの出
 力を作る TeX ファイルを生成します。デフォルトでは `input` で、これは
 LaTeX 文書から \input コマンドで取り込まれる必要があるファイルを生成し
 ます。

 "" や "default" 以外のフォントを与えた場合、それは LaTeX のフォント
 名であるとみなされます。それは ',' 区切りで最大 3 つの部分からなる、
 'fontname,fontseries,fontshape' の形式です。デフォルトの fontshape や
 fontseries を使いたい場合は、それらは省略できます。よって、フォント名の
 実際の書式は、'{fontname}{,fontseries}{,fontshape}' となります。(訳注:
 より gnuplot 風に言えば '{<fontname>}{,{<fontseries>}{,<fontshape>}}')
 名前の各部分の指定法は、LaTeX のフォント系の慣習に従う必要があります。
 フォント名 (fontname) は 3 から 4 文字の長さで、以下のようになっていま
 す: 最初の文字はフォントの供給者、次の 2 つの文字はフォント名用、オプシ
 ョンとして特別なフォント用に 1 文字追加できます。例えば、'j' は古いスタ
 イルの数字用のフォント、'x' はエキスパートフォント用です。多くのフォン
 ト名が以下に記述されています:
           http://www.tug.org/fontname/fontname.pdf
 例えば、'cmr' は Computer Modern Roman を、'ptm' は Times-Roman, 'phv'
 は Helvetica を意味しています。font series は、グリフの太さを表し、多く
 の場合は、'm' が標準 ("medium")、'bx' か 'b' が太字 (bold) のフォント
 を意味します。font shape は、一般的には 'n' が立体 (upright)、'it' がイ
 タリック (italic)、'sl' が斜体 (slanted)、'sc' がスモールキャピタル
 (small caps) を意味します。異なる series や shapes を提供するフォントも
 あります。

 例:

 Times-Roman のボールド体 (周りの文字列と同じ形状) を使うには:
       set terminal cairolatex font 'ptm,bx'
 Helvetica, ボールド体、イタリックを使うには:
       set terminal cairolatex font 'phv,bx,it'
 周りと同じで斜体の形状のフォントを使うには:
       set terminal cairolatex font ',,sl'
 スモールキャピタルを使うには
       set terminal cairolatex font ',,sc'

 この方法では、テキストフォントだけが変更されます。数式フォントも変更し
 たい場合は、ファイル "gnuplot.cfg" か、または以下で説明するオプション
 `header` を使う必要があります。

 `standalone` モードでは、フォントサイズはコマンド `set terminal` で指定
 したフォントサイズを取ります。指定したフォントサイズを使うためにはファ
 イル "size<size>.clo" が LaTeX の検索パスにある必要があります。デフォ
 ルトでは 10pt, 11pt, 12pt をサポートしています。パッケージ "extsizes"
 がインストールされていれば、8pt, 9pt, 14pt, 17pt, 20pt も追加されます。

 オプション `header` は一つの文字列を引数として取り、その文字列を生成す
 る LaTeX ファイルに書き出します。`standalone` モードでは、それはプリア
 ンブルの \begin{document} の直前に書きますが、`input` モードでは、それ
 はグラフに関するすべての設定を局所化するための \begingroup コマンドの
 の直後に書きます。

 例:

 T1 フォントエンコーディングを使い、テキストフォントと数式フォントを
 Times-Roman に、sans-serif フォントを Helvetica に変えるには:
     set terminal cairolatex standalone header \
     "\\usepackage[T1]{fontenc}\n\\usepackage{mathptmx}\n\\usepackage{helvet}"
 グラフ内では太字 (bold) を使うが、グラフ外のテキストはそうしない:
     set terminal cairolatex input header "\\bfseries"

 LaTeX がファイル "gnuplot.cfg" を見つけると、`standalone` モードでは
 それをプリアンブルに取り込みます。これは、さらに設定を追加するのに使え
 ます。例: 文書のフォントを、数式フォント ("mathptmx.sty" が処理) も合
 わせて Times-Roman, Helvetica, Courier にするには:
       \usepackage{mathptmx}
       \usepackage[scaled=0.92]{helvet}
       \usepackage{courier}
 ファイル "gnuplot.cfg" は、コマンド `header` で設定するヘッダー情報よ
 りも前に読み込みますので、"gnuplot.cfg" で設定するものを `header` を
 使って上書きすることができます。

?commands set terminal canvas
?set terminal canvas
?set term canvas
?terminal canvas
?term canvas

 出力形式 `canvas` は、HTML5 の canvas 要素上に描画する javascript コマ
 ンドの集合を生成します。
 書式:
       set terminal canvas {size <xsize>, <ysize>} {background <rgb_color>}
                           {font {<fontname>}{,<fontsize>}} | {fsize <fontsize>}
                           {{no}enhanced} {linewidth <lw>}
                           {rounded | butt | square}
                           {dashlength <dl>}
                           {standalone {mousing} | name '<funcname>'}
                           {jsdir 'URL/for/javascripts'}
                           {title '<some string>'}

 <xsize> と <ysize> は描画領域のピクセル単位でのサイズを設定します。
 standalone モードでのデフォルトのサイズは、600x400 ピクセルです。
 デフォルトのフォントサイズは 10 です。

 注: ファイル canvastext.js で提供している Hershey simplex Roman フォン
 トのアスキー部分のフォント一つだけが利用できます。これは、ファイル
 canvasmath.js で置き換えることもでき、そこには UTF-8 エンコードされた
 Hershey simplex Greek と math symbols も含まれています。他の出力形式に
 合わせて、`font "name,size"` の形式も使えるようになっています。今の
 ところ `name` のフォント名部分は無視されますが、そのうちにブラウザが名
 前付きフォントをサポートしだすでしょう。

 デフォルトの `standalone` モードは、HTML 5 の canvas 要素を使用してグ
 ラフを描画するような javascript コードを含む HTML ページを生成します。
 その HTML ページは、2 つの必要な javascript ファイル 'canvastext.js'、
 'gnuplot_common.js' にリンクします。点線をサポートするためにはさらに追
 加ファイル 'gnuplot_dashedlines.js' が必要です。デフォルトではそれらは
 ローカルファイルへのリンクで、Unix 互換のシステムでは通常はそれらディ
 レクトリ /usr/local/share/gnuplot/<version>/js にあります。他の環境に
 ついては、インストールに関する注意を参照してください。この設定は、オプ
 ション `jsdir` に別のローカルディレクトリ、あるいは一般的な URL を指定
 することで変更できます。グラフをリモートクライアントのマシンで見れるよ
 うにする場合は、通常は後者の設定が適切でしょう。

 canvas 出力形式で生成される描画はすべてマウス操作可能です。キーワード
 `mousing` を追加すると、`standalone` モードのグラフの下にマウストラッ
 キングボックスをつけます。これは、`canvastext.js` が置かれているのと同
 じローカルディレクトリ、または URL 内の、'gnuplot_mouse.js' という
 javascript ファイルへのリンクと 'gnuplot_mouse.css' というマウスボック
 スに関するスタイルシートも追加します。

 オプション `name` は、javascript のみを含むファイルを一つ生成します。
 それが含む javascript 関数と、それが描画する canvas 要素の id の両方は、
 以下の文字列パラメータから取られます。例えば以下のコマンド
       set term canvas name 'fishplot'
       set output 'fishplot.js'
 は、javascript 関数 fishplot() を含むファイルを生成し、その関数はグラ
 フを id=fishplot の canvas 上に描画します。この javascript 関数を呼び
 出す HTML ページは、上で説明した canvastext.js も読み込まなければいけ
 ません。上のように生成した、この fishplot を取りこむ最小の HTML ファイ
 ルは以下のようになります:

       <html>
       <head>
           <script src="canvastext.js"></script>
           <script src="gnuplot_common.js"></script>
       </head>
       <body onload="fishplot();">
           <script src="fishplot.js"></script>
           <canvas id="fishplot" width=600 height=400>
               <div id="err_msg">No support for HTML 5 canvas element</div>
           </canvas>
       </body>
       </html>

 このキャンバス上に描かれるそれぞれのグラフの名前は、fishplot_plot_1,
 fishplot_plot_2 等となります。外部の javascript ルーチンでそれらを参照
 することもできます。例: gnuplot.toggle_visibility("fishplot_plot_2")

?commands set terminal cgm
?set terminal cgm
?set term cgm
?terminal cgm
?term cgm
?cgm
 `cgm` ドライバは CGM 出力 (Computer Graphics Metafile Version 1) を生
 成します。このファイルフォーマットは ANSI 規格書 X3.122-1986 "Computer
 Graphics - Metafile for the Storage and Transfer of Picture Description
 Information" で定義されているものの一部分です。

 書式:
       set terminal cgm {color | monochrome} {solid | dashed} {{no}rotate}
                        {<mode>} {width <plot_width>} {linewidth <line_width>}
                        {font "<fontname>,<fontsize>"}
                        {background <rgb_color>}
   [deprecated]         {<color0> <color1> <color2> ...}

 `solid` は全ての曲線を実線で描き、どんな点線パターンも塗りつぶします;
 <mode> は `landscape`, `portrait`, `default` のいずれか;
 <plot_width> はポイント単位でのグラフの仮定されている幅;
 <line_width> はポイント単位での線幅 (デフォルトは 1);
 <fontname> はフォントの名前 (以下のフォント一覧参照); そして
 <fontsize> はポイント単位でのフォントのサイズ (デフォルトは 12) です。

 最初の 6 つのオプションはどの順番で指定しても構いません。`default` を
 選択すると、全てのオプションをそのデフォルトの値にします。

 線の色を `set term` コマンドで設定する仕組みは、今は非推奨です。代わり
 に、背景色は分離されたキーワード background で、線の色は `set linetype`
 で設定すべきでしょう。この非推奨の仕組みでは色は 'xrrggbb' の形式で受け
 つけますが、x は文字 'x' そのもの、'rrggbb' は 16 進数での赤、緑、青の
 成分です。最初の色を背景色として使い、その後に続く色指定を順次線の色と
 として割り当てていました。

 例:
       set terminal cgm landscape color rotate dashed width 432 \
                      linewidth 1  'Helvetica Bold' 12       # デフォルト
       set terminal cgm linewidth 2  14  # やや広い線とやや大きいフォント
       set terminal cgm portrait "Times Italic" 12
       set terminal cgm color solid    # 面倒な点線など消えてしまえ !
?commands set terminal cgm font
?set terminal cgm font
?set term cgm font
?cgm font
 CGM (Computer Graphics Metafile) ファイルの最初の部分、メタファイルの
 記述部分には、フォントリスト (font table) が含まれています。画像の本体
 部では、フォントはこのリストにある番号で指定されます。デフォルトではこ
 のドライバは以下の 35 個のフォントリストを生成し、さらにこのリストの
 `Helvetica`, `Times`, `Courier` の各フォントの `italic` を `oblique`
 で置き換えたもの、およびその逆による 6 つの追加のフォントが含まれます
 (Microsoft Office と Corel Draw CGM の import フィルタは `italic` と
 `oblique` を同じものとして扱うからです)。
       Helvetica
       Helvetica Bold
       Helvetica Oblique
       Helvetica Bold Oblique
       Times Roman
       Times Bold
       Times Italic
       Times Bold Italic
       Courier
       Courier Bold
       Courier Oblique
       Courier Bold Oblique
       Symbol
       Hershey/Cartographic_Roman
       Hershey/Cartographic_Greek
       Hershey/Simplex_Roman
       Hershey/Simplex_Greek
       Hershey/Simplex_Script
       Hershey/Complex_Roman
       Hershey/Complex_Greek
       Hershey/Complex_Script
       Hershey/Complex_Italic
       Hershey/Complex_Cyrillic
       Hershey/Duplex_Roman
       Hershey/Triplex_Roman
       Hershey/Triplex_Italic
       Hershey/Gothic_German
       Hershey/Gothic_English
       Hershey/Gothic_Italian
       Hershey/Symbol_Set_1
       Hershey/Symbol_Set_2
       Hershey/Symbol_Math
       ZapfDingbats
       Script
       15
 これらのフォントの最初の 13 個は WebCGM で要求されているものです。
 Microsoft Office の CGM import フィルタはその 13 個の標準フォントと
 'ZapfDingbats' と 'Script' をサポートしています。しかし、そのスクリプ
 ト (script) フォントは '15' という名前でしかアクセスできません。
 Microsoft の import フィルタの font の置き換えに関するより詳しい情報に
 ついては、
   C:\Program Files\Microsoft Office\Office\Cgmimp32.hlp
 のヘルプファイル、または
   C:\Program Files\Common Files\Microsoft Shared\Grphflt\Cgmimp32.cfg
 の設定ファイルなどをチェックしてください。

 `set term` コマンドでデフォルトのフォントリストにないフォント名を指定
 することも可能です。その場合、その指定したフォントが最初に現われる新
 しいフォントリストが作られます。そのフォント名に関して、スペル、単語
 の先頭の大文字化やどこにスペースが入るかなどが、作られる CGM ファイル
 を読むアプリケーションにとって適切なものであるかをちゃんと確認する必要
 があります。(gnuplot と任意の MIL-D-28003A 準拠アプリケーションは、フ
 ォント名の大文字小文字の違いは無視します。) 新しいフォントをいくつも追
 加したい場合は、`set term` コマンドを繰り返し使用してください。

 例:
       set terminal cgm 'Old English'
       set terminal cgm 'Tengwar'
       set terminal cgm 'Arabic'
       set output 'myfile.cgm'
       plot ...
       set output

 `set label` コマンドでは新しいフォントを導入することはできません。
?commands set terminal cgm fontsize
?set terminal cgm fontsize
?set term cgm fontsize
?cgm fontsize
 フォントは、ページが 6 インチの幅であると仮定して伸縮されます。`size`
 コマンドでページの縦横比が変更されていたり、CGM ファイルが異なる幅に変
 換されている場合、結果としてフォントのサイズも拡大されたり縮小されたり
 することになります。仮定されている幅を変更するには、`width` オプション
 を使用してください。
?commands set terminal cgm linewidth
?set terminal cgm linewidth
?set term cgm linewidth
?cgm linewidth
 `linewidth` オプションは線の幅をポイント単位 (pt) で設定します。デフォ
 ルトの幅は 1 pt です。`fontsize` や `width` オプションのところで説明さ
 れているように、ページの実際の幅によってその縮尺は影響を受けます。
?commands set terminal cgm rotate
?set terminal cgm rotate
?set term cgm rotate
?cgm rotate
 `norotate` オプションはテキストの回転をしないようにします。例えば Word
 for Windows 6.0c 用の CGM 入力フィルタは回転された文字列を受け付けます
 が、Word に付属する DRAW エディタはそれを受け付けることができず、グラ
 フを編集すると (例えば曲線に見出しをつける)、全ての回転された文字列は
 水平方向になって保存されてしまい、Y 軸の見出しはクリップされる境界線を
 越えてしまうでしょう。`norotate` オプションを使えば、見栄えの良くない
 場所から Y 軸の見出しが始まってしまいますが、編集によってダメージを受
 けることはなくなります。`rotate` オプションはデフォルトの挙動を保証し
 ます。
?set terminal cgm solid
?set term cgm solid
?cgm solid
 `solid` オプションは描画の点線の線描画スタイルを無効するのに使います。
 これは、カラーが有効である場合、また点線にすることでグラフが見にくくな
 る場合に有用でしょう。`dashed` オプションはデフォルトの挙動を保証し、
 この場合個々の線種に異なる点線のパターンが与えられます。
?commands set terminal cgm size
?set terminal cgm size
?set term cgm size
?cgm size
 CGM グラフのデフォルトのサイズは、横置き (landscape) では幅 32599, 縦
 23457、縦置き (portrait) では幅 23457, 縦 32599 です。
?commands set terminal cgm width
?set terminal cgm width
?set term cgm width
?cgm width
 CGM ファイルの全ての長さは抽象的な単位を持ち、そのファイルを読むアプリ
 ケーションが最終的なグラフのサイズを決定します。デフォルトでは最終的な
 グラフの幅は 6 インチ (15.24 cm) であると仮定されています。この幅は正
 しいフォントサイズを計算するのに使われ、`width` オプションで変更できま
 す。キーワード `width` の後に幅をポイント単位で指定します。(ここで、ポ
 イントは PostScript と同様 1/72 インチを意味します。この単位は TeX では
 "big point" と呼ばれています。) 他の単位から変換するには、gnuplot の数
 式が使えます。

 例:
       set terminal cgm width 432            # デフォルト
       set terminal cgm width 6*72           # 上と同じ値
       set terminal cgm width 10/2.54*72     # 10 cm の幅
?commands set terminal cgm nofontlist
?set terminal cgm nofontlist
?set term cgm nofontlist
?cgm nofontlist
?set terminal cgm winword6
?set term cgm winword6
?cgm winword6
 デフォルトのフォントリスト (font table) は WebCGM で勧告されているフォ
 ントを含んでいて、これは Microsoft Office と Corel Draw の CGM (Computer
 Graphics Metafile) 入力フィルタに適合しています。他のアプリケーション
 は異なるフォント、あるいは異なるフォント名を使用するかも知れませんが、
 それはマニュアルには書かれていないかも知れません。オプション
 `nofontlist` (`winword6` も同じ意味) を使用すると CGM ファイルからフォ
 ントリストを削除します。この場合、読み込んだアプリケーションはデフォル
 トのフォントリストを使用するでしょう。gnuplot はその場合でもフォント番
 号の選択のために自分のデフォルトのフォントリストを使用します。よって、
 'Helvetica' が 1 番になり、それがあなたの使用するアプリケーションのデ
 フォルトフォントリストの最初のものになります。'Helvetica Bold' がその
 フォントリストの 2 番目のフォントに対応し、他も同様となります。

?commands set terminal context
?set terminal context
?terminal context
?set term context
?term context
?context
 ConTeXt は (絵の描画のために) Metapost と高度に融合し、高品質な PDF 文
 書を生成するための TeX のマクロパッケージです。この出力形式は、Metafun
 ソースを生成しますが、これは手動で編集でき、外部からほとんどのことをあ
 なたが設定できます。

 ConTeXt + gnuplot モジュールの平均的なユーザには、このページを読むより
 も、`Using ConTeXt` を参照するか、ConTeXt の gnuplot モジュールのマニュ
 アルを参照することを推奨します。

 出力形式 `context` は、以下のオプションをサポートしています:

 書式:
      set term context {default}
              {defaultsize | size <scale> | size <xsize>{in|cm}, <ysize>{in|cm}}
              {input | standalone}
              {timestamp | notimestamp}
              {noheader | header "<header>"}
              {color | colour | monochrome}
              {rounded | mitered | beveled} {round | butt | squared}
              {dashed | solid} {dashlength | dl <dl>}
              {linewidth | lw <lw>}
              {fontscale <fontscale>}
              {mppoints | texpoints}
              {inlineimages | externalimages}
              {defaultfont | font "{<fontname>}{,<fontsize>}"}

 standalone でないグラフ (`input`) では、オプションはグラフサイズを選択
 する `size`、すべてのラベルを倍率 <fontscale> で伸縮する `fontscasle`、
 および font サイズのみ意味を持ち、他のオプションは警告なく無視されるの
 みで、それらはそのグラフィックを読み込む .tex ファイルの方で設定してく
 ださい。元の文書のフォントが 12pt ではない場合は、適切なフォントサイズ
 を指定することを強く推奨します。それにより、gnuplot がラベル用にどれく
 らいの大きさのスペースを確保すればいいかを知ることができまず。

 `default` は、すべてのオプションをデフォルトの値にリセットします。

 `defaultsize` は、描画サイズを 5in x 3in に設定します。
 `size` <scale> は、描画サイズをデフォルトサイズの <scale> 倍にしますが
 引数を ',' 区切りで 2 つ与えた場合は、最初のものは横のサイズを、2 つ目
 のものは垂直サイズを設定します。それらのサイズには、単位としてインチ
 ('in'), センチ ('cm') が使えますが、省略した場合はデフォルト値に対する
 比であるとみなします。

 `input` (デフォルト) は、他の ConTeXt 文書から取り込めるグラフを生成し
 ます。
 `standalone` は、それに数行追加し、それ自身がそのままコンパイルできるよ
 うにします。その場合、`header` オプションが必要になるかもしれません。

 standalone のグラフに設定/定義/マクロを追加したい場合は `header` を使用
 してください。デフォルトは `noheader` です。

 `notimestamp` は、コメント部分の日時の出力を抑制します (バージョン管理
 システムを使っている場合、日付だけ違うものを新しいバージョンとして登録
 したくはないでしょう)。

 `color` (デフォルト) は、カラー描画を生成しますが、`monochrome` は一切
 special を入れません。白黒プリンタ用には、その挙動をこんな風に変えた方
 がもっと良くなるというアイデアを持っている人は、是非提案してください。

 `rounded` (デフォルト) と `mitered`, `beveled` は、線分の接合部の形状を
 制御し、`round` (default) と `butt`, `squared` は、線分の端の形状を制御
 します。詳細は、PostScript か PDF のリファレンスマニュアルを参照してく
 ださい。激しく変化する関数と太い線用には、線分の接合部での尖った角を避
 けるように`rounded` と `round` を使うといいでしょう。
 (これに関する一般的な仕組みは、このオプションを各描画スタイル毎に別々に
 指定できるよう gnuplot がサポートすべきだと思います。)

 `dashed` (デフォルト) は、異なる線種に異なる点線パターンを使い、`solid`
 は、すべての描画に実線を使用します。

 `dashlength` (または `dl`) は、点線の線分の長さを <dl> 倍します。
 `linewidth` (または `lw`) は、すべての線幅を <lw> 倍します。
 (lw 1 は 0.5bp を意味し、これは Metapost の描画のデフォルトの線幅です)
 `fontscale` は、テキストラベルをデフォルトの文書フォントの <fontscale>
 倍に拡大します。

 `mppoints` は、Metapost で描画された定義済みの点の形状を使用します。
 `texpoints` は、簡単に設定できる記号セットを使用します。これは、以下
 のようにして ConTeXt で定義できます:
      \defineconversion[my own points][+,{\ss x},\mathematics{\circ}]
      \setupGNUPLOTterminal[context][points=tex,pointset=my own points]

 `inlineimages` は、バイナリ画像を文字列として書き出しますが、これは
 ConTeXt MKIV のみで機能します。
 `externalimages` は、PNG ファイルを外部出力し、これは ConTeXt MKII で機
 能します。これが動作するためには、gnuplot が PNG 画像出力をサポートして
 いる必要があります。

 standalone のグラフでは、`font` でフォント名とサイズを設定できます。
 standalone でないモード (`input`) では、テキストラベルに十分なスペース
 を割り当てるためにフォントサイズのみが意味を持ちます
 コマンド
      set term context font "myfont,ss,10"
 は、以下のようになります:
      \setupbodyfont[myfont,ss,10pt]
 例えばさらに追加で `fontscale` を 0.8 に設定すると、結果としてフォント
 は 8pt の大きさになり、
      set label ... font "myfont,12"
 は 9.6pt になります。

 適当なタイプスクリプトフォント (とヘッダー) を用意するのは自分で行って
 さもなくばフォントの切り替えは効果を持ちません。ConTeXt MKII (pdfTeX)
 の標準フォントは、以下のようにして使えます:
      set terminal context standalone header '\usetypescript[iwona][ec]' \
          font "iwona,ss,11"
 フォントの利用に関する ConTeXt の最新の情報については、ConTeXt の文書、
 wiki、メーリングリスト (アーカイブ) を探してみてください。

 例:
      set terminal context size 10cm, 5cm     # 10cm, 5cm
      set terminal context size 4in, 3in      # 4in, 3in
 UTF-8 エンコードラベルを standalone (ページ全体) グラフで使用するには:
      set terminal context standalone header '\enableregime[utf-8]'

 ConTeXt 用の gnuplot モジュール:
      http://ctan.org/pkg/context-gnuplot
 と、最新の ConTeXt が必要です。
 そこから gnuplot を呼び出すには、write18 を可能にする必要があります。
 ほとんどの TeX 配付物では、これは texmf.cnf で shell_escape=t とするこ
 とで設定できます。

 この出力形式とより詳しいヘルプと例に関しては以下も参照してください:
           http://wiki.contextgarden.net/Gnuplot

 ConTeXt 文書でグラフを作成する最も簡単な方法は以下の通り:
      \usemodule[gnuplot]
      \starttext
      \title{How to draw nice plots with {\sc gnuplot}?}
      \startGNUPLOTscript[sin]
      set format y "%.1f"
      plot sin(x) t '$\sin(x)$'
      \stopGNUPLOTscript
      \useGNUPLOTgraphic[sin]
      \stoptext
 これは自動的に gnuplot を実行し、その結果の画像を文書中に取り込みます。
?commands set terminal corel
?set terminal corel
?set term corel
?terminal corel
?term corel
?corel
 CorelDraw (1995 年頃) 用の古い (legacy) 出力形式 です。

 書式:
       set terminal corel {monochrome | color} {"<font>" {<fontsize>}}
                          {<xsize> <ysize> {<linewidth> }}

 ここで、フォントサイズ (`fontsize`) と線幅 (`linewidth`) はポイント単
 位、横幅 (`xsize`) と縦幅 (`ysize`) はインチ単位です。デフォルトの値は
 それぞれ、monochrome, "SwitzerlandLight", 22, 8.2, 10, 1.2 です。
?commands set terminal debug
?set terminal debug
?set term debug
?terminal debug
?term debug
?debug
 このドライバは `gnuplot` のデバッグのために提供されているものです。お
 そらくソースコードを修正するユーザのみが使用するものでしょう。
?set terminal domterm
?terminal domterm
?set term domterm
?term domterm
?domterm
 `domterm` 出力形式は、domterm, qtdomterm プログラム等の DomTerm ターミ
 ナルエミュレータ上で動作します。
 これは、ターミナル出力内へ直接 SVG グラフ画像を埋め込むことをサポートし
 ています。http://domterm.org を参照してください。

 `svg` 出力形式のヘルプを読んでください。

?commands set terminal dumb
?set terminal dumb
?set term dumb
?terminal dumb
?term dumb
?dumb
 ダム端末 (`dumb`) ドライバは、ASCII 文字を使用してテキスト領域に描画し
 ます。サイズの指定と改行制御用のオプションがあります。

 書式:
       set terminal dumb {size <xchars>,<ychars>} {[no]feed}
                         {aspect <htic>{,<vtic>}}
                         {[no]enhanced}

 <xchars>, <ychars> はテキスト領域のサイズを設定し、デフォルトは 79 x 24
 となっています。最後の改行は、`feed` オプションが設定されている場合のみ
 出力されます。

 オプション `aspect` は、グラフのアスペクト比の制御に使用します。これは
 水平軸、垂直軸の目盛り刻みの長さを設定します。整数の指定のみが許されて
 いて、デフォルトは 2,1 で、これは共通のスクリーンフォントのアスペクト比
 に対応します。

 オプション `ansi`, `ansi256`, `ansirgb` は色扱うために出力にエスケープ
 シーケンスを挿入しますが、あなたのターミナルでは処理できないかもしれま
 せん。デフォルトは `mono` です。
 `ansi` モードでは、色は `set colorsequence classic` を使うのが一番合い
 ます。
 どのモードを使用するかによって、`dumb` 出力形式は、以下のシーケンスを出
 力します (空白を追加せずに):

       ESC [ 0 m           属性をデフォルトにリセット
       foreground color:
       表示色:
       ESC [ 1 m           強調/太字をセット
       ESC [ 22 m          強調/太字をオフに
       ESC [ <fg> m        30 <= <fg> <= 37 のカラーコード指定
       ESC [ 39 m          デフォルトにリセット
       ESC [ 38; 5; <c> m  パレットの番号指定 (16 <= <c> <= 255)
       ESC [ 38; 2; <r>; <g>; <b> m  成分指定 (0 <= <r,g,b> <= 255)
       背景色:
       ESC [ <bg> m        40 <= <bg> <= 47 のカラーコード指定
       ESC [ 49 m          デフォルトにリセット
       ESC [ 48; 5; <c> m  パレットの番号指定 (16 <= <c> <= 231)
       ESC [ 48; 2; <r>; <g>; <b> m  成分指定 (0 <= <r,g,b> <= 255)

 例えば、以下の記述も参照してください:
           https://en.wikipedia.org/wiki/ANSI_escape_code#Colors

 例:
       set term dumb mono size 60,15 aspect 1
       set tics nomirror scale 0.5
       plot [-5:6.5] sin(x) with impulse ls -1

           1 +-------------------------------------------------+
         0.8 +|||++                   ++||||++                 |
         0.6 +|||||+                 ++|||||||+  sin(x) +----+ |
         0.4 +||||||+               ++|||||||||+               |
         0.2 +|||||||+             ++|||||||||||+             +|
           0 ++++++++++++++++++++++++++++++++++++++++++++++++++|
        -0.2 +        +|||||||||||+              +|||||||||||+ |
        -0.4 +         +|||||||||+                +|||||||||+  |
        -0.6 +          +|||||||+                  +|||||||+   |
        -0.8 +           ++||||+                    ++||||+    |
          -1 +---+--------+--------+-------+--------+--------+-+
                -4       -2        0       2        4        6
?commands set terminal dxf
?set terminal dxf
?set term dxf
?terminal dxf
?term dxf
?dxf
 `dxf` は AutoCad (リリース 10.x) 用の出力ドライバです。
 このドライバにはオプションはありません。デフォルトの大きさは AutoCad の
 単位での 120x80 です。
 `dxf` は 7 色 (白、赤、黄、緑、水色、青、赤紫) を使いますが、これを変更
 するにはドライバソースファイルを修正する必要があります。白黒の出力装置
 を使う場合、それらの色は線の太さの違いで表現されます。
 注意: どなたか、DXF 規格 2012 を使うように更新してください !
?commands set terminal dxy800a
?set terminal dxy800a
?set term dxy800a
?terminal dxy800a
?term dxy800a
?dxy800a
 注意: 古い (legacy) 出力形式です。
 このドライバは Roland DXY800A プロッタをサポートします。オプションはあ
 りません。
?commands set terminal eepic
?set terminal eepic
?set term eepic
?terminal eepic
?term eepic
?eepic
 `eepic` ドライバは LaTeX picture 環境を拡張するものをサポートします。
 これは `latex` ドライバに代わる別な選択肢です。

 このドライバによる出力は、LaTeX 用の "eepic.sty" マクロパッケージと共
 に使われることを仮定しています。それを使うには、"eepic.sty" と
 "epic.sty"、および "tpic" \special 命令群をサポートするプリンタドライ
 バが必要です。もし、あなたの使うプリンタドライバがそれらの "tpic"
 \special 命令をサポートしていない場合でも、"eepicemu.sty" を使うことで
 それらのうちのいくつかを使えるようになります。
 dvips と dvipdfm は "tpic" \special をサポートしています。

 書式:
    set terminal eepic {default} {color|dashed} {rotate} {size XX,YY}
                       {small|tiny|<fontsize>}

 オプション:
 オプションは任意の順番で与えることができます。
 'color' は gnuplot に \color{...} コマンドを生成させ、それによりグラフ
 をカラーにします。このオプションを使用する場合は、latex 文書のプリアン
 ブルに \usepackage{color} を入れる必要があります。
 'dashed' は線種に点線を使用することを許可します。このオプションを指定
 しないと、色々な太さの実線のみが使われます。
 'dashed' と 'color' は一方のみが意味を持ち、'color' が指定された場合、
 'dashed' は無視されます。
 'rotate' は本当に回転 (90 度) された文字列を使用するようになります。指
 定しない場合は、1 文字 1 文字、上に積み上げていく方法で回転された文字
 列を作ります。このオプションを使う場合は、\usepackage{graphicx} をプリ
 アンブルに入れる必要があります。
 'small' は point スタイルでのグラフ描画の印として \scriptsize の記号を
 使用します (多分これは TeX ではだめで、LaTeX2e でしか使えないでしょう)。
 デフォルトでは標準の数式のサイズを使用します。
 'tiny' は、それに \scriptscriptstyle の記号を使用します。
 'default' は全てのオプションをデフォルトの値にリセットします。デフォル
 トは、color はなし、dashed line はなし、疑似回転 (積み上げ) 文字列の使
 用、大きなサイズの記号の使用、です。
 <fontsize> は picture 環境内でのフォントサイズを指定する数字です。単位
 は pt (ポイント) で、10 pt はほぼ 3.5 mm です。フォントサイズを指定し
 ない場合、全てのグラフ内の文字は \footnotesize に設定されます。

 注意:
 文字 # (およびその他 (La)TeX で特別な意味を持つその他の文字) を \\ (バ
 ックスラッシュ 2 つ) でエスケープすることを忘れないでください。
 グラフの角が近すぎると点線は実線のようになります。(これが tpic specials
 の一般的な問題なのか、eepic.sty や dvips/dvipdfm のバグが原因なのかは私
 にはわかりません。)
 デフォルトの eepic グラフの大きさは 5x3 インチで、これは teminal オプシ
 ョンの `size` で変更可能です。
 数ある中で、点 (point) は、LaTeX のコマンド "\Diamond", "\Box" などを
 使って描かれます。これらのコマンドは現在は LaTeX2e のコアには存在せず
 latexsym パッケージに含まれていますが、このパッケージ基本配布の一部で
 あり、よって多くの LaTeX のシステムの一部になっています。このパッケー
 ジを使うことを忘れないでください。latexsym の代わりに amssymb パッケー
 ジを使うことも可能です。
 LaTeX に関する全てのドライバは文字列の配置の制御に特別な方法を提供しま
 す: '{' で始まる文字列は、'}' で閉じる必要がありますが、その文字列全体
 が水平方向にも垂直方向にもセンタリングされます。'[' で始まる文字列の場
 合は、位置の指定をする文字列 (t,b,l,r のうち 2 つまで) が続き、次に
 ']{'、文字列本体、で最後に '}' としますが、この文字列は LaTeX が LR-box
 として整形します。'\rule{}{}' を使えばさらに良い位置合わせが可能でしょ
 う。

 例:
 set term eepic
   は、グラフを picture 環境に含まれた eepic マクロとして出力します。
   そのファイルを LaTeX 文書に \input で取り込んでください。
 set term eepic color tiny rotate 8
   eepic マクロを \color マクロ、point 印は \scripscriptsize の大きさ、
   本当に回転された文字の使用、および全ての文字を 8pt にセットして出力
   します。

 見出しの位置合わせに関して:
 gnuplot のデフォルト (大抵それなりになるが、そうでないこともある):
        set title '\LaTeX\ -- $ \gamma $'
 水平方向にも垂直方向にもセンタリング:
        set label '{\LaTeX\ -- $ \gamma $}' at 0,0
 位置を明示的に指定 (上に合わせる):
        set xlabel '[t]{\LaTeX\ -- $ \gamma $}'
 他の見出し -- 目盛りの長い見出しに対する見積り:
        set ylabel '[r]{\LaTeX\ -- $ \gamma $\rule{7mm}{0pt}}'
?commands set terminal emf
?set terminal emf
?set term emf
?terminal emf
?term emf
?emf
 `emf` ドライバは EMF (Enhanced Metafile Format) ファイルを生成します。
 この形式のファイルは多くの MS-Windows アプリケーションで認識できます。

 書式:
       set terminal emf {color | monochrome}
                        {enhanced {noproportional}}
                        {rounded | butt}
                        {linewidth <LW>} {dashlength <DL>}
                        {size XX,YY} {background <rgb_color>}
                        {font "<fontname>{,<fontsize>}"}
                        {fontscale <scale>}

 `monochorome` モードは折れ線を点線のパターンを循環させて打ち出します。
 `linewidth <factor>` は全ての線幅をここで指定する値倍にします。
 `dashlength <factor>` は、太い線には便利でしょう。
 `<fontname>` はフォント名、
 `<fontsize>` はポイント単位でのフォントの大きさです。

 出力画像の形式的な (名ばかりの) サイズは、デフォルトでは適当な単位での
 1024x768 になっています。オプション `size` を使って別な形式的なサイズ
 を指定できます。

 拡張文字列処理モード (enhanced text mode) は、プロポーショナル文字間隔
 を近似しようとします。モノスペースフォントを使う場合、あるいはこの近似
 を好まない場合、オプション `noproportional` を使うことでこの補正をオフ
 にできます。

 デフォルトの設定は、`color font "Arial,12" size 1024,768` で、
 `default` を選択すると全てのオプションがそのデフォルトの値になります。

 例:
       set terminal emf 'Times Roman Italic, 12'
?commands set terminal emxvga
?set terminal emxvga
?set term emxvga
?terminal emxvga
?term emxvga
?emxvga
?commands set terminal emxvesa
?set terminal emxvesa
?set term emxvesa
?terminal emxvesa
?term emxvesa
?emxvesa
 注意: 古い (legacy) 出力形式です。
 `emxvga`, `emxvesa` の各ドライバはそれぞれ SVGA, VESA SVGA,
 VGA グラッフィックボードの PC をサポートします。これらは DOS、または
 OS/2 上で、"emx-gcc" でコンパイルされたることを意図しています。これ
 らにはさらに VESA パッケージと SVGAKIT が必要です。これらは Johannes
 Martin (JMARTIN@GOOFY.ZDV.UNI-MAINZ.DE) が保守し David J. Liu
 (liu@phri.nyu.edu) が拡張しているライブラリです。

 書式:
       set terminal emxvga
       set terminal emxvesa {vesa-mode}

 唯一のオプションは `emxvesa` に対する vesa のモードで、デフォルトでは
 それは G640x480x256 となっています。
?set terminal epscairo
?terminal epscairo
?set term epscairo
?term epscairo
?epscairo
 出力形式 `epscairo` は、cairo, pango ライブラリを用いて EPS 出力
 (Encapsulated PostScript) を生成します。cairo は version 1.6 以降が必
 要です。

 詳細は、`pdfcairo` 出力形式のヘルプを参照してください。
?commands set terminal epslatex
?set terminal epslatex
?set term epslatex
?terminal epslatex
?term epslatex
?epslatex
 `epslatex` ドライバは LaTeX で処理すべき出力を生成します。

 書式:
       set terminal epslatex   {default}
       set terminal epslatex   {standalone | input}
                               {oldstyle | newstyle}
                               {level1 | leveldefault | level3}
                               {color | colour | monochrome}
                               {background <rgbcolor> | nobackground}
                               {dashlength | dl <DL>}
                               {linewidth | lw <LW>} {pointscale | ps <PS>}
                               {rounded | butt}
                               {clip | noclip}
                               {palfuncparam <samples>{,<maxdeviation>}}
                               {size <XX>{unit},<YY>{unit}}
                               {header <header> | noheader}
                               {blacktext | colortext | colourtext}
                               {{font} "fontname{,fontsize}" {<fontsize>}}
                               {fontscale <scale>}

 epslatex 出力形式は、文字列を PostScript コードに含ませる代わりに LaTeX
 ファイルに移すことを除けば `terminal postscript eps` 同様に描画します。
 よって、`postscript terminal` と多くのオプションが共通です。

 version 4.0 から 4.2 の間に、postscript 出力形式とのより良い互換性の
 ために epslatex 出力は変更されました。描画サイズは 5 x 3 インチから
 5 x 3.5 インチへと変更され、文字幅は従来はフォントサイズの 50% と見
 なしていましたが、現在は 60% と評価しています。より多くの Postscript
 の線種や記号も使われます。以前の状態にほぼ等しい状態にするにはオプショ
 ン `oldstyle` を指定してください。(実際にはごくわずかな違いが残ります:
 記号のサイズがわずかに違い、目盛刻み (tics) は従来の半分になっています
 がそれは `set tics scale` で変更できます。そして矢 (arrow) に関しては
 postscript 出力形式で使える全ての機能が利用できます。)

 以下のようなエラーメッセージが出た場合:
       "Can't find PostScript prologue file ... "
 以下参照: `postscript prologue`。そしてその指示に従ってください。

 オプション `color` はカラーを有効にし、`monochrome` は各要素を黒と白
 描画します。さらに、`monochrome` は灰色の `palette` も使用しますが、
 これは、明示的に `colorspec` で指定された部品の色を変更しません。

 `dashlength` または `dl` は点線の線分の長さを <DL> (0 より大きい実数)
 に設定し、
 `linewidth` または `lw` は全ての線の幅を <LW> に設定します。

 デフォルトでは、生成される PostScript コードは、特にフィルタリングや
 filledcurves のようなでこぼこな領域のパターン塗りつぶしにおいて、
 PostScript Level 2 として紹介されている言語機能を使います。PostScript
 Level 2 の機能は条件的に保護されていて、PostScript Level 1 のインター
 プリタがエラーを出さず、むしろメッセージか PostScript Level 1 による
 近似であることを表示するようになっています。`level1` オプションは、こ
 れらの機能を近似する PostScript Level1 で代用し、PostScript Level 2
 コードを一切使用しません。これは古いプリンタや、Adobe Illustrator の
 古いバージョンなどで必要になるかもしれません。このフラグ `level1` は
 出力された PostScript ファイルのある一行を手で編集することで、後から
 強制的に PostScript Level 1 機能を ON/OFF にすることもできます。level
 2 のコードが含まれている場合、上の機能は現われないか、このフラグがセ
 ットされた場合、あるいは PostScript インタプリタプログラムが level 2
 以上の PostScript を解釈するとは言わなかった場合に警告文に置き換わり
 ます。`level3` オプションは、ビットマップ画像の PNG 化の機能を有効に
 します。それにより出力サイズをかなり削減できます。

 `rounded` は、線の端や接合部を丸くし、デフォルトの `butt` は尖った端と
 角張った接合部を使用します。

 `clip` は、PostScript にすべての出力を BoundingBox (PostScript の外枠)
 でクリップすることを指示します; デフォルトは `noclip` です。

 `palfuncparam` は `set palette functions` から出力の傾きをどのようにコ
 ード化するかを制御します。解析的な色の成分関数 (`set palatte functions`
 で設定される) は、postscript 出力では傾きの線形補完を用いてコード化さ
 れます: まず色の成分関数が <samples> 個の点で標本化され、そしてそれら
 の点は、結果として線形補完との偏差が <maxdeviation> 以内に収まるように
 削除されます。ほとんど全ての有効なパレットで、デフォルトの <samples>
 =2000 と <maxdeviation>=0.003 の値をそのまま使うのが良いでしょう。

 PostScript 出力のデフォルトの大きさは 10 インチ x 7 インチです。EPS
 出力のデフォルトの大きさは 5 x 3.5 インチです。オプション `size` は
 これらをユーザが指定したものに変更します。デフォルトでは X と Y のサ
 イズの単位はインチとみなされますが、他の単位 (現在は cm のみ) も使う
 ことはできます。描画の BoundingBox (PostScript ファイルの外枠) は、
 サイズが変更された画像を丁度含むように正しく設定されます。
 スクリーン座標は、オプション `size` で指定された描画枠の全体が 0.0
 から 1.0 になります。
 注意: `これは、以前は、出力形式での設定よりも、コマンド set size で
 設定した方がいい、と言っていたことの変更を意味します`。以前の方法で
 は BoundingBox は変更されずに残ってしまい、スクリーン座標が実際の描
 画の限界に対応していませんでした。

 `blacktext` は、たとえカラーモードでも全ての文字列を黒で書きます。

 epslatex ドライバは文字列の配置の制御に特別な方法を提供します:
 (a) '{' で始まる文字列は、'}' で閉じる必要がありますが、その文字列全体
 が LaTeX によって水平方向にも垂直方向にもセンタリングされます。
 (b) '[' で始まる文字列の場合は、位置の指定をする文字列 (t,b,l,r,c のう
 ち 2 つまで) が続き、次に ']{'、文字列本体、で最後に '}' としますが、
 この文字列は  LaTeX が LR-box として整形します。\rule{}{} を使えばさ
 らに良い位置合わせが可能でしょう。以下も参照: ドライバ `pslatex` に関
 する説明。
 複数行の見出しを作成するには \shortstack を使用してください。例えば、
    set ylabel '[r]{\shortstack{first line \\ second line}}'

 `set label` コマンドのオプション `back` は使えますが、他の出力形式のも
 のとは少し違っています。`front` の場合の見出しが他の全ての要素の上に出
 力されるのに対して、`back` を使った見出しは他の全ての要素の下に出力され
 ます。

 このドライバは 2 つの別のファイルを作ります。1 つは図の eps の部分で、
 もう一つは LaTeX の部分です。LaTeX ファイルの名前は、`set output` コマ
 ンドのものが使われ、eps ファイルの名前はその拡張子 (通常 `.tex`) を
 `.eps` に置き換えたものになります。
 出力ファイルを指定しなければ LaTeX 出力は行なわれません !
 `multiplot` モード以外では、次の描画を行なう前にその出力ファイルをクロ
 ーズするのを忘れないでください。

 LaTeX の文書で図を取り込むには '\input{filename}' としてください。
 `.eps` ファイルは \includegraphics{...} コマンドで取り込むので、よって
 LaTeX のプリアンブルに \usepackage{graphicx} も入れる必要があります。
 `textcolour` オプションで色付きの文字列を使用している場合は、LaTeX の
 プリアンブルに \usepackage{color} も入れる必要があります。

 この eps ファイルから 'epstopdf' を使って pdf ファイルを作ることもでき
 ます。graphics パッケージが適切に設定されている場合、その LaTeX のファ
 イルは、変更なしに pdflatex によっても処理でき、その場合 eps ファイル
 の代わりに pdf ファイルが取り込まれます。

 フォントの選択に関する挙動はヘッダーモードに依存します。
 どの場合でも、与えられたフォントサイズはスペースの計算にちゃんと使用さ
 れます。`standalone` モードが使われなかった場合は、include される場所で
 の実際の LaTeX フォントとフォントサイズが使われるので、よってフォントの
 変更には LaTeX コマンドを使ってください。例えばフォントサイズとして
 LaTeX 文書中で 12pt を使う場合は、オプション '"" 12' を使います。この
 場合フォント名は無視されます。`standalone` を使う場合は、与えられたフォ
 ントとフォントサイズが使われます。詳細は下記を参照してください。

 文字列がカラーで表示されるかどうかは TeX の Bool 値変数 \ifGPcolor と
 \ifGPblacktext で制御します。\ifGPcolor が true で \ifGPblacktext が
 false の場合のみ文字列はカラーで表示されます。それらは生成される TeX フ
 ァイルを変更するか、またはあなたの TeX ファイルで大域的に与えてください。
 例えば
    \newif\ifGPblacktext
    \GPblacktexttrue
 をあなたのファイルのプリアンブルに書きます。部分的な指定は大域的な値が
 与えられていないときのみ働きます。

 epslatex 出力形式を使う場合、`set output` コマンドで TeX ファイルの名前
 を拡張子付き (通常 ".tex") で与えてください。eps ファイルの名前はその
 拡張子を ".eps" に置き換えた名前になります。

 `standalone` モードを使う場合、その LaTeX ファイルに完全な LaTeX のヘッ
 ダが付加され、eps ファイルのファイル名には "-inc" が追加されます。
 `standalone` モードは、dvips, pdfTeX, VTeX を使う場合に正しいサイズで出
 力されるような TeX ファイルを作ります。
 デフォルトは `input` モードで、これは \input コマンドを使って、別の
  LaTeX ファイルから読み込まれるようなファイルを生成します。

 "" か "default" 以外のフォント名が与えられた場合、それは LaTeX のフ
 ォント名と解釈されます。それは、'fontname,fontseries,fontshape' の、コ
 ンマで区切られた 3 つ以下の部分からなります。デフォルトのフォントシェイ
 プ、フォントシリーズが使いたい場合はそれらは省略できます。つまり、フォ
 ント名に対する正式な書式は、'[fontname][,fontseries][,fontshape]' とな
 ります。そのいずれの部分も名前に関しては LaTeX のフォント体系の慣習に従
 います。fontname は 3 から 4 文字の長さで、次のような規則で作られていま
 す: 1 つ目がフォントの製造元を表し、次の 2 つがフォント名、オプションで
 追加される 1 つは特別なフォントを意味し、例えば 'j' は旧式の数字を持つ
 フォント、'x' は expert フォント等となっています。以下には、多くのフォ
 ントの名前について書かれています。
           http://www.tug.org/fontname/fontname.pdf
 例えば 'cmr' は Computer Modern Roman フォント、'ptm' は Times-Roman,
 'phv' は Helvetica 等を表します。フォントシリーズは文字の線の太さを意味
 し、大半は 'm' で普通 ("medium")、'bx' または 'b' が太字 (bold) フォ
 ントを意味します。フォントシェイプは一般に 'n' が立体 (upright)、'it'
 はイタリック、'sl' は斜体 (slanted)、'sc' は小さい大文字 (small caps)
 となります。これらとは異なるフォントシリーズやフォントシェイプで与えら
 れるフォントも存在します。

 例:

 Times-Roman で太字 (シェイプは周りの文字列と同じもの) を使う場合:
       set terminal epslatex 'ptm,bx'
 Helvetica で太字でイタリックを使う場合:
       set terminal epslatex 'phv,bx,it'
 斜体のシェイプで周りのフォントを使い続ける場合:
       set terminal epslatex ',,sl'
 小型の大文字 (small caps) を使う場合:
       set terminal epslatex ',,sc'

 この方法では文字列のフォントのみが変更されます。数式のフォントも変更し
 たい場合は、"gnuplot.cfg" ファイルかまたは `header` オプションを使う
 必要がありますが、これについては以下に書きます。

 standalone モードでは、フォントサイズは `set terminal` コマンドで与えら
 れたフォントサイズが使われます。指定したフォントサイズが使えるためには
 LaTeX の検索パスに "size<size>.clo" というファイルが存在しなければな
 りません。デフォルトでは 10pt, 11pt, 12pt がサポートされています。パッ
 ケージ "extsizes" がインストールされていれば、8pt, 9pt, 14pt, 17pt,
 20pt も追加されます。

 オプション `header` は文字列引数を取ります。その文字列は、生成される
 LaTeX ファイルに書き込まれます。`standalone` モードを使う場合、その文字
 列はプリアンブルの \begin{document} コマンドの直前に書き込まれます。
 `input` モードでは、その文字列は \begingroup コマンドの直後に置かれ、
 描画への設定がすべて局所的になるようにします。

 例:

 T1 フォントエンコーディングを使い、文字列、数式フォントを Times-Roman
 とし、サンセリフフォントを Helvetica と変更する場合:
     set terminal epslatex standalone header \
     "\\usepackage[T1]{fontenc}\n\\usepackage{mathptmx}\n\\usepackage{helvet}"
 描画の外の文字列には影響を与えないように描画内で太字 (boldface) フォン
 トを使う場合:
     set terminal epslatex input header "\\bfseries"

 ファイル "gnuplot.cfg" が LaTeX によって見つけられると、`standalone`
 モードを使っている場合は、それは生成される LaTeX 文書のプリアンブルに取
 り込まれます。それは追加の設定を行なうのに使えます。例えば、文書のフォ
 ントを TImes-Roman, Helvetica, Courier と変更し、("mathptmx.sty" で扱
 われている) 数式フォントを入れる場合:
       \usepackage{mathptmx}
       \usepackage[scaled=0.92]{helvet}
       \usepackage{courier}
 ファイル "gnuplot.cfg" は `header` コマンドで与えられるヘッダ情報の前
 に読み込まれます。よって、"gnuplot.cfg" で行なわれる設定のいくつかを
 `header` を使って上書きすることができます。

?commands set terminal epson_180dpi
?set terminal epson_180dpi
?set term epson_180dpi
?terminal epson_180dpi
?term epson_180dpi
?epson_180dpi
?commands set terminal epson_60dpi
?set terminal epson_60dpi
?set term epson_60dpi
?terminal epson_60dpi
?term epson_60dpi
?epson_60dpi
?commands set terminal epson_lx800
?set terminal epson_lx800
?set term epson_lx800
?terminal epson_lx800
?term epson_lx800
?epson_lx800
?commands set terminal nec_cp6
?set terminal nec_cp6
?set term nec_cp6
?terminal nec_cp6
?term nec_cp6
?nec_cp6
?commands set terminal okidata
?set terminal okidata
?set term okidata
?terminal okidata
?term okidata
?okidata
?commands set terminal starc
?set terminal starc
?set term starc
?terminal starc
?term starc
?starc
?commands set terminal tandy_60dpi
?set terminal tandy_60dpi
?set term tandy_60dpi
?terminal tandy_60dpi
?term tandy_60dpi
?tandy_60dpi
?commands set terminal dpu414
?set terminal dpu414
?set term dpu414
?terminal dpu414
?term dpu414
?dpu414
 注意: gnuplot が --with-bitmap-terminals で作られた場合のみ使えます。
 このドライバはエプソンプリンタのいくつかとそれに類似するものをサポート
 します。

 `epson_180dpi` と `epson_60dpi` はそれぞれ 180dpi (ドット/インチ),
 60dpi の解像度の Epson LQ 型 24 ピンプリンタ用のドライバです。

 `epson_lx800` は Epson LX-800, Star の NL-10 や NX-1000, PROPRINTER な
 どの適当なプリンタに流用できる、一般的な 9 ピンプリンタドライバです。

 `nec_cp6` は NEC CP6 や Epson LQ-800 などのプリンタで使える、一般的な
 24 ピンプリンタ用のドライバです。

 `okidata` ドライバは 9 ピンの OKIDATA 320/321 標準プリンタをサポートし
 ます。

 `starc` ドライバは Star カラープリンタ用です。

 `tandy_60dpi` ドライバは 9 ピン 60dpi の Tandy DMP-130 シリーズ用です。

 `dpu414` ドライバは Seiko DPU-414 感熱プリンタ用です。

 `nec_cp6` にはオプションがあります:

 書式:
       set terminal nec_cp6 {monochrome | colour | draft}

 デフォルトでは白黒 (monochrome) です。

 `dpu414` にはオプションがあります:

 書式:
       set terminal dpu414 {small | medium | large} {normal | draft}

 デフォルトは medium (= フォントサイズ) で normal です。
 おすすめの組み合わせは、`medium normal` か `small draft` です。

?commands set terminal excl
?set terminal excl
?set term excl
?terminal excl
?term excl
?excl
 注意: 古い (legacy) 出力形式です。
 `excl` ドライバは EXCL レーザープリンターや 1590 のような Talaris プリ
 ンタをサポートします。オプションはありません。
?commands set terminal fig
?set terminal fig
?set term fig
?terminal fig
?term fig
?fig
?xfig
 `fig` ドライバは、対話型描画ツール xfig に取り込める Fig グラフィック言
 語での出力を生成します。
 注意:
        fig 出力形式は、gnuplot 5.2.7 で大きく改訂されました。
        現在は fig ファイル形式バージョン 3.2 のみサポートしています。
        点線/破線パターンを利用するには Xfig 3.2.6 以降が必要です。

 書式:
       set terminal fig {monochrome | color}
                        {small | big | size <xsize>{in|cm},<ysize>{in|cm}}
                        {landscape | portrait}
                        {font "<fontname>{,<fontsize>}"} {fontsize <size>}
                        {textnormal | {textspecial texthidden textrigid}}
                        {{linewidth|lw} <multiplier>}

 デフォルトの設定は、
       set term fig color small landscape font "Times Roman,10" lw 1.0

 `size` は描画範囲を <xsize>*<ysize> に、インチ単位 (デフォルト) かセン
 チ単位で設定 (変更) します。デフォルトは `size 5in,3in` です。
 `small` は `size 5in,3in` (portrait モードでは 3in,5in) の省略形、
 `big` は `size 8in,5in` の省略形です。

 `font` は、テキストフォントフェース名を <fontname> に、フォントサイズを
 <fontsize> ポイントに設定します。その選択は、35 の標準 PostScript フォ
 ントに限定されています。
 `textnormal` はテキストフラグをリセットして postscript フォントを選択し、
 `textspecial` はテキストフラグを LaTeX special に設定し、
 `texthidden`, `textrigid` はそれぞれ無表示のテキスト、スケーリングされ
 ないテキスト用のフラグを設定します。

 `linewidth` は、すべての線に対する linewidth の値への倍率です。

 `fig` ドライバには `plot` コマンドの `point` スタイルの記号が追加されて
 います。記号の指定は (`pointtype` の値) % 100 の 50 以上の値が使われ、
 その塗りつぶしの濃さは <pointtype> % 5 の値で制御し、その輪郭は黒
 (<pointtype> % 10 < 5 の場合) または現在の色で書かれます。利用可能な記
 号は以下の通りです。
         50 - 59:  円
         60 - 69:  正方形
         70 - 79:  ひし形
         80 - 89:  上向きの三角形
         90 - 99:  下向きの三角形
 これらの記号の大きさはフォントの大きさで変更できます。

 RGB 色は、それが描画の前に線種として定義されているものではない場合、ま
 たは登録されている色名やパレット値に一致しなかった場合は灰色で置き換え
 られます。以下参照: `colornames`。
 例:
       set linetype 999 lc rgb '#aabbcc'
       plot $data with fillecurve fillcolor rgb '#aabbcc'

?commands set terminal ggi
?set terminal ggi
?set term ggi
?terminal ggi
?term ggi
?ggi
 これは GGI (General Graphics Interface) プロジェクト用の古い (legacy)
 出力ドライバです。

 書式:
    set terminal ggi [acceleration <integer>] [[mode] {mode}]

 X では、ウィンドウマネージャの機能を使ってウィンドウのサイズを変更する
 ことはできませんが、モードを mode オプションを使って、例えば以下のよう
 に変更することができます:
  - V1024x768
  - V800x600
  - V640x480
  - V320x200
 他のモードについては、ggi (libggi) のドキュメントを参照してください。
 キーワード `mode` は追加してもしなくても結構です。libggi のマニュアル
 ページで紹介されているように、環境変数でターゲットを選択することをお勧
 めします。X 上で DGA を使うなら、例えば以下のようにしてください。
    bash> export GGI_DISPLAY=DGA
    csh>  setenv GGI_DISPLAY DGA

 `acceleration` は、相対的なポインタ動作イベントを発生するターゲット
 (例えば DGA) でのみ使用され、正の整数で相対的な距離に対する倍率 (積因
 子) を表します。デフォルトの acceleration は 7 です。

 例:
    set term ggi acc 10
    set term ggi acc 1 mode V1024x768
    set term ggi V1024x768
?commands set terminal gif
?set terminal gif
?set term gif
?terminal gif
?term gif
?gif
 書式:
       set terminal gif
              {{no}enhanced}
              {{no}transparent} {rounded|butt}
              {linewidth <lw>} {dashlength <dl>}
              {tiny | small | medium | large | giant}
              {font "<face> {,<pointsize>}"} {fontscale <scale>}
              {size <x>,<y>} {{no}crop}
              {animate {delay <d>} {loop <n>} {{no}optimize}}
              {background <rgb_color>}

 PNG, JPEG, GIF 画像は、外部ライブラリ libgd を使って生成されます。GIF
 の描画は、ImageMagick パッケージのソフト 'display' にその出力を以下の
 ようにパイプで渡すことで対話的に表示させることができます:
                set term gif
                set output '| display gif:-'
 次の描画コマンドからの出力は、display ウィンドウ上で対話的に <space>
 を打つことで見ることができます。現在の描画をファイルに保存するには、
 display ウィンドウで左クリックし、`save` を選択してください。

 `transparent` は、ドライバに背景色の透明化 (transparent) を行うよう指
 示します。デフォルトは `notransparent` です。

 オプション `linewidth` と `dashlength` は拡大率で、描画されるすべての
 線に影響を与えます。すなわち、これらは様々な描画コマンドで要求される値
 にかけ算されます。

 `butt` は線分の描画で、その端の点でのはみだしを起こさない描画メソッド
 を使うようドライバに指示します。この設定は、線幅が 1 より大きい場合に
 のみ有効です。この設定は、水平線、垂直線の描画の場合に有用でしょう。
 デフォルトは `rounded` (丸め) です。

 フォントの選択の詳細は、やや複雑です。
 以下に同じ意味を持つ簡単な例を示します:
      set term gif font arial 11
      set term gif font "arial,11"
 より詳しい情報については、`fonts` の下の該当するセクションを参照してく
 ださい。

 オプション `animate` はあなたの手元にある gd ライブラリがアニメーショ
 ン gif の作成をサポートする場合にのみ有効です。作成される画像の表示間
 隔は、1/100 秒単位で指定できます (デフォルトは 5)。ただし実際の表示間
 隔は、使用する表示ソフトによって変化します。
 アニメーションの繰り返し回数も指定できますが、デフォルトは 0 でそれは
 無限の繰り返しを意味します。
 アニメーション画像列は、次の `set output` か `set term` コマンドによっ
 て終了します。オプション `optimize` は、アニメーションに関する 2 つの
 効果を持ちます。

 1) アニメーション全体を通じて単一のカラーマップが使用されます。これは
 アニメーションの全てのフレームで使用される全ての色が最初のフレームで
 定義されている必要があります。

 2) 可能ならば、個々のフレームで一つ前のフレームと違う部分のみがアニメ
 ーションファイルに保存されます。これはファイルサイズを小さくしてくれ
 ますが、透明化機能を使用している場合には働かないかもしれません。

 これら両方の最適化はより小さいサイズの出力ファイルを作ろうとするもの
 ですが、多分その減少量は、長いアニメーションかまたはフレームサイズが
 とても小さな場合にのみ意味がある程度でしょう。
 オプション `nooptimize` はこれらの効果をいずれも無効にします。各フレ
 ームは、個々のカラーマップ (プライベートカラーマップ) を使い、丸ごと
 保存されていきます。一つ注意しておきますが、最適化されていないアニメ
 ーションファイルは外部ユーティリティを使って後処理することができます
 し、その後処理によって gnuplot の最適化よりも小さなファイルが作られ
 るかもしれません。
 デフォルトでは `nooptimize` です。

 出力描画サイズ <x,y> はピクセル単位で与えます。デフォルトは 640x480 で
 す。以下も参照: `canvas`, `set size`。
 描画終了後の端の余白は、オプション `crop` で取り除くことができ、その結
 果としてその画像サイズは小さくなります。デフォルトは `nocrop` です。

?set term gif examples
       set terminal gif medium size 640,480 background '#ffffff'

 この例は medium サイズの、大きさ変更不能で回転できない組み込みフォント
 を使用し、透明化されない背景色として白 (16 進数の 24bit RGB) を使用しま
 す。

       set terminal gif font arial 14 enhanced

 これは、'arial' というフェース名のスケーラブルフォントを検索し、フォン
 トサイズを 14pt に設定します。フォントの検索がどのように行われるかにつ
 いては以下参照: `fonts`。これはスケーラブルフォントなので、拡張文字列
 処理モードが使用できます。

       set term gif animate transparent opt delay 10 size 200,200
       load "animate2.dem"

 これは、アニメーション GIF ファイルの作成用に gif 出力形式を開きます。
 アニメーション列の個々のフレームは、標準デモファイル集にあるスクリプト
 ファイル animate2.dem によって生成されます。

?commands set terminal gpic
?set terminal gpic
?set term gpic
?terminal gpic
?term gpic
?gpic
 `gpic` ドライバは FSF (the Free Software Foundations) の "groff" パッ
 ケージの中の GPIC 形式のグラフを生成します。デフォルトの大きさは 5 x 3
 インチです。オプションは原点に関するもののみで、デフォルトでは (0,0)
 です。

 書式:
       set terminal gpic {<x> <y>}

 ここで `x` と `y` の単位はインチです。

 単純なグラフを整形するには以下のようにします。

       groff -p -mpic -Tps file.pic > file.ps

 pic からの出力はパイプで eqn に渡すこともできるので、'set label' と
 `set {x/y}label` コマンドでグラフに複雑な関数の式を入れることも可能で
 す。例えば、

       set ylab '@space 0 int from 0 to x alpha ( t ) roman d t@'

 とすれば、以下のコマンドによって y 軸に綺麗な積分が見出し付けされます。

       gpic filename.pic | geqn -d@@ -Tps | groff -m[macro-package] -Tps
           > filename.ps

 このようにして作られた図は文書に綺麗に当てはまるように伸縮することがで
 きます。pic 言語は簡単に理解できるので、必要なら容易にグラフを直接編集
 できます。`gnuplot` で作られる pic ファイルの全ての座標は x+gnuplotx,
 y+gnuploty の形で与えられます。デフォルトでは x, y の値は 0 です。いく
 つかのファイルに対してその x,y を 0 と設定している行を削除すれば、以下
 のようにして複数のグラフを一つの図の中に入れてしまうこともできます (デ
 フォルトの大きさは 5.0x3.0 インチ):

       .PS 8.0
       x=0;y=3
       copy "figa.pic"
       x=5;y=3
       copy "figb.pic"
       x=0;y=0
       copy "figc.pic"
       x=5;y=0
       copy "figd.pic"
       .PE

 これは、横に 2 つ、縦に 2 つずつ並んだ 4 つのグラフからなる、8 インチ
 の広さの図を生成します。

 以下のように x, y を指定することでも同じことができます。

       set terminal gpic x y

?commands set terminal grass
?set terminal grass
?set term grass
?terminal grass
?term grass
?grass
 注意: 古い (legacy) 出力形式です。
 `grass` ドライバは GRASS 地理情報システムのユーザが `gnuplot` を利用す
 ることを可能にします。詳しい情報については grassp-list@moon.cecer.army.mil
 に連絡を取ってください。ページは GRASS グラフウィンドウの現在のフレー
 ムに書かれます。オプションはありません。
?commands set terminal hp2623a
?set terminal hp2623a
?set term hp2623a
?terminal hp2623a
?term hp2623a
?hp2623a
 `hp2623a` ドライバはヒューレットパッカード (Hewlett Packard) HP2623A
 をサポートします。オプションはありません。
?commands set terminal hp2648
?set terminal hp2648
?set term hp2648
?terminal hp2648
?term hp2648
?hp2648
 `hp2648` ドライバはヒューレットパッカード (Hewlett Packard) HP2647 と
 HP2648 をサポートします。オプションはありません。
?commands set terminal hp500c
?set terminal hp500c
?set term hp500c
?terminal hp500c
?term hp500c
?hp500c
 注意: gnuplot が --with-bitmap-terminals で作られた場合のみ使えます。
 `hp500c` ドライバはヒューレットパッカード (Hewlett Packard) 社の HP
 DeskJet 500c をサポートします。これには解像度と圧縮に関するオプション
 があります。

 書式:
       set terminal hp500c {<res>} {<comp>}

 ここで `res` は 75, 100, 150, 300 のいずれかの解像度 (DPI; dots per
 inch) で、`comp` は "rle" か "tiff" です。他の設定をするとそれはデフォ
 ルトの値になります。デフォルトは 75 dpi で圧縮はなしです。高解像度での
 ラスタライズはたくさんのメモリを必要とします。
?commands set terminal hpgl
?set terminal hpgl
?set term hpgl
?terminal hpgl
?term hpgl
?hpgl
?commands set terminal pcl5
?set terminal pcl5
?set term pcl5
?terminal pcl5
?term pcl5
?pcl5
 `hpgl` ドライバは HP7475A プロッタのような装置用の HPGL 出力を行ないま
 す。これは 2 つの設定可能なオプションを持ちます: それはペンの数と `eject`
 オプションで、"eject" は描画後にプロッタにページを排出させるよう指示し
 デフォルトでは 6 つのペンを使い、描画後のページの排出は行ないません。

 国際的文字セット ISO-8859-1 と CP850 を `set encoding iso_8859_1` や
 `set encoding cp850` で認識させることができます (詳細は、以下参照:
 `set encoding`)。

 書式:
       set terminal hpgl {<number_of_pens>} {eject}

 以下の設定

       set terminal hpgl 8 eject

 は、以前の `hp7550` ドライバと同等で、設定

       set terminal hpgl 4

 は、以前の `hp7580b` ドライバと同等です。

 `pcl5` ドライバは、Hewlett-Packard Designjet 750C、Hewlett-Packard
 Laserjet III, Hewlett-Packard Laserjet IV のようなプロッタをサポートし
 ます。これは実際には HPGL-2 を使用しているのですが、装置間で名前の衝突
 があります。このドライバにはいくつかのオプションがありますが、それらは
 以下に示した順序で指定しなければいけません:

 書式:
       set terminal pcl5 {mode <mode>} {<plotsize>}
           {{color {<number_of_pens>}} | monochrome} {solid | dashed}
           {font <font>} {size <fontsize>} {pspoints | nopspoints}

 <mode> は `landscape` か `portrait` です。<plotsize> はグラフの物理的
 な描画サイズで、それは以下のうちのいずれかです: `letter` は標準の
 (8 1/2" X 11") 出力、`legal` は (8 1/2" X 14") 出力、`noextended` は
 (36" X 48") 出力 (letter サイズ比)、`extended` は (36" X 55") 出力
 (ほぼ legal サイズ比)。`color` は複数のペン (すなわちカラー) 描画用で
 <number_of_pens> はカラー出力で使用されるペンの本数 (すなわち色数) で
 す。`monochrome` は 1 本のペン (例えば黒) の描画です。`solid` は全ての
 線を実線で描き、`dashed` は異なる点線や鎖線パターンで線を描き分けます。
 <font> は `stick`, `univers`, `cg_times`, `zapf_dingbats`, `antique_olive`,
 `arial`, `courier`, `garamond_antigua`, `letter_gothic`, `cg_omega`,
 `albertus`, `times_new_roman`, `clarendon`, `coronet`, `marigold`,
 `truetype_symbols`, `wingdings` のいずれかです。<fontsize> はポイント
 単位でのフォントの大きさです。点の種類 (point type) は、`nopspoints` を
 指定することで標準的なデフォルトの設定から選択できるようになりますが、
 `pspoints` を指定すると postscript terminal と同じ点の種類の設定から
 選択できるようになります。

 これらのオプションのいくつかの組み込まれたサポートは、プリンタに依存す
 ることに注意してください。例えば全てのフォントは恐らく HP Laserjet IV
 ではサポートされているでしょうが、HP Laserjet III と Designjet 750C で
 は 2,3 (例えば univers, stick) がサポートされているのみでしょう。
 また、laserjet は白黒の出力装置なので、それらではカラーも明らかに使え
 ません。

 デフォルト: landscape, noextended, color (6 pens), solid, univers, 12
             point, nopspoints

 `pcl5` では国際的文字セットはプリンタで扱われますので、テキスト文字列
 に適切な 8-bit 文字コードを入れるだけで、わざわざ `set encoding` で邪
 魔をする必要はありません。

 HPGL グラフィックは多くのソフトウェアパッケージで取り込むことが可能で
 す。
?commands set terminal hpljii
?set terminal hpljii
?set term hpljii
?terminal hpljii
?term hpljii
?hpljii
?commands set terminal hpdj
?set terminal hpdj
?set term hpdj
?terminal hpdj
?term hpdj
?hpdj
 注意: gnuplot が --with-bitmap-terminals で作られた場合のみ使えます。
 `hpljii` ドライバは HP Laserjet Sries II プリンタを、`hpdj` ドライバは
 HP DeskJet 500 プリンタをサポートします。これらのドライバでは、解像度
 の選択が可能です。

 書式:
       set terminal hpljii | hpdj {<res>}

 ここで `res` は 75, 100, 150, 300 のいずれかの解像度 (DPI; dots per
 inch) で、デフォルトは 75 です。高解像度でのラスタライズはたくさんのメ
 モリを必要とします。

 `hp500c` ドライバは `hpdj` とほぼ同じですが、`hp500c` は加えてカラーと
 圧縮もサポートしています。
?commands set terminal hppj
?set terminal hppj
?set term hppj
?terminal hppj
?term hppj
?hppj
 注意: gnuplot が --with-bitmap-terminals で作られた場合のみ使えます。
 `hppj` ドライバは HP PaintJet と HP3630 プリンタをサポートします。オプ
 ションはフォントを選択するものがあるのみです。

 書式:
       set terminal hppj {FNT5X9 | FNT9X17 | FNT13X25}

 中間サイズフォント (FNT9X17) がデフォルトです。
?commands set terminal imagen
?set terminal imagen
?set term imagen
?terminal imagen
?term imagen
?imagen
 `imagen` ドライバは Imagen レーザプリンタをサポートします。これは 1 ペ
 ージに複数のグラフを配置することも可能です。

 書式:
       set terminal imagen {<fontsize>} {portrait | landscape}
                           {[<horiz>,<vert>]}

 `fontsize` はデフォルトでは 12 ポイントで、レイアウトのデフォルトは
 `landscape` です。`<horiz>` と `<vert>` はグラフを横方向と縦方向に何列
 置くかを指定します。これらのデフォルトは 1 です。

 例:
       set terminal imagen portrait [2,3]

 これは、1 ページに 6 つのグラフを横に 2 列、縦に 3 列、縦置き (portrait)
 で配置します。
?commands set terminal jpeg
?set terminal jpeg
?set term jpeg
?terminal jpeg
?term jpeg
?jpeg
 書式:
       set terminal jpeg
              {{no}enhanced}
              {{no}interlace}
              {linewidth <lw>} {dashlength <dl>} {rounded|butt}
              {tiny | small | medium | large | giant}
              {font "<face> {,<pointsize>}"} {fontscale <scale>}
              {size <x>,<y>} {{no}crop}
              {background <rgb_color>}

 PNG, JPEG, GIF 画像は、外部ライブラリ libgd を使って生成されます。大抵
 の場合、単一の描画なら PNG の方が向いていて、GIF はアニメーション用で
 す。それらは損失の少ない画像形式で、損失のある JPEG 形式よりも上質の画
 像を生成します。これは、特にベタ塗り潰した背景でのカラーの実線、つまり
 まさに gnuplot が生成する典型的な画像に対しては注意すべきことです。

 オプション `interlace` は、プログレッシブ JPEG 画像を生成します。デフ
 ォルトは `nointerlace` です。

 オプション `linewidth` と `dashlength` は拡大率で、描画されるすべての
 線に影響を与えます。すなわち、これらは様々な描画コマンドで要求される値
 にかけ算されます。

 `butt` は線分の描画で、その端の点でのはみだしを起こさない描画メソッド
 を使うようドライバに指示します。この設定は、線幅が 1 より大きい場合に
 のみ有効です。この設定は、水平線、垂直線の描画の場合に有用でしょう。
 デフォルトは `rounded` (丸め) です。

 フォントの選択の詳細は、やや複雑です。
 以下に同じ意味を持つ簡単な例を示します:
      set term jpeg font arial 11
      set term jpeg font "arial,11"
 より詳しい情報については、`fonts` の下の該当するセクションを参照してく
 ださい。

 出力描画サイズ <x,y> はピクセル単位で与えます。デフォルトは 640x480 で
 す。以下も参照: `canvas`, `set size`。
 描画終了後の端の余白は、オプション `crop` で取り除くことができ、その結
 果としてその画像サイズは小さくなります。デフォルトは `nocrop` です。

?commands set terminal kyo
?set terminal kyo
?set term kyo
?terminal kyo
?term kyo
?kyo
?commands set terminal prescribe
?set terminal prescribe
?set term prescribe
?terminal prescribe
?term prescribe
?prescribe
 `kyo` と `prescribe` のドライバは Kyocera (京セラ) レーザープリンタを
 サポートします。この両者の唯一の違いは、`kyo` が "Helvetica" を使うの
 に対して `prescribe` が "Courier" を使うことだけです。オプションはあり
 ません。
?commands set terminal emtex
?set terminal emtex
?set term emtex
?terminal emtex
?term emtex
?emtex
?commands set terminal latex
?set terminal latex
?set term latex
?terminal latex
?term latex
?latex
 書式:
       set terminal {latex | emtex} {default | {courier|roman} {<fontsize>}}
                    {size <XX>{unit}, <YY>{unit}} {rotate | norotate}

 デフォルトでは、それを埋め込む文書のフォントの設定を引き継ぎますが、代
 わりに Courier (cmtt) か Roman (cmr) フォントのいずれかにするオプショ
 ンが使えます。その際はフォントサイズも指定できます。
 あなたの DVI ドライバが任意のサイズのフォントを作り出すことができない
 場合 (例えば dvips)、標準的な 10, 11, 12 ポイントサイズでなんとかしの
 いでください。

 METAFONT ユーザへの警告: METAFONT は妙なサイズは好みません。

 LaTeX に関する全てのドライバは文字列の配置の制御に特別な方法を提供しま
 す: '{' で始まる文字列は、'}' で閉じる必要がありますが、その文字列全体
 が水平方向にも垂直方向にもセンタリングされます。'[' で始まる文字列の場
 合は、位置の指定をする文字列 (t,b,l,r のうち 2 つまで) が続き、次に
 ']{'、文字列本体、で最後に '}' としますが、この文字列は LaTeX が LR-box
 として整形します。'\rule{}{}' を使えばさらに良い位置合わせが可能でしょ
 う。

 数ある中で、点 (point) は、LaTeX のコマンド "\Diamond" と "\Box" を使
 って描かれます。これらのコマンドは現在は LaTeX2e のコアには存在せず、
 latexsym パッケージに含まれていますが、このパッケージ基本配布の一部で
 あり、よって多くの LaTeX のシステムの一部になっています。このパッケー
 ジを使うことを忘れないでください。
 他の点種は、amssymb パッケージの記号を使用します。

 デフォルトの描画サイズは 5 inch × 3 inch ですが、オプション `size` で
 これをユーザの希望するものに変更できます。また、デフォルトでは X と Y
 のサイズの単位は inch ですが、他の単位を使うことも可能です (現在は cm
 のみ)。

 'rotate' を指定すると、文字列の回転、特に y 軸のラベルの回転が可能にな
 ります (graphics か graphicx パッケージが必要)。その場合、y 軸ラベルを
 '積み上げ型' にする仕組みは停止されます。

 例:
 見出しの位置合わせに関して:
 gnuplot のデフォルト (大抵それなりになるが、そうでないこともある):
        set title '\LaTeX\ -- $ \gamma $'
 水平方向にも垂直方向にもセンタリング:
        set label '{\LaTeX\ -- $ \gamma $}' at 0,0
 位置を明示的に指定 (上に合わせる):
        set xlabel '[t]{\LaTeX\ -- $ \gamma $}'
 他の見出し -- 目盛りの長い見出しに対する見積り:
        set ylabel '[r]{\LaTeX\ -- $ \gamma $\rule{7mm}{0pt}}'
?commands set terminal linux
?set terminal linux
?set term linux
?terminal linux
?term linux
?linux
 非推奨 (gnuplot の次のリリースでは削除予定)。
 `linux` ドライバには指定するオプションは何もありません。それはデフォル
 トのモード用に環境変数 GSVGAMODE を参照します。もしそれが設定されてい
 なければ 1024x768x256 をデフォルトとして使用しますが、それができなけれ
 ば 640x480x16 (標準の VGA) とします。
?commands set terminal lua
?set terminal lua
?set term lua
?terminal lua
?term lua
?lua
 この `lua` 出力ドライバは、対象先指定描画ファイルを作成するための、外
 部 Lua スクリプトとの組み合わせで機能します。現在サポートしている対象
 は、TikZ -> pdflatex のみです。

 Lua に関する情報は、http://www.lua.org で参照できます。

 書式:
    set terminal lua <target name> | "<file name>"
                        {<script_args> ...}
                        {help}

 スクリプト用に 'target name'、または引用符付きの 'file name' が必須で
 す。スクリプトの 'target name' を与えた場合は、この出力形式は、
 "gnuplot-<target name>.lua" をまずローカルディレクトリで探し、それに
 失敗すると環境変数 GNUPLOT_LUA_DIR を探します。

 その他のすべての引数は、選択したスクリプトに評価させるように与えられま
 す。例えば、'set term lua tikz help' は、スクリプトそれ自身に、スクリ
 プト用のオプションと選択に関する追加のヘルプを表示させます。

?commands set terminal mf
?set terminal mf
?set term mf
?terminal mf
?term mf
?mf
?metafont
 `mf` ドライバは METAFONT プログラムへの入力ファイルを作ります。よって
 その図は TeX の文書中では文字と同じように使うことができます。

 文書中で図を使うには、`gnuplot` の出力するファイルを入力として METAFONT
 プログラムを実行する必要があります。よって、ユーザはフォントが作られる
 プロセスと新しく作ったフォントをドキュメントに取り込むための基礎知識が
 必要となります。しかし、使用するサイトで METAFONT プログラムが適切に設
 定されていれば、経験のないユーザでもそう問題なく操作はできるでしょう。

 グラフ中の文字は METAFONT の文字セットに基づいてサポートされます。現状
 では Computer Modern Roman フォントセットが入力ですが、ユーザは必要な
 フォントを何でも自由に選ぶことができます。ただしその選んだフォントの
 METAFONT ソースファイルが使える状態になっている必要があります。個々の
 文字は METAFONT の中で別々のピクチャー変数に保存され、文字が必要になっ
 たときにこれらの変数が操作 (回転、伸縮等) されます。欠点は、METAFONT
 プログラムが解釈に要する時間です。ある計算機 (つまり PC) では、ピクチ
 ャー変数をたくさん使用しすぎることで、使えるメモリの量の限界が問題を起
 こすこともあります。

 `mf` ドライバにはオプションはありません。
?commands set terminal mf detailed
?set terminal mf detailed
?set term mf detailed
?mf detailed
?metafont detailed

 - 出力形式 (terminal) を METAFONT にセット:
   set terminal mf
 - 出力ファイル名を設定。例えば:
   set output "myfigures.mf"
 - グラフの描画。各グラフは別々の文字を生成し、そのデフォルトの大きさは
 5x3 インチですが、この大きさは `set size 0.5,0.5` のようにしてどんなサ
 イズにでも自由に変更できます。

 - `gnuplot` を終了

 - `gnuplot` の出力ファイルに対して METAFONT を実行し、TFM ファイルと GF
 ファイルを作ります。グラフは割と大きい (5x3 インチ) ので、memmax の値が
 少なくとも 150000 である METAFONT を使う必要があるでしょう。Unix では、
 それは通常 bigmf という名前でインストールされているでしょう。以下では、
 virmf コマンドが big 版の METAFONT であると仮定し、実行例を示します:

 - METAFONT の立ち上げ:
     virmf '&plain'
 - 出力装置の選択: METAFONT プロンプト ('*') 上で次のように打ちます:
     \mode:=CanonCX;     % あなたの使用するプリンタを指定
 - 拡大率 (magnification) の選択 (オプション):
     mag:=1;             % あなたの好みの値を指定
 - `gnuplot` で作ったファイルを入力:
     input myfigures.mf
 典型的な Unix マシンでは、virmf '&plain' を実行するスクリプト "mf" が
 あるので、virmf &plain の代わりに mf を使えます。これにより mfput.tfm
 と mfput.$$$gf ($$$ は出力装置の解像度) の 2 つのファイルが作られます。
 上の作業は、すべてをコマンドライン上で簡単に実行することもできます:
 virmf '&plain' '\mode:=CanonCX; mag:=1; input myfigures.mf'
 この場合、作られるファイル名は myfigures.tfm と myfigures.300gf という
 名前になります。

 - gftopk を使って GF ファイルから PK ファイルを生成:
   gftopk myfigures.300gf myfigures.300pk
 gftopk が作るファイルの名前はあなたが使用する DVI ドライバに依存します
 ので、サイトの TeX の管理者にフォント名の規則について聞いてください。
 次に TFM ファイルと PK ファイルを適当なディレクトリにインストールするか
 または環境変数を適切な値に設定します。通常それは、TEXFONTS にカレントデ
 ィレクトリを含めることと、あなたが使用する DVI ドライバが使用している環
 境変数 (標準的な名前はありませんが ...) に対して同じことをやれば済みま
 す。これは TeX がフォントメトリック (TFM) ファイル を見つけ、DVI ドライ
 バが PK ファイルを見つけられるようにするために必要な作業です。

 - 文書にそのグラフを入れるために TeX にそのフォント名を指示:
   \font\gnufigs=myfigures
 各グラフは、最初のグラフが文字 0、2 番目のグラフが文字 1 というように、
 それぞれ一つの文字として保存されています。上記の作業を行なうと、グラフ
 はその他の文字と同じように使うことができ、例えばグラフ 1 と 2 を文書中
 にセンタリングして置くために plain TeX ファイル中ですべきことは:
   \centerline{\gnufigs\char0}
   \centerline{\gnufigs\char1}
 だけです。もちろん LaTeX では picture 環境を使って \makebox と \put マ
 クロで任意の位置にグラフを配置することができます。

 このやり方は、一度フォントを生成してしまえば、大幅に時間の節約になりま
 す: TeX はグラフを文字として使い、それを配置するにはごく少ない時間しか
 使用しませんし、グラフよりも文書の方が修正することが多いでしょうから。
 そしてこれは TeX のメモリの節約にもなります。METAFONT ドライバを使うも
 う最後の一つの利点は、生成される DVI ファイルが本来のデバイス非依存な
 形になるということです。それは eepic や tpic ドライバのような \special
 コマンドを全く使わないからです。
?commands set terminal mif
?set terminal mif
?set term mif
?terminal mif
?term mif
?mif
 注意: 古い (legacy) 出力形式です。
 `mif` ドライバは Frame Maker MIF フォーマット (version 3.00) の出力を
 生成します。これは 15*10 cm のサイズの MIF フレームを出力し、同じペン
 で書かれるグラフの基本要素は同じ MIF グループにグループ化されます。
 `gnuplot` の 1 ページにおけるグラフの基本要素は一つの MIF フレームに描
 画され、いくつかの MIF フレームは一つの大きな MIF フレーム内に集められ
 ます。文字列で使われる MIF フォントは "Times" です。

 MIF 3.00 ドライバではいくつかのオプションが設定できます。

 書式:
       set terminal mif {color | colour | monochrome} {polyline | vectors}
                        {help | ?}

 `colour` は線種 (line type) >= 0 の線をカラー (MIF separation 2--7) で、
 `monochrome` は全ての線を黒 (MIF separation 0) で描画します。
 `polyline` は曲線を連続曲線として描画し、`vectors` は曲線をベクトルの
 集まりとして描画します。
 `help` と `?` はオンラインヘルプを標準エラー出力に表示します。両者はそ
 の使用法の短い説明を出力し、`help` は更にオプションも表示します。

 例:
       set term mif colour polylines    # デフォルト
       set term mif                     # デフォルト
       set term mif vectors
       set term mif help
?commands set terminal mpost
?set terminal mp
?set term mp
?terminal mp
?term mp
?mp
?metapost

 `mp` ドライバは Metapost プログラムへ入力することを意図した出力を生成
 し、そのファイルに対して Metapost を実行するとグラフを含む EPS ファイ
 ルが作られます。デフォルトでは Metapost は全ての文字列を TeX に通しま
 す。これはタイトルや見出しに任意の TeX の記号を本質的に使うことができ
 る、という利点を持つことを意味します。

 書式:
    set term mp {color | colour | monochrome}
                {solid | dashed}
                {notex | tex | latex}
                {magnification <magsize>}
                {psnfss | psnfss-version7 | nopsnfss}
                {prologues <value>}
                {a4paper}
                {amstex}
                {"<fontname> {,<fontsize>}"}

 オプション `color` は線をカラーで書くことを意味し (それをサポートする
 プリンタやディスプレイ上で)、`monochrome` (または何も指定しない場合)
 は黒の線が選択されます。オプション `solid` は線を実線で描き、`dashed`
 (または無指定) は線を異なるパターンの点線で描き分けます。`solid` が指
 定されてかつ `color` が指定されなかった場合、ほとんど全ての線が同じも
 のになりますが、これも何かの場合には有用でしょうから認められています。

 オプション `notex` は完全に TeX を迂回しますので、このオプションの元で
 は見出しには TeX のコードは使うことができません。これは、古いグラフフ
 ァイル、あるいは TeX では特殊記号として解釈されてしまう `$` や `%` の
 ような一般的な文字をたくさん使うファイルのために用意されています。

 オプション `tex` は、TeX で処理する文字列を出力するように設定します。

 オプション `latex` は、LaTeX で処理する文字列を出力するように設定しま
 す。これによって TeX では使えないけれど LaTeX では使えるもの、例えば分
 数を \frac で書いたりすることができます。このオプションを使う場合は、
 環境変数 TEX に LaTeX の実行プログラム名 (通常は latex) を設定するか、
 あるいは `mpost --tex=<LaTeX の実行プログラム名> ...` とすることを忘れ
 ないでください。そうでないと metapost はテキストの処理に TeX を使おう
 として失敗してしまうでしょう。

 TeX におけるフォントサイズの変更は数式には効果がなく、そのような変更を
 行なうとても簡単な方法は、大域的に拡大率 (magnification factor) を設定
 する以外にはありません。それがオプション `magnification` の意味です。
 その場合は拡大率を後ろに指定する必要があります。全ての文字 (グラフでは
 なく) はこの率で拡大されます。数式をデフォルトの 10pt 以外の他のサイズ
 で書きたい場合はこれを使用してください。ただ残念なことに全ての数式が同
 じサイズになってしまいますが、しかし、以下の MP 出力の編集に関する説明
 を参照してください。`mag` は `notex` の元でも働きますが、それを行なう
 意味がないくらい (以下に述べる) フォントサイズオプションはうまく働きま
 す。

 オプション `psnfss` は postscript フォントを LaTeX と組み合わせて使用
 します。このオプションは LaTeX が使われる場合のみ意味を持ちますので、
 自動的に `latex` オプションが選択されます。このオプションは以下の
 LaTeX パッケージを使用します:
 inputenc(latin1), fontenc(T1), mathptmx, helvet(scaled=09.2), courier,
 latexsym, textcomp

 オプション `psnfss-version7` も postscript フォントを LaTeX と組み合わ
 せて使用します (`latex` が自動的に選択されます) が、以下の LaTeX パッ
 ケージを使用します:
 inputenc(latin1), fontenc(T1), times, mathptmx, helvet, courier

 オプション `nopsnfss` はデフォルトで、標準的なフォント (何も指定されて
 いなければ cmr10) が使われます。

 オプション `prologues` は追加の値を引数に持ち、metapost ファイルに
 `prologues:=<その値>` という行を追加します。値として `2` を指定すると
 metapost は eps ファイルを作るように postscript フォントを使用し、それ
 によりその結果は例えば ghostscript などで参照できるようになります。標
 準では metapost は TeX のフォントを使用しますので、それを参照するには
 (La)TeX のファイルに取り込む必要があります。

 オプション `noprologues` はデフォルトで、prologue で指定したいかなる行
 も追加されません。

 オプション `a4paper` は `[a4paper]` を documentclass に追加します。標
 準では letter 用紙 (デフォルト) が使われます。このオプションは LaTeX
 でのみ使われますので、自動的に `latex` オプションが選択されます。

 オプション `amstex` は、自動的に `latex` オプションを選択し、以下の
 LaTeX パッケージを使用します: amsfonts, amsmath(intlimits)。デフォルト
 ではこれらは使用されません。

 引用符で囲まれた名前はフォント名を表し、`set label` や `set title` で
 明示的にフォントが与えられない場合はこのフォントが使われます。フォント
 は TeX が認識できる (TFM ファイルが存在する) ものを使う必要があります。
 デフォルトでは `notex` が選択されていなければ "cmr10" が、そうでなけれ
 ば "pcrr8r" (Courier) が使われます。`notex` の元でも、Metapost には
 TFM ファイルは必要です。`pcrr8r.tfm` は LaTeX psnfss パッケージの
 Courier フォント名として与えられています。`notex` のデフォルトからフォ
 ントを変更する場合は、少なくとも 32-126 のコード範囲は ASCII エンコー
 ディングに一致するものを選んでください。`cmtt10` もほぼ使えますが、し
 かしこれはコード 32 (スペース) にスペースではない文字が入っています。

 サイズは 5.0 から 99.99 の間の任意の数字を指定でき、省略された場合は
 10.0 が使われます。なるべく `magstep` サイズ、つまり 1.2 の整数かまた
 は 0.5 乗の 10 倍を小数以下 2 桁未満を丸めた値を使用することをお勧め
 します。それはそれが TeX のシステムで最もよく使われるフォントのサイズ
 だからです。

 全てのオプションは省略可能です。フォントを指定する場合はそれは (必要な
 らサイズもつけて) 一番最後に指定する必要があります。フォント名にそのサ
 イズ情報が含まれていたとしても、サイズを変えるにはフォントサイズを指定
 する必要があります。例えば `set term mp "cmtt12"` は cmtt12 をデフォル
 トのサイズである 10 に縮めて使います。それは多分望まないことでしょうし
 cmtt10 を使う方が良いでしょう。

 以下の ascii 文字は、TeX では特別に扱われます:
    $, &, #, %, _;  |, <, >;  ^, ~,  \, {, }
 $, #, &, _, % の 5 つは、例えば `\$` とすることで容易にそれをエスケー
 プできます。<, >, | の 3 つは、例えば `$<$` のように数式モードに入れて
 やればうまくいきます。残りのものに関しては少し TeX の回避策が必要にな
 りますが、適当なよい TeX の本がそれを指導してくれるでしょう。

 見出しを二重引用符で囲む場合、TeX コードのバックスラッシュはエスケープ
 する (2 つ書く) 必要があります。単一引用符を使えばそれを避けることはで
 きますが、今度は改行として `\n` を使えなくなります。これを書いている現
 在、gnuplot 3.7 は `plot` コマンドで与えられたタイトルは、別な場所で与
 えられた場合とは異なる処理をしますし、引用符のスタイルにかかわらず TeX
 コマンドのバックスラッシュは二重化した方が良さそうです。

 Metapost の画像は TeX の文書内で一般に使われています。Metapost はフォ
 ントを TeX が行なうのと全く同じ方法で扱い、それは他の大抵の文書整形プ
 ログラムとは異なっています。グラフが LaTeX の文書に graphics パッケー
 ジで取り込まれ、あるいは epsf.tex を使って plainTeX に取り込まれ、そし
 て dvips (または他の dvi から ps への変換ソフト) で PostScript に変換
 される場合、そのグラフ内の文字は大抵は正しく扱われているでしょう。しか
 し、Metapost 出力をそのまま PostScript インタプリタに送っても、グラフ
 内の文字は出力されないでしょう。

?commands set terminal mp detailed
?set terminal mp detailed
?set term mp detailed
?mp detailed
?metapost detailed

 - まず terminal ドライバを Metapost に設定、例えば:
    set terminal mp mono "cmtt12" 12

 - 出力ファイルを選択、例えば:
    set output "figure.mp"

 - グラフを作成。各 plot (または multiplot の各グループ) はそれぞれ別な
 Metapost beginfig...endfig グループに分けられます。そのデフォルトのサ
 イズは 5x3 インチですが、それは `set size 0.5,0.5` とか、そうしたいと
 思う適当な割合をそのように指定することで変更できます。

 - gnuplot を終了。

 -  gnuplot の出力ファイルに対して Metapost を実行して EPS ファイルを作
 成:
    mpost figure.mp  OR  mp figure.mp
 Metapost プログラム名はシステムに依存し、Unix では通常 `mpost` で、他
 の多くのシステムでは `mp` です。Metapost は各グラフに対して 1 つずつの
 EPS ファイルを生成します。

 - そのグラフを文書に取り込むには LaTeX graphics パッケージや、plainTeX
 では epsf.tex を使用:
    \usepackage{graphics} % LaTeX
    \input epsf.tex       % plainTeX
 TeX DVI 出力を PS に変換するのに、dvips 以外の DVI ドライバを使う場合
 は、LaTeX ファイルに以下の行を入れる必要があるかも知れません:
    \DeclareGraphicsRule{*}{eps}{*}{}
 作られた各グラフは分離したファイルになっていて、最初のグラフのファイル
 は、例えば figure.0, 2 つ目は例えば figure.1 のような名前になります。
 よって、3 つ目のグラフを文書に取り込むためにあなたがしなければいけない
 ことは以下のみです:
    \includegraphics{figure.2} % LaTeX
    \epsfbox{figure.2}         % plainTeX

 mp ドライバの postscript ドライバに代わる利点は、もしあるとすれば、そ
 れは編集可能な出力であるということでしょう。この出力を可能な限り綺麗に
 するための、かなりの努力が払われました。Metapost 言語に関するそういっ
 た知識のおかげで、デフォルトの線種や色は配列 `lt[]` や `col[]` を編集
 することで変更できるようになりました。実線/点線、カラー/白黒といった選
 択も、真偽値として定義されている `dashedlines` や `colorlines` を変更
 することで行なえます。デフォルトの `tex` オプションが有効な場合、ブロ
 ック `vebatimtex...etex` を編集することで、ラベル文字フォントに対する
 大域的な変更が行なえます。特に、もし望むなら LaTeX のプリアンブルを追
 加することもでき、その場合 LaTeX の持つサイズ変更コマンドを使えるので
 最大の柔軟性を発揮できるでしょう。ただし、Metapost に plainTeX でなく
 LaTeX を実行させるよう、適切な MP 設定変数を設定することを忘れないでく
 ださい。
?commands set terminal pbm
?set terminal pbm
?set term pbm
?terminal pbm
?term pbm
?pbm
 注意: gnuplot が --with-bitmap-terminals で作られた場合のみ使えます。
 書式:
       set terminal pbm {<fontsize>} {<mode>} {size <x>,<y>}

 <fontsize> は `small` か `medium` か `large` で、<mode> は `monochrome`
 か `gray` か `color` です。デフォルトの描画サイズは 640 ピクセルの幅で
 480 ピクセルの高さです。出力サイズは、x と y の両方を 8 ピクセル倍した
 ものに最も近くなるように空白が追加されます。必要であれば、この空白部分
 は後で取り除くことができます。

 `pbm` ドライバの出力は <mode> によります: `monochrome` は portable
 bitmap (PBM; 1 ピクセル 1 ビット) を、`gray` は portable graymap (PGM;
 1 ピクセル 3 bit) を、`color` は portable pixmap (PPM; 1 ピクセル 4 ビ
 ット) を出力します。

 このドライバの出力は、NETPBM によって提供される様々な画像変換、画像処
 理ツールで使うことができます。 Jef Poskanzer の PBMPLUS パッケージに基
 づく NETPBM は、上記の PBM 形式から GIF, TIFF, MacPaint, Macintosh
 PICT, PCX, X11 ビットマップ、その他多くの形式に変換するプログラムを提
 供します。完全な情報は http://netpbm.sourceforge.net/ にあります。

 例:
       set terminal pbm small monochrome                # デフォルト
       set terminal pbm color medium size 800,600
       set output '| pnmrotate 45 | pnmtopng > tilted.png'  # NETPBM を利用
?commands set terminal pdf
?set terminal pdf
?set term pdf
?terminal pdf
?term pdf
?pdf
 このドライバは Adobe PDF (Portable Document Format) 出力を生成し、それ
 は Acrobat Reader のようなツールで表示、印刷ができます。
 [非推奨] この出力形式は、Portable Document Format 形式のファイルを生成
 するのに、フリーではないライブラリ PDFlib (GmbH Munchen)を使用します。
 あなたが、PDFlib の商用ライセンスを持っているのでなければ、そしてそれが
 提供する特別な機能を必要とするのでなければ、これの代わりに cairopdf 出
 力形式を使用する方がいいでしょう。gnuplot では、wxt や qt のような対話
 型出力形式での作業中に PDF ファイルを生成させることもできます。

 書式:
       set terminal pdf {monochrome|color|colour}
                        {{no}enhanced}
                        {fname "<font>"} {fsize <fontsize>}
                        {font "<fontname>{,<fontsize>}"} {fontscale <scale>}
                        {linewidth <lw>} {rounded|butt}
                        {dl <dashlength>}
                        {size <XX>{unit},<YY>{unit}}

 デフォルトでは、個々の線種に対して異なる色を用います。`monochrome` を選
 択すると全ての線種を黒で描きますが、モノクロモードでも塗りつぶし領域や
 ラインスタイルでは明示的に色を使用することができます。

 <font> はデフォルトで使われるフォント名 (デフォルトでは Helvetica) で
 <fontsize> はポイント単位でのフォントサイズ (デフォルトでは 12) です。
 どのようなフォントが使えて、新しいフォントをインストールするには、とい
 ったことに関しては、ローカルにインストールされている pdflib のドキュメ
 ントを参照してください。

 オプション `enhanced` は、拡張文字列処理機能 (下付き文字、上付き文字、
 および複数のフォントの利用) を有効にします。以下参照: `enhanced`。

 描画における全ての線の幅は `linewidth` で指定する因子 <n> で増加するこ
 とができます。同様に、`dashlength` はデフォルトの点線の空白部分に対する
 積因子です。

 `rounded` は、線の端や接合部を丸くし、デフォルトの `butt` は尖った端と
 角張った接合部を使用します。

 PDF 出力のデフォルトのサイズは、5inch x 3inch です。オプション `size`
 は、これをユーザの指定するものへ変更します。デフォルトの X, Y サイズの
 単位はインチですが、他の単位も使用可能です (現在は cm のみ)。

?set terminal pdfcairo
?terminal pdfcairo
?set term pdfcairo
?term pdfcairo
?pdfcairo
 出力形式 `pdfcairo` は、PDF 出力を生成します。実際の描画は、2D グラフ
 ィックライブラリである cairo と、文字列の配置とレンダリング用のライブ
 ラリ pango を経由して行われます。

 書式:
         set term pdfcairo
                      {{no}enhanced} {mono|color}
                      {font <font>} {fontscale <scale>}
                      {linewidth <lw>} {rounded|butt|square} {dashlength <dl>}
                      {background <rgbcolor>
                      {size <XX>{unit},<YY>{unit}}

 この出力形式は、拡張文字列処理モード (enhanced text mode) をサポートし
 ていて、フォントや書式コマンド (上付、下付など) をラベルや他の文字列に
 埋め込むことができます。拡張文字列処理モードの書式は他の gnuplot の出
 力形式と共通です。詳細は、以下参照: `enhanced`。

 描画における全ての線の幅は、`linewidth` で指定する因子 <lw> で変更でき
 ます。デフォルトの線幅は 0.5 ポイントです。(1 "PostScript" ポイント
 = 1/72 インチ = 0.353 mm)

 `rounded` は、線の端や接合部を丸くします。
 デフォルトの `butt` は尖った端と角張った接合部を使用します。

 PDF 出力のデフォルトのサイズは、5inch x 3inch です。オプション `size`
 は、これをユーザの指定するものへ変更します。デフォルトの X, Y サイズの
 単位はインチですが、他の単位も使用可能です (現在は cm のみ)。`size` オ
 プションで指定されたことによる描画の端から端までの領域は、常にスクリー
 ン座標の 0.0 から 1.0 に対応します。

 <font> は、"FontFace,FontSize" の書式、つまりフォント名とサイズをカ
 ンマで区切った一つの文字列として表記します。FontFace は、'Arial' の
 ような通常のフォント名です。フォント名を与えない場合、pdfcairo 出力形
 式では'Sans' が使用されます。FontSize はポイント単位でのフォントサイ
 ズです。指定しない場合は、pdfcairo 出力形式では 12 ポイントサイズの標
 準フォントが使用されます。しかし、この出力形式のパラメータ fontscale
 のデフォルトは 0.5 なので、見かけのフォントサイズは、PDF 出力をフルサ
 イズで見た場合よりも小さくなるでしょう。
    例 :
       set term pdfcairo font "Arial,12"
       set term pdfcairo font "Arial" # フォント名のみ変更
       set term pdfcairo font ",12" # フォントサイズのみ変更
       set term pdfcairo font "" # フォント名とサイズをリセット

 フォントは、通常のフォント処理機構により取得されます。Windows では、フ
 ォントはコントロールパネルの "フォント" の項目で構成され見つけられる
 もので、UNIX では、フォントは "fontconfig" で処理されます。

 文字列のレイアウトに使用されるライブラリ Pango は、utf-8 に基づいてい
 ますので、pdfcairo 出力形式では、文字コードを utf-8 に変換する必要があ
 ります。デフォルトの入力文字コードは、あなたが使用している 'locale'
 に基づきます。他の文字コードにしたい場合は、あなたがどの文字コードを使
 っているのかを確実に gnuplot がわかるようにしてください。詳細について
 は、以下参照: `encoding`。

 pango は、unicode マッピングでないフォントに対しては予期せぬ結果を与え
 るかもしれません。例えば Symbol フォントに対しては、pdfcairo 出力形式
 は、文字コードを unicode に変換するために http://www.unicode.org/ で提
 供されるマッピングを利用します。なお、"the Symbol font" は、Acrobat
 Reader と一緒に "SY______.PFB" として配布されている Adobe Symbol フ
 ォントであると解釈されることに注意してください。この代わりに、
 OpenOffice.org と一緒に "opens___.ttf" として配布される OpenSymbol
 フォントが同じ文字を提供しています。Microsoft も Symbol フォント
 ("symbol.ttf") を配布していますが、これは異なる文字セットになってい
 て、いくつかは欠けていますし、いくつかは数式記号に変わってしまっていま
 す。あなたのデフォルトの設定でなんらかの問題が起きた場合 (例えばデモス
 クリプト enhancedtext.dem がちゃんと表示されないといった場合) は、
 Adobe か OpenOffice の Symbol フォントをインストールして、Microsoft の
 Symbol フォントを削除しないといけないかもしれません。"windings" のよ
 うな他の非標準のフォントでも動作することが報告されています。

 描画のレンダリングは、今のところ変更できません。出力をより良くするため
 にこのレンダリングは、アンチエイリアス、オーバーサンプリングの 2 つの
 機構を持っています。
 アンチエイリアスは、水平や垂直でない線を滑らかに表示します。
 オーバーサンプリングは、アンチエイリアスと組でピクセルよりも小さいサイ
 ズでの精度を提供し、gnuplot が非整数座標の直線を書けるようになります。
 これは、対角方向の直線 (例えば 'plot x') が左右に揺れるのを避けます。

?commands set terminal pm
?set terminal pm
?set term pm
?terminal pm
?term pm
?pm
 `pm` ドライバは、グラフが描画される OS/2 プレゼンテーションマネージャ
 ウィンドウを提供します。そのウィンドウは最初のグラフが描画されたときに
 開かれます。このウィンドウは印刷、クリップボードへのコピー、そしてそれ
 自身のオンラインヘルプを持っています。

 書式:
       set terminal pm {server {n}} {persist} {widelines} {enhanced} {"title"}

 `persist` を指定すると、各グラフはそれぞれ自身のウィンドウを持ち、その
 すべてのウィンドウは `gnuplot` が終了した後も開いたままになります。
 `server` を指定すると、全てのグラフは同じウィンドウ内に現われ、それは
 `gnuplot` 終了後も開いたままになります。このオプションは、さらに追加の
 数引数を取り、その数字はサーバプロセスのインスタンスになります。よって
 同時に複数のサーバウィンドウを使うことができます。

 `widelines` を指定すると、全てのグラフは幅の広い線で描かれます。
 `enhanced` を指定すると、上付き文字や下付き文字、複数のフォントを使う
 ことができます (詳細は、以下参照: `enhanced text`)。コア PostScript フ
 ォントのフォント名は 1 文字に省略できます
 (T/H/C/S はそれぞれ Times/Helvetica/Courier/Symbol を意味します)。

 `title` を指定すると、それは描画ウィンドウのタイトルとして使われます。
 それはサーバインスタンス名としても使われ、それは追加の数引数を上書きし
 ます。
?commands set terminal png
?set terminal png
?set term png
?terminal png
?term png
?png
 書式:
       set terminal png
              {{no}enhanced}
              {{no}transparent} {{no}interlace}
              {{no}truecolor} {rounded|butt}
              {linewidth <lw>} {dashlength <dl>}
              {tiny | small | medium | large | giant}
              {font "<face> {,<pointsize>}"} {fontscale <scale>}
              {size <x>,<y>} {{no}crop}
              {background <rgb_color>}

 PNG, JPEG, GIF 画像は、外部ライブラリ libgd を使って生成されます。PNG
 の描画は、ImageMagick パッケージのソフト 'display' にその出力を以下の
 ようにパイプで渡すことで対話的に表示させることができます:
                set term png
                set output '| display png:-'
 次の描画コマンドからの出力は、display ウィンドウ上で対話的に <space>
 を打つことで見ることができます。現在の描画をファイルに保存するには、
 display ウィンドウで左クリックし、`save` を選択してください。

 `transparent` は、ドライバに背景色の透明化 (transparent) を行うよう指
 示します。デフォルトは `notransparent` です。

 `interlace` は、ドライバにインターレース GIF を生成するよう指示します。
 デフォルトは `nointerlace` です。

 オプション `linewidth` と `dashlength` は拡大率で、描画されるすべての
 線に影響を与えます。すなわち、これらは様々な描画コマンドで要求される値
 にかけ算されます。

 デフォルトでは、出力される PNG 画像は 256 個に番号付けられた色を使用し
 ます。代わりにオプション `truecolor` を使えば、24 ビット/ピクセルの色
 情報を持つ TrueColor 画像が生成されます。透明化塗りつぶし (transparent
 fill) を使用するときは、このオプション `truecolor` が必要になります。
 以下参照: `fillstyle`。背景の透明化は、番号付け画像か TrueColor 画像で
 可能です。

 `butt` は線分の描画で、その端の点でのはみだしを起こさない描画メソッド
 を使うようドライバに指示します。この設定は、線幅が 1 より大きい場合に
 のみ有効です。この設定は、水平線、垂直線の描画の場合に有用でしょう。
 デフォルトは `rounded` (丸め) です。

 フォントの選択の詳細は、やや複雑です。
 以下に同じ意味を持つ簡単な例を示します:
      set term png font arial 11
      set term png font "arial,11"
 より詳しい情報については、`fonts` の下の該当するセクションを参照してく
 ださい。

 出力描画サイズ <x,y> はピクセル単位で与えます。デフォルトは 640x480 で
 す。以下も参照: `canvas`, `set size`。
 描画終了後の端の余白は、オプション `crop` で取り除くことができ、その結
 果としてその画像サイズは小さくなります。デフォルトは `nocrop` です。

?set term png examples
       set terminal png medium size 640,480 background '#ffffff'

 この例は medium サイズの、大きさ変更不能で回転できない組み込みフォント
 を使用し、透明化されない背景色として白 (16 進数の 24bit RGB) を使用しま
 す。

       set terminal png font arial 14 size 800,600

 これは、'arial' というフェース名のスケーラブルフォントを検索し、フォン
 トサイズを 14pt に設定します。フォントの検索がどのように行われるかにつ
 いては以下参照: `fonts`。

       set terminal png transparent truecolor enhanced

 これは、24 ビット/ピクセルの色情報を使用し、背景を透明化します。そして
 表示される文字列の配置制御として `enhanced text` モードを使用します。

?set terminal pngcairo
?terminal pngcairo
?set term pngcairo
?term pngcairo
?pngcairo
 出力形式 `pngcairo` は、PNG 出力を生成します。実際の描画は、2D グラフ
 ィックライブラリである cairo と、文字列の配置とレンダリング用のライブ
 ラリ pango を経由して行われます。

 書式:
         set term pngcairo
                      {{no}enhanced} {mono|color}
                      {{no}transparent} {{no}crop} {background <rgbcolor>
                      {font <font>} {fontscale <scale>}
                      {linewidth <lw>} {rounded|butt|square} {dashlength <dl>}
                      {pointscale <ps>}
                      {size <XX>{unit},<YY>{unit}}

 この出力形式は、拡張文字列処理モード (enhanced text mode) をサポートし
 ていて、フォントや書式コマンド (上付、下付など) をラベルや他の文字列に
 埋め込むことができます。拡張文字列処理モードの書式は他の gnuplot の出
 力形式と共通です。詳細は、以下参照: `enhanced`。

 描画における全ての線の幅は、因子 <lw> で変更できます。

 `rounded` は、線の端や接合部を丸くします。
 デフォルトの `butt` は尖った端と角張った接合部を使用します。

 PNG 出力のデフォルトのサイズは、640 x 480 ピクセルです。オプション
 `size` は、これをユーザの指定するものへ変更します。デフォルトの X, Y
 サイズの単位はピクセルですが、他の単位も使用可能です (現在は cm とイン
 チ)。サイズを cm かインチで与えるとそれは、解像度 72 dpi でのピクセル
 数に変換されます。`size` オプションで指定されたことによる描画の端から
 端までの領域は、常にスクリーン座標の 0.0 から 1.0 に対応します。

 <font> は、"FontFace,FontSize" の書式、つまりフォント名とサイズをカ
 ンマで区切った一つの文字列として表記します。FontFace は、'Arial' の
 ような通常のフォント名です。フォント名を与えない場合、pngcairo 出力形
 式では'Sans' が使用されます。FontSize はポイント単位でのフォントサイ
 ズです。指定しない場合は、pngcairo 出力形式では 12 ポイントのサイズが
 使用されます。
    例 :
       set term pngcairo font "Arial,12"
       set term pngcairo font "Arial" # フォント名のみ変更
       set term pngcairo font ",12" # フォントサイズのみ変更
       set term pngcairo font "" # フォント名とサイズをリセット

 フォントは、通常のフォント処理機構により取得されます。Windows では、フ
 ォントはコントロールパネルの "フォント" の項目で構成され見つけられる
 もので、UNIX では、フォントは "fontconfig" で処理されます。

 文字列のレイアウトに使用されるライブラリ Pango は、utf-8 に基づいてい
 ますので、pngcairo 出力形式では、文字コードを utf-8 に変換する必要があ
 ります。デフォルトの入力文字コードは、あなたが使用している 'locale'
 に基づきます。他の文字コードにしたい場合は、あなたがどの文字コードを使
 っているのかを確実に gnuplot がわかるようにしてください。詳細について
 は、以下参照: `encoding`。

 pango は、unicode マッピングでないフォントに対しては予期せぬ結果を与え
 るかもしれません。例えば Symbol フォントに対しては、pngcairo 出力形式
 は、文字コードを unicode に変換するために http://www.unicode.org/ で提
 供されるマッピングを利用します。なお、"the Symbol font" は、Acrobat
 Reader と一緒に "SY______.PFB" として配布されている Adobe Symbol フ
 ォントであると解釈されることに注意してください。この代わりに、
 OpenOffice.org と一緒に "opens___.ttf" として配布される OpenSymbol
 フォントが同じ文字を提供しています。Microsoft も Symbol フォント
 ("symbol.ttf") を配布していますが、これは異なる文字セットになってい
 て、いくつかは欠けていますし、いくつかは数式記号に変わってしまっていま
 す。あなたのデフォルトの設定でなんらかの問題が起きた場合 (例えばデモス
 クリプト enhancedtext.dem がちゃんと表示されないといった場合) は、
 Adobe か OpenOffice の Symbol フォントをインストールして、Microsoft の
 Symbol フォントを削除しないといけないかもしれません。

 レンダリングは、cairo と pango ライブラリがサポートする範囲内で、オーバ
 ーサンプリングとアンチエイリアス、フォントのヒンティングを行います。

?commands set terminal postscript
?set terminal postscript
?set term postscript
?terminal postscript
?term postscript
?postscript
 `postscript` ドライバではいくつかのオプションが設定できます。

 書式:
       set terminal postscript {default}
       set terminal postscript {landscape | portrait | eps}
                               {enhanced | noenhanced}
                               {defaultplex | simplex | duplex}
                               {fontfile [add | delete] "<filename>"
                                | nofontfiles} {{no}adobeglyphnames}
                               {level1 | leveldefault | level3}
                               {color | colour | monochrome}
                               {background <rgbcolor> | nobackground}
                               {dashlength | dl <DL>}
                               {linewidth | lw <LW>} {pointscale | ps <PS>}
                               {rounded | butt}
                               {clip | noclip}
                               {palfuncparam <samples>{,<maxdeviation>}}
                               {size <XX>{unit},<YY>{unit}}
                               {blacktext | colortext | colourtext}
                               {{font} "fontname{,fontsize}" {<fontsize>}}
                               {fontscale <scale>}
 以下のようなエラーメッセージが出た場合:
       "Can't find PostScript prologue file ... "
 以下参照: `postscript prologue`。そしてその指示に従ってください。


 `landscape` と `portrait` は出力が横置か、縦置かを選択します。
 `eps` モードは EPS (Encapsulated PostScript) 出力を生成しますが、これ
 は通常の PostScript に、それを他の多くのアプリケーションで取り込むこと
 ができるようにいくつかの行を追加したものです (追加される行は PostScript
 のコメント行なので、よってそれ自身もちゃんと印刷できます)。EPS 出力を
 得るには `eps` モードを使用し、1 つのファイルには 1 つのグラフのみ、と
 してください。`eps` モードではフォントも含めてグラフ全体がデフォルトの
 大きさの半分に縮められます。

 `enhanced` は拡張文字列処理モード (上付き文字、下付き文字、および複数
 のフォントの利用) の機能を有効にします。詳細は、以下参照: `enhanced`。
 `blacktext` は、たとえカラーモードでも全ての文字列を黒で書きます。

 PostScript の両面印刷命令 (duplex) は、プリンタで 1 枚の紙に両面印刷す
 ることを可能にします。`defaultplex` はプリンタのデフォルトの設定を使用
 し、`simplex` は紙の片面のみ印刷、`duplex` は 両面印刷を行ないます (あ
 なたのプリンタがそれを行なえないなら無視されます)。

 `"<fontname>"` は有効な PostScript フォントの名前で、`<fontsize>` は
 PostScript ポイント単位でのフォントの大きさです。
 標準的な postscript フォント以外に、数式を表現するのに便利な oblique
 Symbol フォント ("Symbol-Oblique") が定義されています。

 `default` は全てのオプションを以下のデフォルトの値に設定します:
 `landscape`, `monochrome`, `dl 1.0`, `lw 1.0`, `defaultplex`,
 `enhanced`, "Helvetica", 14pt。PostScript のグラフのデフォルトの大き
 さは、10 インチの幅で 7 インチの高さです。
 オプション `color` はカラーを有効にし、`monochrome` は各要素を黒と白
 描画します。さらに、`monochrome` は灰色の `palette` も使用しますが、
 これは、明示的に `colorspec` で指定された部品の色を変更しません。

 `dashlength` または `dl` は点線の線分の長さを <DL> (0 より大きい実数)
 に設定し、
 `linewidth` または `lw` は全ての線の幅を <LW> に設定します。

 デフォルトでは、生成される PostScript コードは、特にフィルタリングや
 filledcurves のようなでこぼこな領域のパターン塗りつぶしにおいて、
 PostScript Level 2 として紹介されている言語機能を使います。PostScript
 Level 2 の機能は条件的に保護されていて、PostScript Level 1 のインター
 プリタがエラーを出さず、むしろメッセージか PostScript Level 1 による
 近似であることを表示するようになっています。`level1` オプションは、こ
 れらの機能を近似する PostScript Level1 で代用し、PostScript Level 2
 コードを一切使用しません。これは古いプリンタや、Adobe Illustrator の
 古いバージョンなどで必要になるかもしれません。このフラグ `level1` は
 出力された PostScript ファイルのある一行を手で編集することで、後から
 強制的に PostScript Level 1 機能を ON/OFF にすることもできます。level
 2 のコードが含まれている場合、上の機能は現われないか、このフラグがセ
 ットされた場合、あるいは PostScript インタプリタプログラムが level 2
 以上の PostScript を解釈するとは言わなかった場合に警告文に置き換わり
 ます。`level3` オプションは、ビットマップ画像の PNG 化の機能を有効に
 します。それにより出力サイズをかなり削減できます。

 `rounded` は、線の端や接合部を丸くし、デフォルトの `butt` は尖った端と
 角張った接合部を使用します。

 `clip` は、PostScript にすべての出力を BoundingBox (PostScript の外枠)
 でクリップすることを指示します; デフォルトは `noclip` です。

 `palfuncparam` は `set palette functions` から出力の傾きをどのようにコ
 ード化するかを制御します。解析的な色の成分関数 (`set palatte functions`
 で設定される) は、postscript 出力では傾きの線形補完を用いてコード化さ
 れます: まず色の成分関数が <samples> 個の点で標本化され、そしてそれら
 の点は、結果として線形補完との偏差が <maxdeviation> 以内に収まるように
 削除されます。ほとんど全ての有効なパレットで、デフォルトの <samples>
 =2000 と <maxdeviation>=0.003 の値をそのまま使うのが良いでしょう。

 PostScript 出力のデフォルトの大きさは 10 インチ x 7 インチです。EPS
 出力のデフォルトの大きさは 5 x 3.5 インチです。オプション `size` は
 これらをユーザが指定したものに変更します。デフォルトでは X と Y のサ
 イズの単位はインチとみなされますが、他の単位 (現在は cm のみ) も使う
 ことはできます。描画の BoundingBox (PostScript ファイルの外枠) は、
 サイズが変更された画像を丁度含むように正しく設定されます。
 スクリーン座標は、オプション `size` で指定された描画枠の全体が 0.0
 から 1.0 になります。
 注意: `これは、以前は、出力形式での設定よりも、コマンド set size で
 設定した方がいい、と言っていたことの変更を意味します`。以前の方法で
 は BoundingBox は変更されずに残ってしまい、スクリーン座標が実際の描
 画の限界に対応していませんでした。

 `fontfile` や `fontfile add` で指定されたフォントは、そのフォントのフ
 ォント定義を直接 postscript Type 1, TrueType フォントから gnuplot の
 postscript 出力の中にカプセル化します。よって、その埋め込まれたフォン
 トは見出し、タイトルなどに使うことができます。詳細は、以下参照:
 `postscript fontfile`。`fontfile delete` によってフォントファイルを埋
 め込まれるファイルの一覧から取り除くことができます。
 `nofontfiles` は埋め込みフォントのリストをクリアします。

 例:
       set terminal postscript default       # 以前の postscript
       set terminal postscript enhanced      # 以前の enhpost
       set terminal postscript landscape 22  # 以前の psbig
       set terminal postscript eps 14        # 以前の epsf1
       set terminal postscript eps 22        # 以前の epsf2
       set size 0.7,1.4; set term post portrait color "Times-Roman" 14
       set term post "VAGRoundedBT_Regular" 14 fontfile "bvrr8a.pfa"

 線の幅と点の大きさは `set style line` で変更できます。

 `postscript` ドライバは約 70 種類の異なる点種をサポートしていて、これ
 は `plot` や `set style line` の `pointtype` オプションで選択できます。

 `gnuplot` と Postscript に関する多分有用と思われるファイルが `gnuplot`
 の配布物、またはその配布サイトの /docs/psdos サブディレクトリ内にいく
 つか含まれています。そこには "ps_symbols.gpi" (実行すると `postscript`
 ドライバで使える全ての記号を紹介する "ps_symbols.ps" というファイルを生
 成する `gnuplot` のコマンドファイル)、"ps_guide.ps" (拡張された書式に
 関する要約と、文字列内で 8 進コードで生成されるもの、symbol フォント等
 を含む PostScript ファイル)、"ps_file.doc" (`gnuplot` で作られる
 PostScript ファイルの構造の説明を含むテキストファイル)、
 "ps_fontfile_doc.tex" (数式フォントの文字の一覧と LaTeX のフォントの埋
 め込みに関する短い説明を含む LaTeX ファイル) があります。

 PostScript ファイルは編集可能で、一度 `gnuplot` でそれを作れば、それを
 望むように修正することは自由に行なえます。そのためのヒントを得るには、
 以下参照: `editing postscript` の節。
?commands set terminal postscript editing
?set terminal postscript editing
?set term postscript editing
?terminal postscript editing
?term postscript editing
?editing_postscript
?editing postscript
 PostScript 言語はとても複雑な言語で、ここで詳細を記述することはとても
 できません。それでも、`gnuplot` で作られる PostScript ファイルには、致
 命的なエラーをそのファイルに導入してしまう危険性のない変更を行なうこと
 が可能な部分があります。

 例えば、PostScript の文 "/Color true def" (`set terminal postscript color`
 コマンドに答えてファイルに書き込まれます) を変更して、その描画を白黒の
 ものにする方法はおわかりでしょう。同様に、線の色、文字の色、線の太さ
 (weight)、記号のサイズも、本当に簡単に書き換えられるでしょう。タイトル
 や見出しなどの文字列の誤植や、フォントの変更も編集可能でしょう。任意の
 ものの配置も変更できますし、もちろん、任意のものを追加したり、削除した
 りもできますが、それらの修正は PostScript 言語の深い知識が必要でしょう。

 `gnuplot` によって作られる PostScript ファイルの構成に関しては、gnuplot
 のソース配布物内の docs/ps ディレクトリのテキストファイル "ps_file.doc"
 に述べられています。
?commands set terminal postscript fontfile
?set terminal postscript fontfile
?set term postscript fontfile
?terminal postscript fontfile
?term postscript fontfile
?postscript fontfile
?fontfile
 オプション `fontfile` または `fontfile add` は 1 つのファイル名を引数
 として持ち、そのファイルを postscript 出力内にカプセル化して埋め込み、
 それによって様々な文字列要素 (ラベル、目盛り見出し、タイトル等) をその
 フォントで出力することを可能にします。オプション `fontfile delete` も
 1 つのファイル名を引数に持ち、そのファイル名をカプセル化されるファイル
 のリストから削除します。

 postscript 出力ドライバはいくつかのフォントファイル形式を認識します:
 ASCII 形式の Type 1 フォント (拡張子 ".pfa")、バイナリ形式の Type 1 フ
 ォント (拡張子 ".pfb")、TrueType フォント (拡張子 ".ttf")。pfa ファイ
 ルは直接認識されますが、pfb と ttf ファイルは gnuplot の実行中に並行し
 て変換され、そのために適切な変換ツール (下記参照) がインストールされて
 いる必要があります。ファイル名は拡張子も含めて完全な形で指定する必要が
 あります。各 `fontfile` オプションはちょうど一つのフォントファイル名に
 対応しますので、複数のフォントファイルを埋め込むためにはこのオプション
 を複数回使って下さい。

 フォントファイルは、作業ディレクトリ、そして `set fontpath` で与えられ
 るフォントパス一覧の全てのディレクトリが検索されます。さらに、環境変数
 GNUPLOT_FONTPATH でフォントパスを設定することもできます。それが設定さ
 れていない場合はデフォルトの検索リストが使われますが、これはシステムに
 依存します。詳細は、以下参照: `set fontpath`。

 埋め込まれたフォントファイルを使うには、フォント名 (通常ファイル名と同
 じではありません) を指定する必要があります。対話モードで `fontfile` オ
 プションを使ってフォントを埋め込んだ場合、フォント名はスクリーンに表示
 されます。例:
    Font file 'p052004l.pfb' contains the font 'URWPalladioL-Bold'. Location:
    /usr/lib/X11/fonts/URW/p052004l.pfb

 pfa や pfb フォントでは、フォント名はフォントファイル内に見つけること
 ができます。フォントファイル中に "/FontName /URWPalladioL-Bold def" の
 ような行がありますが、この真中の物から / を除いたものがフォント名です。
 この例の場合は "URWPalladioL-Bold" となります。
 TrueType フォントでは、フォント名はバイナリ形式で保存されているので見
 つけるのは容易ではありません。さらに、その名前は多くの場合、Type 1 フ
 ォント (実行中に TrueType が変換される形式である) ではサポートされてい
 ない、スペースを含んだ形式になっています。そのため、フォント名はそこか
 らスペースを取り除いた形に変換されます。gnuplot で使うために生成された
 フォント名が何であるかを知る最も簡単な方法は、gnuplot を対話モードで起
 動して、以下のように入力することです:
 "set terminal postscript fontfile '<filename.ttf>'".

 フォントファイル (ttf, pfb) を pfa 形式に変換するために、フォントファ
 イルを読んで、そして変換結果を標準出力に吐き出す変換ツールが必要になり
 ます。その出力を標準出力に書き出すことができない場合、実行中の変換はで
 きません。

 pfb ファイルに対しては、例えば "pfbtops" が使えます。それがシステム
 にインストールされていれば、実行中の変換はうまく行くはずです。pfb ファ
 イルのカプセル化をちょっとやってみましょう。もしプログラムの変換時に正
 しくツールを呼び出していない場合は、どのようにツールを呼び出したら良い
 かを環境変数 GNUPLOT_PFBTOPFA に、例えば "pfbtops %s" のように定義し
 て下さい。`%s` はフォントファイル名に置き換えられますので、これはその
 文字列に必ず必要です。

 実行中の変換をしたくなくて、けれども pfa 形式のファイルは必要である場
 合、"pfb2pfa" という C で書かれた簡単なツールを使えば良いでしょう。こ
 れは大抵の C コンパイラでコンパイルでき、たくさんの ftp サーバに置いて
 あります。例えば
           ftp://ftp.dante.de/tex-archive/fonts/utilities/ps2mf/
 実際に "pfbtopfa" と "pfb2ps" は同じ作業を行います。"pfbtops" は結果の
 pfa コードを標準出力に出力しますが、"pfbtopfa" はファイルに出力します。

 TrueType フォントは、例えば "ttf2pt1" というツールを使って Type 1 pfa
 フォーマットに変換できます。これは以下にあります:
           http://ttf2pt1.sourceforge.net/
 もし gnuplot に組み込まれている変換手順がうまく行かない場合、変換コマ
 ンドは環境変数 GNUPLOT_TTFTOPFA で変更できます。ttf2pt1 を使う場合は、
 それを "ttf2pt1 -a -e -W 0 %s - " のように設定して下さい。ここでも
 `%s` はファイル名を意味します。

 特殊な用途のために、パイプも使えるようになっています (パイプをサポート
 している OS 上で)。ファイル名を "<" で始め、その後にプログラム呼び出し
 を追加します。そのプログラム出力は標準出力への pfa データでなければい
 けません。結果として pfa ファイルを、例えば以下のようにしてアクセスで
 きることになります: `set fontfile "< cat garamond.pfa"`。

 Type 1 フォントを取り込むことは、例えば LaTeX 文書中に postscript ファ
 イルを取り込む場合に使えます。pfb 形式の "european computer modern" フ
 ォント ("computer modern" フォントの一種) が各地の CTAN サーバに置かれ
 ています。
           ftp://ftp.dante.de/tex-archive/fonts/ps-type1/cm-super/
 例えば、ファイル "sfrm1000.pfb" は、中太、セリフ付き、立体の 10 ポイン
 トのフォント (フォント名 "SFRM1000") です。computer modern フォントは
 今でも数式を書くのに必要ですが、それは以下にあります:
           ftp://ftp.dante.de/tex-archive/fonts/cm/ps-type1/bluesky
 これらによって、TeX 用の任意の文字も使えます。しかし、computer modern
 フォントは少しエンコーディングがおかしくなっています (このため、文字列
 には cmr10.pfb の代わりに sfrm1000.pfb を使うべきです)。
 TeX フォントの使用法はいくつかのデモの一つで知ることができます。
 `gnuplot` のソース配布物の /docs/psdoc に含まれるファイル
 "ps_fontfile_doc.tex" に TeX 数学フォントの文字の一覧表が含まれていま
 す。

 フォント "CMEX10" (ファイル "cmex10.pfb") を埋め込むと、gnuplot は
 追加フォント "CMEX10-Baseline" も定義します。それは、他の文字にあうよ
 うに垂直方向にずらされたものです (CMEX10 は、記号の天辺にベースライン
 があります)。
?commands set terminal postscript prologue
?set terminal postscript prologue
?terminal postscript prologue
?postscript prologue
?prologue
 各 PostScript 出力ファイルは %%Prolog セクションを含みますし、例えば文
 字エンコーディングなどを含む追加ユーザ定義セクションを含むかもしれませ
 せん。これらのセクションは、gnuplot の実行ファイル中にコンパイルされて
 いる、あるいはあなたのコンピュータの別のところに保存されている
 PostScript prologue ファイル群からコピーされます。これらのファイルが置
 かれるデフォルトのディレクトリは、gnuplot のインストール時に設定されま
 すが、このデフォルトは gnuplot コマンドの `set psdir` を使うか、環境変
 数 GNUPLOT_PS_DIR を定義することで変更できます。以下参照: `set psdir`。
?commands set terminal postscript adobeglyphnames
?set terminal postscript adobeglyphnames
?terminal postscript adobeglyphnames
?postscript adobeglyphnames
?adobeglyphnames
 この設定は、UTF-8 エンコーディングでの PostScript 出力にのみ関係します。
 これは、0x00FF より大きい Unicode エントリポイント (つまり Latin1 集合
 外のすべて) の文字を記述するのに使われる名前を制御します。一般に、
 unicode 文字は一意の名前を持たず、それは unicode 識別番号しか持ちませ
 ん。しかし、Adobe は、ある範囲の文字 (拡張ラテン文字、ギリシャ文字等)
 に名前を割り当てる推奨規則を持っています。フォントによってはこの規則を
 利用しているものありますし、そうでないものもあります。gnuplot はデフォ
 ルトでは Adobe グリフ名を使用します。例えば、ギリシャ文字の小文字のア
 ルファは /alpha となります。`noadobeglyphnames` を指定した場合、この文
 字に対して gnuplot は代わりに /uni03B1 を使おうとします。
 この設定でおかしくなったとすれば、それはその文字がフォント内にあるにも
 かかわらずそれが見つからない場合です。Adobe フォントに対しては、デフォ
 ルトを使うのが常に正しいかもしれませんが、他のフォントでは両方の設定を
 試してみないといけないかもしれません。以下も参照: `fontfile`。


?commands set terminal pslatex
?set terminal pslatex
?set term pslatex
?terminal pslatex
?term pslatex
?pslatex
?commands set terminal pstex
?set terminal pstex
?set term pstex
?terminal pstex
?term pstex
?pstex
 `pslatex` ドライバは LaTeX で後処理される出力を生成し、`pstex` ドライ
 バは TeX で後処理される出力を生成します。`pslatex` は dvips と xdvi で
 認識可能な \special 命令を使用します。`pstex` で生成される図は、任意
 の plain-TeX ベースの TeX (LaTeX もそうです) で取り込むことができます。

 書式:
       set terminal [pslatex | pstex] {default}
       set terminal [pslatex | pstex]
                               {rotate | norotate}
                               {oldstyle | newstyle}
                               {auxfile | noauxfile}
                               {level1 | leveldefault | level3}
                               {color | colour | monochrome}
                               {background <rgbcolor> | nobackground}
                               {dashlength | dl <DL>}
                               {linewidth | lw <LW>} {pointscale | ps <PS>}
                               {rounded | butt}
                               {clip | noclip}
                               {palfuncparam <samples>{,<maxdeviation>}}
                               {size <XX>{unit},<YY>{unit}}
                               {<font_size>}

 以下のようなエラーメッセージが出た場合:
       "Can't find PostScript prologue file ... "
 以下参照: `postscript prologue`。そしてその指示に従ってください。

 オプション `color` はカラーを有効にし、`monochrome` は各要素を黒と白
 描画します。さらに、`monochrome` は灰色の `palette` も使用しますが、
 これは、明示的に `colorspec` で指定された部品の色を変更しません。

 `dashlength` または `dl` は点線の線分の長さを <DL> (0 より大きい実数)
 に設定し、
 `linewidth` または `lw` は全ての線の幅を <LW> に設定します。

 デフォルトでは、生成される PostScript コードは、特にフィルタリングや
 filledcurves のようなでこぼこな領域のパターン塗りつぶしにおいて、
 PostScript Level 2 として紹介されている言語機能を使います。PostScript
 Level 2 の機能は条件的に保護されていて、PostScript Level 1 のインター
 プリタがエラーを出さず、むしろメッセージか PostScript Level 1 による
 近似であることを表示するようになっています。`level1` オプションは、こ
 れらの機能を近似する PostScript Level1 で代用し、PostScript Level 2
 コードを一切使用しません。これは古いプリンタや、Adobe Illustrator の
 古いバージョンなどで必要になるかもしれません。このフラグ `level1` は
 出力された PostScript ファイルのある一行を手で編集することで、後から
 強制的に PostScript Level 1 機能を ON/OFF にすることもできます。level
 2 のコードが含まれている場合、上の機能は現われないか、このフラグがセ
 ットされた場合、あるいは PostScript インタプリタプログラムが level 2
 以上の PostScript を解釈するとは言わなかった場合に警告文に置き換わり
 ます。`level3` オプションは、ビットマップ画像の PNG 化の機能を有効に
 します。それにより出力サイズをかなり削減できます。

 `rounded` は、線の端や接合部を丸くし、デフォルトの `butt` は尖った端と
 角張った接合部を使用します。

 `clip` は、PostScript にすべての出力を BoundingBox (PostScript の外枠)
 でクリップすることを指示します; デフォルトは `noclip` です。

 `palfuncparam` は `set palette functions` から出力の傾きをどのようにコ
 ード化するかを制御します。解析的な色の成分関数 (`set palatte functions`
 で設定される) は、postscript 出力では傾きの線形補完を用いてコード化さ
 れます: まず色の成分関数が <samples> 個の点で標本化され、そしてそれら
 の点は、結果として線形補完との偏差が <maxdeviation> 以内に収まるように
 削除されます。ほとんど全ての有効なパレットで、デフォルトの <samples>
 =2000 と <maxdeviation>=0.003 の値をそのまま使うのが良いでしょう。

 PostScript 出力のデフォルトの大きさは 10 インチ x 7 インチです。EPS
 出力のデフォルトの大きさは 5 x 3.5 インチです。オプション `size` は
 これらをユーザが指定したものに変更します。デフォルトでは X と Y のサ
 イズの単位はインチとみなされますが、他の単位 (現在は cm のみ) も使う
 ことはできます。描画の BoundingBox (PostScript ファイルの外枠) は、
 サイズが変更された画像を丁度含むように正しく設定されます。
 スクリーン座標は、オプション `size` で指定された描画枠の全体が 0.0
 から 1.0 になります。
 注意: `これは、以前は、出力形式での設定よりも、コマンド set size で
 設定した方がいい、と言っていたことの変更を意味します`。以前の方法で
 は BoundingBox は変更されずに残ってしまい、スクリーン座標が実際の描
 画の限界に対応していませんでした。

 `rotate` が指定されると y 軸の見出しが回転されます。
 <font_size> は希望するフォントの (ポイント単位での) 大きさです。

 `auxfile` が指定されると、ドライバは PostScript コマンドを、LaTeX ファ
 イルに直接出力する代わりに、補助ファイルに書き出すようになります。これ
 は、dvips がそれを扱えないくらい大きいグラフである場合に有用です。補助
 PostScript ファイルの名前は、`set output` コマンドで与えられる TeX フ
 ァイルの名前から導かれるもので、それはその最後の `.tex` の部分 (実際の
 ファイル名の最後の拡張子の部分) を `.ps` で置き換えたもの、または、TeX
 ファイルに拡張子がないならば `.ps` を最後に付け足したものになります。
 `.ps` ファイルは \special{psfile=...} という命令で `.tex` ファイルに
 取り込まれます。`multiplot` モード以外では、次の描画を行なう前にその出
 力ファイルをクローズするのを忘れないでください。

 version 4.2 より前の gnuplot は ps(la)tex 出力形式では 5 x 3 インチの
 出力でしたが、現在では 5 x 3.5 インチになっています。これは postscript
 eps 出力形式に合わせた変更です。加えて、文字幅は、以前の epslatex 出力
 形式はフォントサイズの 50% と見なしましたが、現在は 60% と評価していま
 す。従来の形式に戻すには、オプション `oldstyle` を指定してください。

 pslatex ドライバは文字列の配置の制御に特別な方法を提供します:
 (a) '{' で始まる文字列は、'}' で閉じる必要がありますが、その文字列全体
 が LaTeX によって水平方向にも垂直方向にもセンタリングされます。
 (b) '[' で始まる文字列の場合は、位置の指定をする文字列 (t,b,l,r のうち
 2 つまで) が続き、次に ']{'、文字列本体、で最後に '}' としますが、この
 文字列は LaTeX が LR-box として整形します。\rule{}{} を使えばさらに良
 い位置合わせが可能でしょう。

 ここに記述されていないオプションは `Postscript terminal` のものと同一で
 すので、それらが何を行なうのかを知りたければそちらを参照してください。

 例:
       set term pslatex monochrome rotate       # デフォルトに設定
 PostScript コマンドを "foo.ps" に書き出す:
       set term pslatex auxfile
       set output "foo.tex"; plot ...; set output
 見出しの位置合わせに関して:
 gnuplot のデフォルト (大抵それなりになるが、そうでないこともある):
        set title '\LaTeX\ -- $ \gamma $'
 水平方向にも垂直方向にもセンタリング:
        set label '{\LaTeX\ -- $ \gamma $}' at 0,0
 位置を明示的に指定 (上に合わせる):
        set xlabel '[t]{\LaTeX\ -- $ \gamma $}'
 他の見出し -- 目盛りの長い見出しに対する見積り:
        set ylabel '[r]{\LaTeX\ -- $ \gamma $\rule{7mm}{0pt}}'

 線幅と点の大きさは `set style line` で変更できます。

?commands set terminal pstricks
?set terminal pstricks
?set term pstricks
?terminal pstricks
?term pstricks
?pstricks
 `pstricks` ドライバは LaTeX の "pstricks.sty" マクロパッケージと共に使
 われることを意図しています。これは `eepic` や `latex` ドライバに代わる
 選択肢の一つです。"pstricks.sty" は必要ですが、もちろん PostScript を
 解釈するプリンタ、または Ghostscript のような変換ソフトも必要です。

 PSTricks は anonymous ftp で Princeton.EDU の /pub ディレクトリから取
 得できます。このドライバは、PSTricks パッケージの全ての能力を使おうと
 などとは全く考えてはいません。

 書式:
       set terminal pstricks {hacktext | nohacktext} {unit | nounit}

 最初のオプションは、あまり綺麗ではない方法で数字のより良い出力を生成す
 るもので、2 つ目のオプションはグラフを伸縮する際には必要です。デフォル
 トでは `hacktext` と `nounit` です。
?commands set terminal qms
?set terminal qms
?set term qms
?terminal qms
?term qms
?qms
 `qms` ドライバは QMS/QUIC レーザープリンタ、Talaris 1200、その他をサポ
 ートします。オプションはありません。
?set terminal qt
?terminal qt
?set term qt
?term qt
?qt
 `qt` 出力形式は、Qt ライブラリを用いて別ウィンドウへの出力を生成します。

 書式:
         set term qt {<n>}
                     {size <width>,<height>}
                     {position <x>,<y>}
                     {title "title"}
                     {font <font>} {{no}enhanced}
                     {linewidth <lw>} {dashlength <dl>}
                     {{no}persist} {{no}raise} {{no}ctrl}
                     {close}
                     {widget <id>}

 複数の描画ウィンドウもサポートしていて、`set terminal qt <n>` とすれば
 番号 n の描画ウィンドウへ出力します。

 デフォルトのウィンドウタイトルは、このウィンドウ番号に基づいています。
 そのタイトルはキーワード "title" でも指定できます。

 描画ウィンドウは、`gnuplot` の出力形式を別なものに変更した後でも開いた
 まま残ります。描画ウィンドウは、そのウィンドウが入力フォーカスを持って
 いる状態で文字 'q' を打つか、ウィンドウマネージャメニューで `close` を
 選択するか、または `set term qt <n> close` とすることで閉じることができ
 ます。

 描画領域のサイズはピクセル単位で与えます、デフォルトは 640x480 です。
 それに加えて、ウィンドウの実際のサイズには、ツールバーやステータスバー
 用のスペースも追加されます。
 ウィンドウのサイズを変更すると、描画グラフもウィンドウの新しいサイズに
 ぴったり合うようにすぐに伸縮されます。`qt` 出力形式はフォント、線幅も含
 めて描画全体を伸縮しますが、全体のアスペクト比は一定に保ちます。
 その後 `replot` とタイプするか、ターミナルツールバーの `replot` アイコ
 ンをクリックするか、新たに `plot` コマンドを入力すると、その新しい描画
 では完全にそのウィンドウに合わせられますが、フォントサイズや線幅はそれ ぞれのデフォルトにリセットされます。

 position オプションは描画ウィンドウの位置を設定するのに使えます。これは
 コマンド `set term` 後の最初の描画にのみ適用されます。


 現在の描画ウィンドウ (`set term qt <n>` で選択されたもの) は対話型で、
 その挙動は、他の出力形式と共通です。詳細は、以下参照: `mouse`。それには
 追加のアイコンもいくつかついていますが、それらはそれ自体が説明的なもの
 になっているはずです。

 この出力形式は、拡張文字列処理モード (enhanced text mode) をサポートし
 ていて、フォントや書式コマンド (上付、下付など) をラベルや他の文字列に
 埋め込むことができます。拡張文字列処理モードの書式は、gnuplot の他の出
 力形式と共通です。詳細は、以下参照: `enhanced`。

 <font> は "FontFace,FontSize" の形式で、FontFace と FontSize とをコ
 ンマで分離して一つの文字列として書きます。FontFace は、'Arial' のよ
 うな通常のフォント名です。FontFace を与えない場合は、qt 出力形式は
 'Sans' を使用します。FontSize はポイント単位のフォントサイズです。
 FontSize を与えない場合は、qt 出力形式は 9 ポイントを使用します。
    例 :
       set term qt font "Arial,12"
       set term qt font "Arial" # フォント名のみ変更
       set term qt font ",12" # フォントサイズのみ変更
       set term qt font "" # フォント名、、フォントサイズをリセット

 dashlength は、点線/破線パターンのユーザ定義にのみ影響を与え、Qt が内部
 に持っているパターンには影響を与えません。

 可能な限り最も良い出力を生成するために、このレンダリングはアンチアリア
 ス、オーバーサンプリング、ヒンチングの 3 つの機構を持っています。
 オーバーサンプリングは、アンチエイリアスと組でピクセルよりも小さいサイ
 ズでの精度を提供し、gnuplot が非整数座標の直線を書けるようになります。
 これは、対角方向の直線 (例えば 'plot x') が左右に揺れるのを避けます。
 ヒンティングは、オーバーサンプリングによって引き起こされる水平、垂直方
 向の線分のぼかしを避けます。この出力形式は、これらの直線を整数座標に揃
 え、それにより、1 ピクセル幅の直線は本当に 1 つ (1 つより多くも少なく
 もない) のピクセルで描画します。

 デフォルトでは、描画が行われたときにウィンドウはデスクトップの一番上
 (最前面) に表示されます。これは、キーワード "raise" で制御できます。
 キーワード "persist" は、すべての描画ウインドウを明示的に閉じない間
 は、gnuplot が終了しないようにします。
 最後に、デフォルトでは <space> キーは gnuplot コンソールウィンドウを上
 に上げ (MS Windows のみ)、'q' は描画ウィンドウを閉じますが、キーワード
 "ctrl" は、それらのキー割り当てを <ctrl>+<space> と <ctrl>+'q' に変
 更します。

 プログラムのコンパイル時に選択した場所に、gnuplot の外部ドライバ
 gnuplot_qt がインストールされますが、環境変数 GNUPLOT_DRIVER_DIR を設定
 することで置き場所を変更することもできます。
?commands set terminal regis
?set terminal regis
?set term regis
?terminal regis
?term regis
?regis
 注意: 古い (legacy) 出力形式です。
 `regis` ドライバは REGIS グラフィック言語での出力を生成します。このド
 ライバには色を 4 色使うか (デフォルト) 16 色使うかのオプションがありま
 す。

 書式:
       set terminal regis {4 | 16}
?commands set terminal sixelgd
?set terminal sixelgd
?set term sixelgd
?terminal sixelgd
?term sixelgd
?sixelgd
 書式:
       set terminal sixelgd
              {{no}enhanced}
              {{no}transparent} {rounded|butt}
              {linewidth <lw>} {dashlength <dl>}
              {tiny | small | medium | large | giant}
              {font "<face> {,<pointsize>}"} {fontscale <scale>}
              {size <x>,<y>} {{no}crop} {animate}
              {background <rgb_color>}

 `sixel` 出力フォーマットは、元々 DEC のターミナル、プリンタで使われて
 いたものです。このドライバは、gd ライブラリを内部的に使用して作成した
 PNG 画像を変換して sixel 出力列を生成します。sixel 出力列は、それを作
 成したときにターミナル上に表示させることができますが、またはその出力列
 をファイルに書きだしておいて、後からそのファイルをターミナルに吐き出す
 ことで表示に置き換えることもできます。

 オプション `animate` は、連続する plot 命令で前のグラフが上にスクロー
 ルして消える代わりに、各 plot がスクリーンの同じ領域を上書きするように
 各 plot の開始時にカーソル位置をターミナルの左上にリセットします。これ
 は場所固定式アニメーション (in-place animation) の生成用の仕組みです。

 `transparent` は、ドライバに背景色の透明化 (transparent) を行うよう指
 示します。デフォルトは `notransparent` です。

 オプション `linewidth` と `dashlength` は拡大率で、描画されるすべての
 線に影響を与えます。すなわち、これらは様々な描画コマンドで要求される値
 にかけ算されます。

 デフォルトでは、sixel 出力は、番号付きの 16 色を使用します。オプション
 `truecolor` では、TrueColor PNG 画像を作成し、それを 256 色の sixel 画
 像出力に減色します。透過型塗り潰しスタイルには、オプション `truecolor`
 が必要です。以下参照: `fillstyle`。
 `transparent` の背景は、番号付きの色画像、TrueColor 画像のどちらでも可
 能です。

 `butt` は線分の描画で、その端の点でのはみだしを起こさない描画メソッド
 を使うようドライバに指示します。この設定は、線幅が 1 より大きい場合に
 のみ有効です。この設定は、水平線、垂直線の描画の場合に有用でしょう。
 デフォルトは `rounded` (丸め) です。

 フォントの選択の詳細は、やや複雑です。
 詳細は、以下参照: `fonts`。

 出力描画サイズ <x,y> はピクセル単位で与えます。デフォルトは 640x480 で
 す。以下も参照: `canvas`, `set size`。
 描画終了後の端の余白は、オプション `crop` で取り除くことができ、その結
 果としてその画像サイズは小さくなります。デフォルトは `nocrop` です。

 この出力形式は、xterm, mlterm, mintty ターミナルではテストされ、動作確
 認されています。最後の 2 つでは、256 色の sixel カラーを丸々使用する
 `truecolor` モードもサポートしますが、配布されている xterm は、sixel
 グラフィックスと 256 色をサポートするものであるかもしれませんし、そう
 でないかもしれません。
?commands set terminal svg
?set terminal svg
?set term svg
?terminal svg
?term svg
?svg
 このドライバは W3C SVG (Scalable Vector Graphics) フォーマットを生成し
 ます。

 書式:
       set terminal svg {size <x>,<y> {|fixed|dynamic}}
                        {mouse} {standalone | jsdir <dirname>}
                        {name <plotname>}
                        {font "<fontname>{,<fontsize>}"} {{no}enhanced}
                        {fontscale <multiplier>}
                        {rounded|butt|square} {solid|dashed} {linewidth <lw>}
                        {background <rgb_color>}

 ここで <x> と <y> は生成される SVG グラフのサイズですが、`dynamic` は
 svg ビューワに描画のリサイズを許し、`fixed` は絶対サイズを要求します
 (デフォルト)。

 `linewidth <w>` は図の中で使用される全ての線の幅を因子 <w> だけ増加さ
 せます。

 <font> はデフォルトとして使われるフォント名 (デフォルトでは Arial)、
 <fontsize> はポイント単位でのフォントサイズ (デフォルトは 12) です。
 svg ビューワソフトは、そのファイルの表示の際には別の代用フォントを使う
 ことになるでしょう。

 拡張文字列処理 (enhanced) モードの書式指定は、他の出力形式の場合と同じ
 です。詳細は、以下参照: `enhanced`。

 オプション `mouse` は、マウストラッキング機能と、対応する key 上でクリ
 ックすることでそれぞれのグラフの描画を On/Off にする機能をサポートを追
 加することを gnuplot に指示します。デフォルトではローカルディレクトリ、
 通常は /usr/local/share/gnuplot/<version>/js 内のあるスクリプトを指すリ
 ンクを取り込むことで行われますが、オプション `jsdir` に別のローカルディ
 レクトリか、通常の URL を指定することでこれは変更できます。SVG 画像を
 Web ページに入れるのであれば、普通は後者の URL の方を指定します。一方で
 オプション `standalone` は、マウス操作プログラムを SVG 文書自体に埋め込
 み、外部リソースへのリンクは行いません。

 SVG ファイルを何かの外部ファイルと組み合わせて利用したい場合、例えばそ
 れがある Web ページや親文書の javascriptコードから参照されているような
 場合、他の SVG グラフへの参照との衝突を避けるために一意的な名前が必要に
 なります。その場合はオプション `name` を使って固有の名前を確保してくだ
 さい。

?commands set terminal svga
?set terminal svga
?set term svga
?terminal svga
?term svga
?svga
 古い (legacy) 出力形式です。`svga` ドライバは SVGA グラフィックの PC を
 サポートします。これは DJGPP でコンパイルされた場合のみ使うことができま
 す。

 書式:
       set terminal svga {"<fontname>"}
?commands set terminal tek40xx
?set terminal tek40xx
?set term tek40xx
?terminal tek40xx
?term tek40xx
?tek40
?commands set terminal vttek
?set terminal vttek
?set term vttek
?terminal vttek
?term vttek
?vttek
?commands set terminal xterm
?set terminal xterm
?set term xterm
?terminal xterm
?term xterm
?xterm
 このドライバ群は VT-ライクな端末のいくつかをサポートします。`tek40xx`
 は Tektronix 4010 とその他ほとんどの TEK エミュレータをサポートします。
 `vttek` は VT-ライクな tek40xx 端末エミュレータをサポートします。
 以下のものは、gnuplot のコンパイル時に選択されたもののみが利用できます:
 `kc-tek40xx` はカラーの MS-DOS Kermit Tek4010 ターミナルエミュレータを、
 `km-tek40xx` はその白黒版をサポートします。
 `selanar` は Selanar グラフィック端末をサポートします。
 `bitgraph` は BBN Bitgraph 端末をサポートします。
 いずれもオプションはありません。
?commands set terminal tek410x
?set terminal tek410x
?set term tek410x
?terminal tek410x
?term tek410x
?tek410x
 `tek410x` ドライバは Tektronix 410x, 420x ファミリーをサポートしていま
 す。オプションはありません。
?commands set terminal texdraw
?set terminal texdraw
?set term texdraw
?terminal texdraw
?term texdraw
?texdraw
 `texdraw` ドライバは LaTeX texdraw 環境をサポートします。それは texdraw
 パッケージの "texdraw.sty" と "texdraw.tex" と共に使用されることを仮定
 しています。

 数ある中で、点 (point) は、LaTeX のコマンド "\Diamond", "\Box" などを
 使って描かれます。これらのコマンドは現在は LaTeX2e のコアには存在せず
 latexsym パッケージに含まれていますが、このパッケージ基本配布の一部で
 あり、よって多くの LaTeX のシステムの一部になっています。このパッケー
 ジを使うことを忘れないでください。

 オプションはありません。
?commands set terminal tgif
?set terminal tgif
?set term tgif
?terminal tgif
?term tgif
?tgif
 Tgif は X11 ベースのドローツールです --- ただし、これは GIF に関して何
 かするわけではありません。

 `tgif` ドライバは、フォント指定、フォントサイズ指定、1 ページ内の複数の
 グラフ描画をサポートしています。軸の比率は変更されません。

 書式:
       set terminal tgif {portrait | landscape | default} {<[x,y]>}
                         {monochrome | color}
                         {{linewidth | lw} <LW>}
                         {solid | dashed}
                         {font "<fontname>{,<fontsize>}"}

 <[x,y]> にはそのページ内の x 方向、y 方向のグラフの数を指定し、
 `color` はカラー機能を有効にし、`linewidth` は全ての線幅を <LW> 倍し、
 "<fontname>" には有効な PostScript フォント名、<fontsize> はその
 PostScript フォントの大きさを指定します。`defaults` は全てのオプション
 の値をデフォルトの値にセットします。デフォルトは `portrait`, `[1,1]`,
 `color`, `linewidth 1.0`, `dashed`, `"Helvetica,18"` です。

 `solid` オプションは、編集作業中にそうであるように、線がカラーである場
 合に普通使われます。ハードコピーは白黒になることが多いので、その場合は
 `dashed` を選択すべきでしょう。

 多重描画 (multiplot) は 2 種類の方法で実装されています。

 その一つは、標準的な gnuplot の多重描画のやり方です:

       set terminal tgif
       set output "file.obj"
       set multiplot
       set origin x01,y01
       set size  xs,ys
       plot ...
            ...
       set origin x02,y02
       plot ...
       unset multiplot

 より詳しい情報については、以下参照: `set multiplot`。

 もう一つの方法はドライバの [x,y] オプションです。この方法の長所は、原
 点 (origin) や大きさ (size) の設定をしなくても全てのグラフが自動的に縮
 尺され配置されることです。グラフの比 x/y は、自然な比 3/2 (または `set
 size` で設定されたもの) が保持されます。

 両方の多重描画の実装が選択された場合、標準的なやり方の方が選択され、警
 告のメッセージが表示されます。

 単一描画 (または標準的な多重描画) の例:
       set terminal tgif                  # デフォルト
       set terminal tgif "Times-Roman,24"
       set terminal tgif landscape
       set terminal tgif landscape solid

 ドライバの持つ多重描画の仕組みを利用する例:
       set terminal tgif portrait [2,4]  # 縦置、x-方向に 2 つ、y-方向
                                         # に 4 つのグラフ描画
       set terminal tgif [1,2]           # 縦置、x-方向に 1 つ、y-方向
                                         # に 2 つのグラフ描画
       set terminal tgif landscape [3,3] # 横置、両方の方向に 3 つのグ
                                         # ラフ描画
?commands set terminal tikz
?set terminal tikz
?set term tikz
?terminal tikz
?term tikz
?tikz
 このドライバは、TeX のグラフィックマクロの TikZ パッケージとともに使用
 する出力を生成します。現在は、外部 lua script によって実装されていて、
 `set term tikz` は `set term lua tikz` の省略形です。詳細は以下参照:
 `term lua`。出力形式のオプションを表示させるには、`set term tikz help`
 を使用してください。
?commands set terminal tkcanvas
?set terminal tkcanvas
?set term tkcanvas
?terminal tkcanvas
?term tkcanvas
?tkcanvas
 このドライバは、以下のスクリプト言語のうちの一つの Tk canvas widget コ
 マンドを生成します: Tcl (デフォルト), Perl, Python, Ruby, REXX。

 書式:
       set terminal tkcanvas {tcl | perl | perltkx | python | ruby | rexx}
                             {standalone | input}
                             {interactive}
                             {rounded | butt}
                             {nobackground | background <rgb color>}
                             {{no}rottext}
                             {size <width>,<height>}
                             {{no}enhanced}
                             {externalimages | pixels}

 結果を表示するには、以下の Tcl/Tk コマンド列を実行します:

       package require Tk
       # 以下の 2 行は、外部画像を使用する場合にのみ必要
       package require img::png
       source resize.tcl
       source plot.tcl
       canvas .c -width 800 -height 600
       pack .c
       gnuplot .c

 Perl/Tk の場合は、以下のようにします:

       use Tk;
       my $top = MainWindow->new;
       my $c = $top->Canvas(-width => 800, -height => 600)->pack;
       my $gnuplot = do "plot.pl";
       $gnuplot->($c);
       MainLoop;

 Perl/Tkx の場合は、以下のようにします:

       use Tkx;
       my $top = Tkx::widget->new(".");
       my $c = $top->new_tk__canvas(-width => 800, -height => 600);
       $c->g_pack;
       my $gnuplot = do "plot.pl";
       $gnuplot->($c);
       Tkx::MainLoop();

 Python/Tkinter の場合は、以下のようにします:

       from tkinter import *
       from tkinter import font
       root = Tk()
       c = Canvas(root, width=800, height=600)
       c.pack()
       exec(open('plot.py').read())
       gnuplot(c)
       root.mainloop()

 Ruby/Tk の場合は、以下のようにします:

       require 'tk'
       root = TkRoot.new { title 'Ruby/Tk' }
       c = TkCanvas.new(root, 'width'=>800, 'height'=>600) { pack  { } }
       load('plot.rb')
       gnuplot(c)
       Tk.mainloop

 Rexx/Tk の場合は、以下のようにします:

       /**/
       call RxFuncAdd 'TkLoadFuncs', 'rexxtk', 'TkLoadFuncs'
       call TkLoadFuncs
       cv = TkCanvas('.c', '-width', 800, '-height', 600)
       call TkPack cv
       call 'plot.rex' cv
       do forever
           cmd = TkWait()
           if cmd = 'AWinClose' then leave
           interpret 'call' cmd
       end

 `gnuplot` が生成するコード (上の例では、"plot.<ext>" として書き出され
 ているものです) は、以下のような手続き関数を含んでいます:

 gnuplot(canvas)
    引数として canvas の名前を取ります。
    これを呼び出すと、その canvas をクリアし、canvas のサイズを探し、そ
    の中にグラフを描き、それに合うように伸縮します。

 gnuplot_plotarea()
    canvas スクリーン座標での描画領域の境界 (xleft, xright, ytop, ybot)
    を含むリストを返します。
    2 次元グラフ描画 (`plot`) に対してのみ動作します。

 gnuplot_axisranges()
    グラフ座標での 2 つの軸の範囲 (x1min, x1max, y1min, y1max, x2min,
    x2max, y2min, y2max) を返します。
    2 次元グラフ描画 (`plot`) に対してのみ動作します。

 オプション `standalone` を使えば、自己完結した最小スクリプトを生成でき
 ます。デフォルトは `input` で、これは取り込まれるべきスクリプトを作りま
 す (すなわち、load されるか call されるか、または選択した言語用のなんら
 かの適切な方法で)。

 オプション `interactive` を指定すると、一つの線分上でマウスクリックした
 ときにその中点の座標が標準出力に出力されるようになります。
 この動作は、user_gnuplot_coordinates という手続き関数を定義することで、
 別なものに置き換えることも可能です。その手続き関数には以下の引数が渡さ
 れます:
   win id x1s y1s x2s y2s x1e y1e x2e y2e x1m y1m x2m y2m,
 これらは、canvas の名前、線分の id、2 つの座標系でのその線分の開始点の
 座標、終了点の座標、中点の座標です。中点の座標は、対数軸に対してのみ与
 えられます

 デフォルトでは、canvas は `transparent` ですが、オプション `background`
 で、明示的に背景色を設定することもできます。

 `rounded` は、線の端や接合部を丸くします。
 デフォルトの `butt` は、尖った端と角張った接合部を使用します。

 オプション `rottext` で、文字列の任意角での回転を有効にできますが、それ
 には Tcl/Tk 8.6 以降が必要です。デフォルトは `norottext` です。

 オプション `size` は、目盛りの刻みとフォントサイズを、指定された canvas
 サイズに対して最適化なものにしようとします。デフォルトでは、出力サイズ
 は 800 x 600 ピクセルとしています。

 `enhanced` は、拡張文字列処理を選択します (デフォルト) が、これは今のと
 ころ Tcl でのみ利用可能です。

 オプション `pixels` (デフォルト) は、フェールセーフなピクセル毎の画像処
 理ルーチンを選択します。以下参照: `image pixels`。
 オプション `externalimages` は、画像を外部 PNG 画像として保存し、それを
 あとで tkcanvas コードが読み込んで伸縮します。このオプションは、Tcl で
 のみ有効で、しかも Tk の画像処理ルーチンが任意の伸縮を提供していないた
 めに、ある状況では遅くなります。この場合、スクリプトで、提供される
 rescale.tcl を取り込まなければいけません。

 対話型モードは、Python/Tk, Rexx/Tk ではまだ実装されていません。Ryby/Tk
 の対話型モードは、まだ user_gnuplot_coordinates をサポートしていません。
?commands set terminal tpic
?set terminal tpic
?set term tpic
?terminal tpic
?term tpic
?tpic
 `tpic` ドライバは tpic \special での LaTeX picture 環境の描画をサポー
 トします。 これは `latex` や `eepic` ドライバに代わる別な選択肢です。
 点の大きさ (pointsize)、線の幅 (linewidth)、点線の点の間隔 (interval)
 に関するオプションがあります。

 書式:
       set terminal tpic <pointsize> <linewidth> <interval>

 `pointsize` と `linewidth` は整数でミリインチ単位、`interval` は実数で
 単位はインチです。正でない値を指定するとデフォルトの値が使われます。デ
 フォルトでは pointsize = 40, linewidth = 6, interval = 0.1 です。

 LaTeX に関する全てのドライバは文字列の配置の制御に特別な方法を提供しま
 す: '{' で始まる文字列は、'}' で閉じる必要がありますが、その文字列全体
 が LaTeX によって水平方向にも垂直方向にもセンタリングされます。'[' で
 始まる文字列の場合は、位置の指定をする文字列 (t,b,l,r のうち 2 つまで)
 が続き、次に ']{'、文字列本体、で最後に '}' としますが、この文字列は
 LaTeX が LR-box として整形します。\rule{}{} を使えばさらに良い位置合わ
 せが可能でしょう。

 例:
 見出しの位置合わせに関して:
 gnuplot のデフォルト (大抵それなりになるが、そうでないこともある):
        set title '\LaTeX\ -- $ \gamma $'
 水平方向にも垂直方向にもセンタリング:
        set label '{\LaTeX\ -- $ \gamma $}' at 0,0
 位置を明示的に指定 (上に合わせる):
        set xlabel '[t]{\LaTeX\ -- $ \gamma $}'
 他の見出し -- 目盛りの長い見出しに対する見積り:
        set ylabel '[r]{\LaTeX\ -- $ \gamma $\rule{7mm}{0pt}}'
?commands set terminal vgagl
?set terminal vgagl
?set term vgagl
?terminal vgagl
?term vgagl
?vgagl
 非推奨 (gnuplot の次のリリースでは削除予定)。
 ドライバ `vgagl` はマウスと pm3d を完全にサポートした、linux の高速な
 コンソールドライバです。デフォルトモードの設定には 環境変数
 SVGALIB_DEFAULT_MODE を参照しますが、設定されていない場合は 256 色モー
 ドで有効な解像度のうち最も高いものを選択します。

 書式:
    set terminal vgagl \
                 background [red] [[green] [blue]] \
                 [uniform | interpolate] \
                 [mode]

 カラーモードは mode オプションで与えることもできます。G1024x768x256 の
 ような記号的名称や整数で与えることができます。オプション `background`
 は [0, 255] の範囲の整数 1 つ、または 3 つの組を取ります。整数 1 つの
 場合はそれは背景の灰色の値と見なされ、3 つの組の場合はそれに対応した色
 が背景に取られます。
 相互に排他的なオプション `interpolate` と `uniform` は、三角形の塗りつ
 ぶしの際に色の補間が行うかどうか (デフォルトでは ON) を制御します。

 高解像度モードを得るには、多分 libvga の設定ファイル (通常
 /etc/vga/libvga.conf) を修正する必要があるでしょう。VESA fb を使うのは
 良い選択ですが、それはカーネルのコンパイルが必要です。

 vgagl ドライバは、以下のリストのうちの *有効な* vga モードの最初のもの
 を使用します。
  - vgagl の設定時に与えられるモード、例えば `set term vgagl G1024x768x256`
    は最初に G1024x768x256 モードが有効かどうかチェックします。
  - 環境変数 SVGALIB_DEFAULT_MODE
  - G1024x768x256
  - G800x600x256
  - G640x480x256
  - G320x200x256
  - G1280x1024x256
  - G1152x864x256
  - G1360x768x256
  - G1600x1200x256

?commands set terminal VWS
?set terminal VWS
?set term VWS
?terminal VWS
?term VWS
?VWS
 注意: 古い (legacy) 出力形式です。
 `VWS` ドライバは VAX ウィンドウシステムをサポートします。オプションは
 ありません。このドライバはディスプレイの状態 (白黒か、グレイスケールか
 カラーか) を自動検知します。全ての線種は実線で描画されます。
?commands set terminal windows
?set terminal windows
?set term windows
?terminal windows
?term windows
?windows
 出力形式 `windows` は、グラフ描画と文字列描画に Windows GDI を使用する
 高速な対話型出力ドライバです。Windows では、複数の環境で動作する `wxt`
 出力形式、`qt` 出力形式もサポートされています。

 書式:
       set terminal windows {<n>}
                            {color | monochrome}
                            {solid | dashed}
                            {rounded | butt}
                            {enhanced | noenhanced}
                            {font <fontspec>}
                            {fontscale <scale>}
                            {linewdith <scale>}
                            {pointscale <scale>}
                            {background <rgb color>}
                            {title "Plot Window Title"}
                            {size <width>,<height>}
                            {position <x>,<y>}
                            {docked {layout <rows>,<cols>} | standalone}
                            {close}

 複数のウィンドウ描画がサポートされています: `set terminal win <n>` で
 出力が番号 n の描画ウィンドウに送られます。

 `color`, `monochrome` は、カラー出力か白黒出力かの選択で、
 `dashed` と `solid` は、点線と実線の選択です。`color` では `solid` が
 デフォルトで、`monochrome` では `dashed` がデフォルトです。
 `rounded` は、線の端や接合部を丸くし、デフォルトの `butt` は尖った端と
 角張った接合部を使用します。
 `enhanced` は拡張文字列処理 (enhanced text mode) の機能 (上付、下付文字
 やフォントの混在) を有効にします。詳細は以下参照: `enhanced text`。
 `<fontspec>` は "<fontface>,<fontsize>" の形式で、"<fontface>" は有
 効な Windows のフォント名で、`<fontsize>` はポイント単位でのフォントの
 大きさです。この両要素はいずれも省略可能です。
 以前の版の gnuplot では、`font` キーワードは省略可能で、<fontsize> は引
 用符なしの数値で与えることができましたが、現在はその形式はサポートして
 いませんので注意してください。
 `linewidth`, `fontscale`, `pointscale` で、線の幅、文字サイズ、点記号の
 大きさを伸縮できます。
 `title` は、グラフウィンドウのタイトルを変更します。
 `size` はウィンドウ内の描画領域のピクセル単位での幅と高さを、`wsize` は
 ウィンドウ自身の実際のサイズを、`position` はウィンドウの原点、すなわち
 左上角のスクリーン上のピクセル単位での位置を定義します。これらのオプシ
 ョンは、ファイル `wgnuplot.ini` のデフォルトの設定を上書きします。

 `docked` は、グラフウィンドウを、wgnuplot のテキストウィンドウの中に埋
 め込み、`size` と `position` のオプションを無視します。`docked` は、コ
 ンソール版の gnuplot では利用できないことに注意してください。このオプシ
 ョンを設定すると、新規のウィンドウに対してデフォルトの値を変更します。
 最初のデフォルトは、`standalone` です。ドッキングモードでは、グラフの最
 小列数、行数は追加オプション `layout` で保持できます。指定されたレイア
 ウト以上にグラフがある場合は、行を追加します。複数のグラフは、数値 ID
 でソートし、行方向に埋めていきます。

 他のオプションもグラフメニューや初期化ファイル `wgnuplot.ini` で変更で
 きます。

 Windows 版は、非対話型モードでは通常、コマンドラインから与えたファイル
 の最後に達すると直ちに終了しますが、コマンドラインの最後に `-` を指定
 した場合は別です。また、このモードではテキストウィンドウは表示せず、グ
 ラフのみの表示となりますが、オプションとして `-persist` (x11 版の
 gnuplot と同じオプション; 従来の Windows のみのオプション `/noend` や
 `-noend` を使うこともできます) を指定すると gnuplot は終了しなくなりま
 す。この場合他の OS での gnuplot の挙動とは異なり、-persist オプション
 後も gnuplot の対話型コマンドラインを受け付けます。

 コマンド `set term` で gnuplot の出力形式を変更した場合、描画ウィンドウ
 はそのまま残りますが、`set term windows close` で描画ウィンドウを閉じる
 ことができます。

 `gnuplot` は、Windows 上での出力の生成のためのいくつかの方法をサポート
 しています。以下参照: `windows printing`。windows 出力形式は、クリップ
 ボードや EMF ファイルを通して他のプログラムとのデータの交換をサポートし
 ています。以下参照: `graph-menu`。EMF ファイルを生成するには、`emf` 出
 力形式を使うこともできます。
?commands set terminal windows graph-menu
?set terminal windows graph-menu
?set term windows graph-menu
?windows graph-menu
?graph-menu
 `gnuplot graph` ウィンドウでマウスの右ボタン(*) を押すか、システムメニ
 ューやツールバーから `Options` を選択すると以下のオプションを持つポップ
 アップメニューが現われます:

 `Copy to Clipboard` クリップボードにビットマップや EMF 画像をコピー

 `Save as EMF...` 現在のグラフウィンドウをメタファイル (EMF か EMF+) と
 して保存

 `Save as Bitmap...` 現在のグラフをビットマップファイルとして保存

 `Print...` グラフィックウィンドウを Windows プリンタドライバでプリント
 アウト。プリンタと拡大率の選択が可能。以下も参照: `windows printing`。

 `Bring to Top` チェックを入れるとグラフウィンドウを他の全ての描画ウィン
 ドウの手前に表示

 `Color` チェックを入れるとカラー出力が有効、チェック無しだとすべて灰色
 階調表示。これは例えば白黒のプリントアウトの見た目の確認に有用です。

 `GDI backend` Windows GDI を使うスクリーン描画。これは古典的な windows
 出力形式の方法で、高速ですが、アンチエイリアス、オーバーサンプリング、
 完全な透過機能などの多くの機能を持っていません。現在は非推奨です。

 `GDI+ backend` GDI+ Windows API を使うスクリーン描画。これは、アンチエ
 イリアス、オーバーサンプリング、透過、点線/破線パターンのカスタマイズの
 すべてを完全にサポートします。現在はこれが一番望ましいです。

 `Direct2D backend` Direct2D と DirectWrite API を使用する描画。これは、
 グラフィックカード加速機能を使用し、よって通常は最も高速です。印刷や保
 存、クリップボードへのコピーには GDI+ を使用します。
 これは、そのうちにデフォルトのバックエンドとなるでしょうが、現在はまだ
 試験段階です。

 `Oversampling` これにより、対角線は非整数のピクセル位置に描画され、左右
 にふらつくことが避けられます。しかし鉛直線、水平線は、ぼやけた線になら
 ないよう整数のピクセル位置に置かれます。

 `Antialiasing` 折れ線や線の端の平滑化を可能にします。これは描画を遲くす
 ることに注意してください。
 `Antialiasing of polygons` 多角形描画のアンチエイリアスは、デフォルトで
 は有効ですが、GDI+ のバックエンドでは描画を遅くする可能性があります。

 `Fast rotation` グラフウィンドウをマウスで回転している際にアンチエイリ
 アスを一時的にオフにします。これは、マウスボタンを離した後に追加の再描
 画が行われますが、相当に描画を早くしてくれます。

 `Background...` ウィンドウ背景色の設定

 `Choose Font...` グラフィックウィンドウで使うフォントの選択

 `Update wgnuplot.ini` 現在のウィンドウの位置、ウィンドウの大きさ、テキ
 ストウィンドウのフォントとそのフォントサイズ、グラフウィンドウのフォン
 トとそのフォントサイズ、背景色を初期化ファイル `wgnuplot.ini` に保存

 (*) このメニューは、`unset mouse` によって右マウスボタン押ししか使えな
 くなるので注意。
?commands set terminal windows printing
?set terminal windows printing
?set term windows printing
?windows printing
?printing
?screendump
 好みにより、グラフは以下のような方法で印刷できます。

 `1.` `gnuplot` のコマンド `set terminal` でプリンタを選択し、`set output`
 で出力をファイルにリダイレクト

 `2.` `gnuplot graph` ウィンドウから `Print...` コマンドを選択。テキス
 トウィンドウからこれを行なう特別なコマンド `screendump` もある。

 `3.` `set output "PRN"` とすると出力は一時ファイルに出力され、`gnuplot`
 を終了するかまたは `set output` コマンドで出力を他のものへ変更すると、
 ダイアログ (対話) ボックスが現われ、そこでプリンタポートを選択。そこで
 OK を選択すると、出力はプリントマネージャでは加工されずにそのまま選択
 されたポートでプリントアウトされる。これは偶然 (または故意) に、あるプ
 リンタ用の出力を、それに対応していないプリンタに送り得ることを意味する。

?commands set terminal windows text-menu
?set terminal windows text-menu
?set term windows text-menu
?windows text-menu
?text-menu
 `gnuplot text` ウィンドウでマウスの右ボタンを押すか、システムメニュー
 から `Options` を選択すると以下のオプションを持つポップアップメニュー
 が現われます:

 `Copy to Clipboard` マークしたテキストをクリップボードにコピー

 `Paste` 打ち込んだのと同じようにクリップボードからテキストをコピー

 `Choose Font...` テキストウィンドウで使うフォントの選択

 `System Colors` 選択するとコントロールパネルで設定したシステムカラーを
 テキストウィンドウに与える。選択しなければ白背景で文字は黒か青。

 `Wrap long lines` 選択すると現在のウィンドウ幅よりも長い行を折り返す

 `Update wgnuplot.ini` 現在の設定を、ユーザのアプリケーションデータディ
 レクトリにある初期化ファイル `wgnuplot.ini` に保存

?windows wgnuplot.mnu
?wgnuplot.mnu
 メニューファイル `wgnuplot.mnu` が `gnuplot` と同じディレクトリにある場
 合、`wgnuplot.mnu` に書かれているメニューが読み込まれます。メニューコマ
 ンドは以下の通り:

  [Menu]      次の行の名前で新しいメニューを開始
  [EndMenu]   現在のメニューを終了
  [--]        水平なメニューの仕切りを入れる
  [|]         垂直なメニューの仕切りを入れる
  [Button]    メニューに押しボタンを入れ、それに次のマクロを割り当てる

 マクロは 2 行で書き、最初の行はマクロ名 (メニューの見出し)、2 行目がマ
 クロ本体です。先頭の空白列は無視されます。マクロコマンドは以下の通り:

 [INPUT]     [EOS] か {ENTER} までをプロンプトとして出力し文字列を入力
 [EOS]       文字列の終り (End Of String)。何も出力しない
 [OPEN]      開くファイル名を取得。最初の [EOS] までが対話ウィンドウのタ
             イトル、そこから次の [EOS] か {ENTER} までがデフォルトのフ
             ァイル名
 [SAVE]      セーブファイル名を取得 ([OPEN] 同様)
 [DIRECTORY] ディレクトリ名を取得。[EOS] か {ENTER} までが対話ウィンドウ
             のタイトル
 マクロ文字の置き換えは以下の通り:

  {ENTER}     復帰 '\r'
  {TAB}       タブ '\011'
  {ESC}       エスケープ '\033'
  {^A}        '\001'
  ...
  {^_}        '\031'

 マクロは展開後の文字数が最大 256 文字に制限されています。

?commands set terminal windows wgnuplot.ini
?set terminal windows wgnuplot.ini
?set term windows wgnuplot.ini
?windows wgnuplot.ini
?wgnuplot.ini
 Windows テキストウィンドウと `windows` 出力形式は、オプションのいくつか
 `wgnuplot.ini` の `[WGNUPLOT]` セクションから読み込みます。このファイル
 は、ユーザのアプリケーションデータディレクトリに置きます。
 `wgnuplot.ini` ファイルのサンプル:

       [WGNUPLOT]
       TextOrigin=0 0
       TextSize=640 150
       TextFont=Consolas,9
       TextWrap=1
       TextLines=400
       TextMaximized=0
       SysColors=0
       GraphOrigin=0 150
       GraphSize=640 330
       GraphFont=Tahoma,10
       GraphColor=1
       GraphToTop=1
       GraphGDI+=1
       GraphD2D=0
       GraphGDI+Oversampling=1
       GraphAntialiasing=1
       GraphPolygonAA=1
       GraphFastRotation=1
       GraphBackground=255 255 255
       DockVerticalTextFrac=350
       DockHorizontalTextFrac=400


 以下の設定は wgnuplot のテキストウィンドウのみに適用されます。

 `TextOrigin` と `TextSize` は、テキストウィンドウの位置とサイズの指定
 です。`TextMaximized` が 0 でない場合、ウィンドウは最大化されます。

 `TextFont` は、テキストウィンドウのフォントとサイズの指定です。

 `TextWrap` は、長いテキスト行の折り返しを選択します。

 `TextLines` は、テキストウィンドウの内部バッファに何行 (折り返しなし)
 保持するかを指定します。現在は、この値を wgnuplot 内からは変更できませ
 ん。

 以下参照: `text-menu`。


 `DockVerticalTextFrac` と `DockHorizontalTextFrac` は、それぞれ千分率単
 位での、テキストウィンドウ内に垂直方向、水平方向に確保される割合です。


 `GraphFont` は、フォント名とポイント単位のフォントサイズの指定です。

 以下参照: `graph-menu`。
?set terminal wxt
?terminal wxt
?set term wxt
?term wxt
?wxt
 `wxt` 出力形式は、個々のウィンドウへの出力を生成します。ウィンドウは
 wxWidgets ライブラリで生成されます (これが `wxt` の名前の由来です)。実
 際の描画は、2D グラフィックライブラリ cairo と、文字列配置/レンダリン
 グライブラリ pango が処理します。

 書式:
         set term wxt {<n>}
                      {size <width>,<height>} {position <x>,<y>}
                      {background <rgb_color>}
                      {{no}enhanced}
                      {font <font>} {fontscale <scale>}
                      {title "title"}
                      {linewidth <lw>}
                      {dashlength <dl>}
                      {{no}persist}
                      {{no}raise}
                      {{no}ctrl}
                      {close}

 複数の描画ウィンドウもサポートしていて、`set terminal wxt <n>` とすれば
 番号 n の描画ウィンドウへ出力します。

 デフォルトのウィンドウタイトルは、このウィンドウ番号に基づいています。
 そのタイトルは "title" キーワードでも指定できます。

 描画ウィンドウは、`gnuplot` の出力形式を別なものに変更しても残ったまま
 になります。それを閉じるには、そのウィンドウに入力フォーカスがある状態
 で 'q' を入力するか、ウィンドウマネージャのメニューで `close` を選択す
 るか、`set term wxt <n> close` としてください。

 描画領域のサイズはピクセル単位で与えます。デフォルトは 640x384 です。
 それに加えて、ウィンドウの実際のサイズには、ツールバーやステータスバー
 用のスペースも追加されます。
 ウィンドウのサイズを変更すると、描画グラフもウィンドウの新しいサイズに
 ぴったり合うようにすぐに伸縮されます。他の対話型出力形式と違い、`wxt`
 出力形式はフォント、線幅も含めて描画全体を伸縮しますが、全体のアスペク
 ト比は一定に保って、空いたスペースは灰色で塗り潰します。その後 `replot`
 とタイプするかターミナルツールバーの `replot` アイコンをクリックするか
 新たに `plot` コマンドを入力すると、その新しい描画では完全にそのウィン
 ドウに合わせられますが、フォントサイズや線幅はそれぞれのデフォルトにリ
 セットされます。

 position オプションは描画ウィンドウの位置を設定するのに使えます。これは
 コマンド `set term` 後の最初の描画にのみ適用されます。

 現在の描画ウィンドウ (`set term wxt <n>` で選択されたもの) は対話的で
 その挙動は、他の出力形式と共通です。詳細は、以下参照: `mouse`。それに
 は追加のアイコンもいくつかついていますが、それらはそれ自体が説明的なも
 のになっているはずです。

 この出力形式は、拡張文字列処理モード (enhanced text mode) をサポートし
 ていて、フォントや書式コマンド (上付、下付など) をラベルや他の文字列に
 埋め込むことができます。拡張文字列処理モードの書式は他の gnuplot の出
 力形式と共通です。詳細は、以下参照: `enhanced`。

 <font> は "FontFace,FontSize" の形式で、FontFace と FontSize とをコ
 ンマで分離して一つの文字列として書きます。FontFace は、'Arial' のよ
 うな通常のフォント名です。FontFace を与えない場合は、wxt 出力形式は
 'Sans' を使用します。FontSize は、ポイント単位のフォントサイズです。
 FontSize を与えない場合は、wxt 出力形式は 10 ポイントを使用します。
    例:
       set term wxt font "Arial,12"
       set term wxt font "Arial" # フォント名のみ変更
       set term wxt font ",12" # フォントサイズのみ変更
       set term wxt font "" # フォント名、フォントサイズをリセット

 フォントは通常のフォントサブシステムから取得します。MS-Windows 上では
 コントロールパネルの "Fonts" エントリで検索されるので、そこに設定し
 ます。Unix 上では、フォントは "fontconfig" が処理します。

 文字列のレイアウトに使用される pango ライブラリは utf-8 を基本としてい
 ますので、wxt 出力形式ではエンコーディングを utf-8 にする必要がありま
 す。デフォルトの入力エンコーディングは、システムの 'locale' によりま
 す。他のエンコーディングを使用したい場合は、それを gnuplot に知らせる
 必要があります。詳細は、以下参照: `encoding`。

 pango は、unicode マッピングでないフォントに対しては予期せぬ結果を与え
 るかもしれません。例えば Symbol フォントに対しては、wxt 出力形式は、文
 字コードを unicode に変換するために http://www.unicode.org/ で提供され
 るマッピングを利用します。pango は、その文字を含むフォントを見つけるた
 めにあなたの Symbol フォントを検索し、そして DejaVu フォントのように、
 幅広く unicode をカバーする他のフォントを探す、といった最善の作業を行
 おうとします。なお、"the Symbol font" は、Acrobat Reader と一緒に
 "SY______.PFB" として配布されている Adobe Symbol フォントであると解
 釈されることに注意してください。この代わりに、OpenOffice.org と一緒に
 "opens___.ttf" として配布される OpenSymbol フォントが同じ文字を提供
 しています。Microsoft も Symbol フォント ("symbol.ttf") を配布してい
 ますが、これは異なる文字セットになっていて、いくつかは欠けていますし、
 いくつかは数式記号に変わってしまっています。あなたのデフォルトの設定で
 なんらかの問題が起きた場合 (例えばデモスクリプト enhancedtext.dem がち
 ゃんと表示されないといった場合) は、Adobe か OpenOffice の Symbol フォ
 ントをインストールして、Microsoft の Symbol フォントを削除しないといけ
 ないかもしれません。
 "windings" のような他の非標準のフォントでも動作することが報告されて
 います。

 描画のレンダリングは、ツールバーで対話的に変更できます。可能な限り最も
 良い出力を生成するためにこのレンダリングは、アンチエイリアス、オーバー
 サンプリング、ヒンティングの 3 つの機構を持っています。
 アンチエイリアスは、水平や垂直でない線の滑らかな表示を可能にします。
 オーバーサンプリングは、アンチエイリアスと組でピクセルよりも小さいサイ
 ズでの精度を提供し、gnuplot が非整数座標の直線を書けるようになります。
 これは、対角方向の直線 (例えば 'plot x') が左右に揺れるのを避けます。
 ヒンティングは、オーバーサンプリングによって引き起こされる水平、垂直方
 向の線分のぼかしを避けます。この出力形式は、これらの直線を整数座標に揃
 え、それにより、1 ピクセル幅の直線は本当に 1 つ (1 つより多くも少なく
 もない) のピクセルで描画します。

 デフォルトでは、描画が行われたときにウィンドウはデスクトップの一番上
 (最前面) に表示されます。これは、キーワード "raise" で制御できます。
 キーワード "persist" は、すべての描画ウインドウを明示的に閉じない間
 は、gnuplot が終了しないようにします。
 最後に、デフォルトでは <space> キーは gnuplot コンソールウィンドウを上
 に上げ、'q' は描画ウィンドウを閉じます。キーワード "ctrl" は、それら
 のキー割り当てを、それぞれ <ctrl>+<space> と <ctrl>+'q' に変更します。
 これらの 3 つのキーワード (raise, persist, ctrl) は、設定ダイアログ上
 のやりとりでも設定し、記憶させることができます。
?commands set terminal x11
?set terminal x11
?set term x11
?terminal x11
?term x11
?x11
?X11

 書式:
    set terminal x11 {<n> | window "<string>"}
                     {title "<string>"}
                     {{no}enhanced} {font <fontspec>}
                     {linewidth LW}
                     {{no}persist} {{no}raise} {{no}ctrlq}
                     {{no}replotonresize}
                     {close}
                     {size XX,YY} {position XX,YY}
    set terminal x11 {reset}

 複数のグラフ描画ウィンドウをサポートしています。`set terminal x11 <n>`
 は番号 n の描画ウィンドウに出力します。n が 0 でなければ、タイトルが明
 示的に指定されていなければその番号がウィンドウタイトルとしてつけられ、
 アイコンには `Gnuplot <n>` とラベル付けされます。現在有効なウィンドウ
 はカーソル記号の変化で区別できます (デフォルトカーソルから十字カーソル
 へ)。

 `x11` 出力形式は、外部のアプリケーションによって生成されている X のウィ
 ンドウの X ID (16 進表記) をオプション `window` の後に文字列として指定
 することで、そのウィンドウと接続できます。X は複数のクライアントにイベ
 ント ButtonPress の選択を認めないため、gnuplot その外部ウィンドウをコン
 テナとして使用します。この方法により、gnuplot のマウス機能はとりこまれ
 た描画ウィンドウ内でも作動します。

    set term x11 window "220001e"

 x11 出力形式は、利用可能なフォントの元で拡張文字列処理モード (以下参照:
 `enhanced`) をサポートしています。文字列に埋め込まれ、様々な効果を与え
 るフォントサイズ命令のために、デフォルトの x11 フォントがスケーラブル
 フォントである必要があります。よって、以下の最初の例はうまくいくでしょ
 うが、2 番目のものはそうではないでしょう。

    set term x11 enhanced font "arial,15"
    set title '{/=20 Big} Medium {/=5 Small}'

    set term x11 enhanced font "terminal-14"
    set title '{/=20 Big} Medium {/=5 Small}'

 `gnuplot` ドライバが別な出力ドライバに変更されても、描画ウィンドウは開
 いたままになります。描画ウィンドウは、そのウィンドウにカーソルを置いて
 文字 q を押すか、ウィンドウマネージャのメニューの `close` を選択すれば
 閉じることができます。`reset` を実行すれば全てのウィンドウを一度に閉じ
 れます。それは実際にウィンドウを管理している子プロセスを終了します (も
 し `-persist` が指定されていなければ)。コマンド `close` は、個々の描画
 ウィンドウを番号を指定して閉じるのに使うことができます。しかし、persist
 のために残っているような描画ウィンドウは `close` コマンドでは閉じること
 はできません。番号を省略して `close` した場合には現在有効な描画ウィンド
 ウを閉じます。

 gnuplot の外にあるドライバ gnuplot_x11 は、プログラムのコンパイル時に
 選択されたデフォルトの場所が検索されます。これは環境変数
 GNUPLOT_DRIVER_DIR を異なる場所と定義することで変更できます。

 描画ウィンドウは `-persisit` オプションが与えられていなければ、対話の
 終了時に自動的に閉じられます。

 オプション `persist` と `raise` はデフォルトでは設定されていませんが、
 それは、デフォルトの値 (persist == no で raise == yes) か、コマンドラ
 インオプション -persist / -raise の指定か、または X のリソース値が使わ
 れる、ということを意味します。[no]persist か [no]raise が指定されると
 それはコマンドラインオプションや X リソースの設定よりも優先されます。
 これらのオプションの設定は直ちに効力を持ちますので、既に起動しているド
 ライバの挙動は変更されます。ウィンドウを前面に出せない場合は、以下参照:
 `raise`。

 オプション `replotonresize` (デフォルトで有効) は、描画ウィンドウのリ
 サイズ時にデータを再描画します。このオプションなしだと、アスペクト比の
 変わらない拡大であっても、リサイズ後にウィンドウの一部分にしか描画され
 ない可能性があります。このオプションを使えば、gnuplot は各リサイズイベ
 ント毎に完全な再描画を行いますので、枠内をより綺麗に使ってくれます。リ
 サイズの間の再描画による潜在的な CPU への負荷が心配でない場合、このオ
 プションは普通は望ましいものです。再描画は、ホットキー 'e' や 'replot'
 コマンドで手動で実行することも可能です。

 オプション `title "<title name>"` は現在の描画ウィンドウに、または番号
 を指定すればその番号の描画ウィンドウに対するウィンドウタイトル名をつけ
 ます。そのタイトルが表示される場所、または表示されるかどうかは、使って
 いる X のウィンドウマネージャに依存します。

 オプション size は、描画ウィンドウのサイズを設定するのに使用できます。
 このオプションは、その後に生成するウィンドウのみに適用されます。

 オプション position は、描画ウィンドウの位置を設定するのに使えます。
 このオプションは、その後に生成するウィンドウのみに適用されます。

 描画サイズとアスペクト比は、`gnuplot` のウィンドウをリサイズすることで
 も変更できます。

 線の幅と点のサイズは `gnuplot` の `set linestyle` で変更可能です。

 出力ドライバ `x11` に関しては、`gnuplot` は (起動時に)、コマンドライン、
 または設定ファイルから、geometry や font, name などの通常の X Toolkit
 オプションやリソースの指定を受け付けます。それらのオプションについては
 X(1) マニュアルページ (やそれと同等のもの) を参照してください。

 他にも `x11` 出力形式用の多くの `gnuplot` のオプションがあります。これ
 らは `gnuplot` を呼ぶときにコマンドラインオプションとして指定するか、
 または設定ファイル ".Xdefaults" のリソースとして指定できます。これら
 は起動時に設定されるので、`gnuplot` 実行時には変更できません
 (`persist` と `raise` 以外は)。
?commands set terminal x11 x11_fonts
?set terminal x11 x11_fonts
?set term x11 x11_fonts
?x11 x11_fonts
?x11_fonts
 初期起動時は、システムの設定か、ユーザの .Xdefaults ファイルの設定か、
 コマンドライン指定か、のいずれかによる X11 リソースによってデフォルト
 のフォントが選択されます。

 例:
       gnuplot*font: lucidasans-bold-12
 新しいデフォルトのフォントを、gnuplot 内部から x11 ドライバに以下のよ
 うにして指示することもできます:
      `set term x11 font "<fontspec>"`
 まず x11 ドライバは、与えられたフォントの正式名を X サーバに尋ねます。
 この問い合わせが失敗した場合、<fontspec> を
 "<font>,<size>,<slant>,<weight>" と解釈し、以下の形の完全な X11 フォ
 ント名を生成しようとします:
       -*-<font>-<weight>-<s>-*-*-<size>-*-*-*-*-*-<encoding>

  <font> はフォントの基本名 (base name) (例: Times, Symbol)
  <size> はポイントサイズ (指定がなければデフォルトは 12)
  <s> は <slant>=="italic" なら `i`, <slant>=="oblique" なら `o`, その他は `r`
  <weight> は明示的に指定されれば `medium` か `bold`、その他は `*`
  <encoding> は現在の文字集合に基づいて設定 (以下参照: `set encoding`)
 よって `set term x11 font "arial,15,italic"` は (デフォルトの encoding
 だとすれば) -*-arial-*-i-*-*-15-*-*-*-*-*-iso8859-1 に変換されます。
 <size>, <slant>, <weight> 指定はいずれも必須ではありません。<slant> や
 <weight> を指定しなかった場合は、フォントサーバが最初に見つけた、変種
 のフォントを取得するかもしれません。
 デフォルトのエンコーディングは、対応する X11 リソースを使って設定するこ
 ともできます。例:
       gnuplot*encoding: iso8859-15
 x11 ドライバは、一般的な PostScript フォント名も認識し、それと同等で有
 効な X11 フォントか TrueType フォントに置き換えます。
 これと同じ手順が、`set label` の要求によるフォントの生成でも使われてい
 ます。

 あなたの gnuplot が configure の --enable-x11-mbfonts オプションをつけ
 てインストールされたものなら、フォント名の前に "mbfont:" をつけるこ
 とでマルチバイトフォントを指定することができます。フォント名を複数指定
 する個ともできますが、その場合はセミコロンで区切ります。マルチバイトフ
 ォントのエンコーディングは locale の設定に従いますので、環境変数
 LC_CTYPE を適切な値 (例えば ja_JP.eucJP, ko_KR.EUC, zh_CN.EUC など) に
 に設定する必要があります。

 例:
       set term x11 font 'mbfont:kana14;k14'
             # 'kana14' と 'k14' は日本語の X11 font エイリアス名、';'
             # はフォント名の区切りです。
       set term x11 font 'mbfont:fixed,16,r,medium'
             # <font>,<size>,<slant>,<weight> 形式も使用できます。
       set title '(mb strings)' font 'mbfont:*-fixed-medium-r-normal--14-*'

 同じ書式は X のリソースでのデフォルトフォントの設定でも有効です。例:
       gnuplot*font: \
           mbfont:-misc-fixed-medium-r-normal--14-*-*-*-c-*-jisx0208.1983-0

 gnuplot が --enable-x11-mbfonts でインストールされた場合、"mbfont:"
 をつけなくても 2 つの特別な PostScript フォント名 'Ryumin-Light-*',
 'GothicBBB-Medium-*' (標準的な日本語 PS フォント) を使うこともできます。

?commands set terminal x11 command-line-options
?set terminal x11 command-line-options
?set term x11 command-line-options
?x11 command-line-options
 X Toolkit オプションに加え、以下のオプションが gnuplot の立ち上げ時の
 コマンドラインで、またはユーザのファイル ".Xdefaults" 内のリソースとし
 て指定できます (`raise` と `persist` は `set term x11 [no]raise [no]persist`
 によって上書きされることに注意してください):
  `-mono`     カラーディスプレイ上で強制的に白黒描画
  `-gray`     グレイスケールまたはカラーディスプレイ上でのグレイスケール描画
              (デフォルトではグレイスケールディスプレイは白黒描画を受け付ける)
  `-clear`    新しい描画を表示する前に (瞬間的に) 画面を消去
  `-tvtwm`    geometry オプションによる位置の指定を、仮想ルートウィンドウ中の
              現在の表示部分に対する相対的な位置にする
  `-raise`    各描画後に描画ウィンドウを最前面へ出す
  `-noraise`  各描画後に描画ウィンドウを最前面へ出すことはしない
  `-ctrlq   ` ウィンドウを q でなく ctrl-q で閉じる
  `-persist`  gnuplot プログラム終了後も描画ウィンドウを残す
 上記のオプションはコマンドライン上での指定書式で、".Xdefaults" にリ
 ソースとして指定するときは異なる書式を使います。

 例:
       gnuplot*gray:  on
       gnuplot*ctrlq: on

 `gnuplot` は描画スタイル `points` で描画する点のサイズの制御にも、コマンド
 ラインオプション (`-pointsize <v>`) とリソース (`gnuplot*pointsize: <v>`)
 を提供しています。値 `v` は点のサイズの拡大率として使われる実数値
 (0 < v <= 10) で、例えば `-pointsize 2` はデフォルトのサイズの 2 倍、
 `-pointsize 0.5` は普通のサイズの半分の点が使われます。

 `-ctrlq` スィッチは、描画ウィンドウを閉じるホットキーを `q` から
 `<ctrl>q` に変更します。これは、`pause mouse keystroke` によるキースト
 ロークの保存機能を使っている場合には、他のアルファベット文字と同様に
 `q` を保存できるようになるので有用でしょう。同じ理由で、`-ctrlq` スィ
 ッチは <space> ホットキーも <ctrl><space> に置き換えます。

?set terminal x11 color_resources
?set term x11 color_resources
?x11 color_resources
 注意: このセクションは、gnuplot バージョン 5 とは大きくずれています。
 x11 出力形式は以下のリソース (ここではそのデフォルトの値を示します)、
 または白黒階調 (greyscale) のリソースを参照します。リソースの値はシス
 テム上の X11 rgb.txt ファイルに書かれている色名、または 16 進の色指定
 (X11 のマニュアルを参照) か、色名と強度 (0 から 1 の間の値) をコンマで
 区切った値を使用できます。例えば `blue, 0.5` は半分の強度の青、を意味
 します。
  gnuplot*background:  white
  gnuplot*textColor:   black
  gnuplot*borderColor: black
  gnuplot*axisColor:   black
  gnuplot*line1Color:  red
  gnuplot*line2Color:  green
  gnuplot*line3Color:  blue
  gnuplot*line4Color:  magenta
  gnuplot*line5Color:  cyan
  gnuplot*line6Color:  sienna
  gnuplot*line7Color:  orange
  gnuplot*line8Color:  coral

 これらに関するコマンドラインの書式は、背景 (bacground) に関しては単純で
 通常の X11 toolkit オプションの "-bg" に直接対応します。他のものも、
 全て一般的なリソースの上書きオプション "-xrm" を使うことで設定できま
 す。

 例:

 背景色を変更するには
       gnuplot -background coral

 線種 1 番目の色を書き換えるには
       gnuplot -xrm 'gnuplot*line1Color:blue'

?commands set terminal x11 grayscale_resources
?set terminal x11 grayscale_resources
?set term x11 grayscale_resources
?x11 grayscale_resources
?grayscale_resources
 `-gray` を選択すると、`gnuplot` は、グレイスケールまたはカラーディスプ
 レイに対して、以下のリソースを参照します (ここではそのデフォルトの値を
 示します)。デフォルトの背景色は黒であることに注意してください。
  gnuplot*background: black
  gnuplot*textGray:   white
  gnuplot*borderGray: gray50
  gnuplot*axisGray:   gray50
  gnuplot*line1Gray:  gray100
  gnuplot*line2Gray:  gray60
  gnuplot*line3Gray:  gray80
  gnuplot*line4Gray:  gray40
  gnuplot*line5Gray:  gray90
  gnuplot*line6Gray:  gray50
  gnuplot*line7Gray:  gray70
  gnuplot*line8Gray:  gray30

?set terminal x11 line_resources
?set term x11 line_resources
?x11 line_resources
 注意: このセクションは、gnuplot バージョン 5 とは大きくずれています。
 `gnuplot` は描画の線の幅 (ピクセル単位) の設定のために以下のリソースを
 参照します (ここではそのデフォルトの値を示します)。0 または 1 は最小の
 線幅の 1 ピクセル幅を意味します。2 または 3 の値によってグラフの外観を
 改善できる場合もあるでしょう。
  gnuplot*borderWidth: 1
  gnuplot*axisWidth:   0
  gnuplot*line1Width:  0
  gnuplot*line2Width:  0
  gnuplot*line3Width:  0
  gnuplot*line4Width:  0
  gnuplot*line5Width:  0
  gnuplot*line6Width:  0
  gnuplot*line7Width:  0
  gnuplot*line8Width:  0

 `gnuplot` は線描画で使用する点線の形式の設定用に以下のリソースを参照し
 ます。0 は実線を意味します。2 桁の 10 進数 `jk` (`j` と `k` は 1 から
 9 までの値) は、`j` 個のピクセルの描画に `k` 個の空白のピクセルが続く
 パターンの繰り返しからなる点線を意味します。例えば '16' は 1 個のピク
 セルの後に 6 つの空白が続くパターンの点線になります。さらに、4 桁の 10
 進数でより詳細なピクセルと空白の列のパターンを指定できます。例えば、
 '4441' は 4 つのピクセル、4 つの空白、4 つのピクセル、1 つの空白のパタ
 ーンを意味します。以下のデフォルトのリソース値は、白黒ディスプレイ、あ
 るいはカラーや白黒階調 (grayscale) ディスプレイ上の白黒描画における値
 です。
 カラーディスプレイでは dashed:off がデフォルトになっています。
  gnuplot*dashed:       off
  gnuplot*borderDashes:   0
  gnuplot*axisDashes:    16
  gnuplot*line1Dashes:    0
  gnuplot*line2Dashes:   42
  gnuplot*line3Dashes:   13
  gnuplot*line4Dashes:   44
  gnuplot*line5Dashes:   15
  gnuplot*line6Dashes: 4441
  gnuplot*line7Dashes:   42
  gnuplot*line8Dashes:   13

?set terminal x11 pm3d_resources
?set term x11 pm3d_resources
?x11 pm3d_resources
?x11 pm3d
 注意: このセクションは、gnuplot バージョン 5 とは大きくずれています。
 適切な visual クラスと色数を選択するのは、X11 アプリケーションにとって
 苦しく、ちょっと厄介なことです。それは X11 が異なる深度 (depth) の 6
 つの visual 型をサポートしているからです。

 デフォルトでは `gnuplot` はそのスクリーンのデフォルトの visual を使用
 します。割り当てることのできる色数は選択された visual クラスによって変
 わります。12bit を超える深度を持つ visual クラス上では、gnuplot は最大
 色数である 0x200 (=512) 色で起動します。8bit を超える (12bit 以下で)
 深度の visual クラスでは最大色数は 0x100 (=256) 色、8bit 以下のディス
 プレイでは最大色は 240 (16 色は曲線の色用に取られる) になります。

 gnuplot は最初に、上に述べたような最大色を割り当てようと起動します。こ
 れに失敗するとその色数は、gnuplot がその全部を割り付けることができるま
 で、1/2 ずつ減らされます。`maxcolors` を繰り返し 2 で割った結果、
 `mincolors` よりも小さい数字になった場合、`gnuplot` は private カラー
 マップを使おうとします。この場合、ウィンドウマネージャは、ポインタが
 X11 ドライバのウィンドウに入るか出るかでカラーマップを退避 (swapping)
 させる責任を持つことになります。

 `mincolors` のデフォルトの値は maxcolors / (num_colormaps > 1 ? 2 : 8)
 で、num_colormaps は gnuplot が現在使用しているカラーマップの数で、こ
 れは、x11 のウィンドウが 1 つだけ開いているような通常の場合は 1 です。

 複数の (異なる) visual クラスを、一つのスクリーン上でサポートするよう
 なシステムもあります。このようなシステムでは、gnuplot に指定した
 visual クラスを強制的に使わせる必要があります。例えば、デフォルトの
 visual が 8bit PseudoColor だけれどもスクリーンは 24bit TrueColor を
 サポートしていてむしろこちらの方を選択すべきであるような場合です。

 X サーバの能力に関する情報はプログラム `xdpyinfo` で取得できます。
 visual 名は次のうちの一つが選択できます: StaticGray, GrayScale,
 StaticColor, PseudoColor, TrueColor, DirectColor。その X サーバが要求
 された visual 型の異なる複数の深度をサポートしている場合、`gnuplot` は
 最も大きい (最深の) 深度の visual クラスを選択します。要求された
 visual クラスがデフォルトの visual とあっていて、その型の複数のクラス
 がサポートされている場合は、デフォルトの visual が選択されます。

 例: 8bit PseudoColor の visual 上では、`gnuplot*maxcolors: 240`、及び
 `gnuplot*mincolors: 240` と指定することで強制的に private カラーマップ
 を使うようにできます。

  gnuplot*maxcolors:  <整数>
  gnuplot*mincolors:  <整数>
  gnuplot*visual:     <visual 名>

?commands set terminal x11 other_resources
?set terminal x11 other_resources
?set term x11 other_resources
?x11 other_resources
 デフォルトでは、現在の描画ウィンドウの内容は、ウィンドウの X イベント
 に従って X11 クリップボードに送られます。'gnuplot*exportselection' の
 リソースの値を 'off' か 'false' と設定することによりこれを無効にできま
 す。

 デフォルトでは、文字の回転は速くそれを行なう方法が使われますが、背景色
 によってはその付近が汚れることがあります。これが起こる場合は、リソース
 'gnuplot.fastrotate' を 'off' にしてみてください。

  gnuplot*exportselection:  off
  gnuplot*fastrotate:  on
  gnuplot*ctrlq:  off
?commands set terminal xlib
?set terminal xlib
?set term xlib
?terminal xlib
?term xlib
?xlib
 `xlib` ドライバは X11 Windows System をサポートしています。このドライ
 バは gnuplot_x11 への命令を生成しますが、`set output '<filename>'` を
 指定するとそれらをファイルに書き出します。`set term x11` は、
 `set output "|gnuplot_x11 -noevents"; set term xlib` と同値です。
 `xlib` には `x11` と同じオプションの組を与えることができます。
?bugs
 バグリポートは e-mail で gnuplot-bugs メーリングリストへ送るか、または
 SourceForge の gnuplot ウェブサイトにその報告を投稿してください。その
 際、あなたが使用している gnuplot のバージョンの完全な情報、そして可能
 ならばそのバグを実証するテストスクリプトを送ってください。以下参照:
 `seeking-assistance`。

 `do` や `while` ループの中括弧内でインラインデータ (例: plot '-' ...)
 を使うことはできません。


 ガンマ関数とベッセル関数は複素数引数をサポートしていません。

 "時刻" として指定された座標は 24 時で折り返します。

 媒介変数の曲線: `nohidden3d` は、全体的な設定である `set hidden3d` を
 個々のグラフに対して免除するためのオプションですが、これは媒介変数の曲
 線 (parametric) に対しては機能しません。
 コマンド `plot` 内の繰り返し (iteration) は、媒介変数の曲線に対しては
 機能しません。

 X11 出力形式: UTF-8 フォントの選択が困難です。
 すべての x11 描画ウィンドウに対して、一度には 1 つのカラーパレットのみ
 が有効です。これは、異なるパレットを使用する描画を含んだ multiplot で
 は x11 上では正しく表示されないことを意味します。

 Qt 出力形式: 3 次元での多角形や曲面の回転は遅くなる可能性がありますが、
 これは Qt のレンダリングモード (Qt の説明書を参照してください) に強く
 依存します。

 `raise` と `lower` の機能はあまり当てにできません。

?bugs external_libraries
 外部ライブラリ GD (PNG/JPEG/GIF ドライバで使用):
 バージョン 2.0.33 までの libgd には、Adobe の Symbol フォントの文字の
 マッピングに関するいくつかのバグがありました。また、アンチエイリアスさ
 れた線分がキャンバスの上の角と交わる場合に、ライブラリがセグメンテーシ
 ョンフォルトを引き起すこともありました。

 外部ライブラリ PDFlib (PDF ドライバで使用):
 gnuplot は libpdf のバージョン 4, 5, 6 のいずれかをリンクできます。し
 かし、これらはバージョンによってパイプされた入出力の処理が違っています
 ので、パイプを使って PDF を出力する gnuplot スクリプトは、PDFlib のあ
 るバージョンでだけしかちゃんと動かないかもしれません。

 外部ライブラリ svgalib (linux, vgadl ドライバで使用):
 これは gnuplot が root に setuid (嫌!) されることを要求しますし、ビデ
 オカードや X11 で使用されるグラフィックドライバに特有の多くのバグがあ
 ります。

 国際化 (ロケールの設定):
 gnuplot は、入出力の数、時刻、日付文字列のロケールに依存した書式の制御
 を、C ランタイムライブラリに含まれる setlocale() を用いて行うので、ロ
 ケールの有効性や、ロケール機能のサポートのレベル (例えば数字の 3 桁毎
 の区切り文字など) などは、あなたのコンピュータが提供する国際化のサポー
 トの度合いに依存します。
